/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/eve-raphael/eve.js":
/*!*****************************************!*\
  !*** ./node_modules/eve-raphael/eve.js ***!
  \*****************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// ┌────────────────────────────────────────────────────────────┐ \\\\\n// │ Eve 0.5.0 - JavaScript Events Library                      │ \\\\\n// ├────────────────────────────────────────────────────────────┤ \\\\\n// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\\\\n// └────────────────────────────────────────────────────────────┘ \\\\\n\n(function (glob) {\n    var version = \"0.5.0\",\n        has = \"hasOwnProperty\",\n        separator = /[\\.\\/]/,\n        comaseparator = /\\s*,\\s*/,\n        wildcard = \"*\",\n        fun = function () {},\n        numsort = function (a, b) {\n            return a - b;\n        },\n        current_event,\n        stop,\n        events = {n: {}},\n        firstDefined = function () {\n            for (var i = 0, ii = this.length; i < ii; i++) {\n                if (typeof this[i] != \"undefined\") {\n                    return this[i];\n                }\n            }\n        },\n        lastDefined = function () {\n            var i = this.length;\n            while (--i) {\n                if (typeof this[i] != \"undefined\") {\n                    return this[i];\n                }\n            }\n        },\n        objtos = Object.prototype.toString,\n        Str = String,\n        isArray = Array.isArray || function (ar) {\n            return ar instanceof Array || objtos.call(ar) == \"[object Array]\";\n        };\n    /*\\\n     * eve\n     [ method ]\n\n     * Fires event with given `name`, given scope and other parameters.\n\n     > Arguments\n\n     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\n     - scope (object) context for the event handlers\n     - varargs (...) the rest of arguments will be sent to event handlers\n\n     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.\n    \\*/\n        var eve = function (name, scope) {\n            var e = events,\n                oldstop = stop,\n                args = Array.prototype.slice.call(arguments, 2),\n                listeners = eve.listeners(name),\n                z = 0,\n                f = false,\n                l,\n                indexed = [],\n                queue = {},\n                out = [],\n                ce = current_event,\n                errors = [];\n            out.firstDefined = firstDefined;\n            out.lastDefined = lastDefined;\n            current_event = name;\n            stop = 0;\n            for (var i = 0, ii = listeners.length; i < ii; i++) if (\"zIndex\" in listeners[i]) {\n                indexed.push(listeners[i].zIndex);\n                if (listeners[i].zIndex < 0) {\n                    queue[listeners[i].zIndex] = listeners[i];\n                }\n            }\n            indexed.sort(numsort);\n            while (indexed[z] < 0) {\n                l = queue[indexed[z++]];\n                out.push(l.apply(scope, args));\n                if (stop) {\n                    stop = oldstop;\n                    return out;\n                }\n            }\n            for (i = 0; i < ii; i++) {\n                l = listeners[i];\n                if (\"zIndex\" in l) {\n                    if (l.zIndex == indexed[z]) {\n                        out.push(l.apply(scope, args));\n                        if (stop) {\n                            break;\n                        }\n                        do {\n                            z++;\n                            l = queue[indexed[z]];\n                            l && out.push(l.apply(scope, args));\n                            if (stop) {\n                                break;\n                            }\n                        } while (l)\n                    } else {\n                        queue[l.zIndex] = l;\n                    }\n                } else {\n                    out.push(l.apply(scope, args));\n                    if (stop) {\n                        break;\n                    }\n                }\n            }\n            stop = oldstop;\n            current_event = ce;\n            return out;\n        };\n        // Undocumented. Debug only.\n        eve._events = events;\n    /*\\\n     * eve.listeners\n     [ method ]\n\n     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\n\n     > Arguments\n\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated\n\n     = (array) array of event handlers\n    \\*/\n    eve.listeners = function (name) {\n        var names = isArray(name) ? name : name.split(separator),\n            e = events,\n            item,\n            items,\n            k,\n            i,\n            ii,\n            j,\n            jj,\n            nes,\n            es = [e],\n            out = [];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            nes = [];\n            for (j = 0, jj = es.length; j < jj; j++) {\n                e = es[j].n;\n                items = [e[names[i]], e[wildcard]];\n                k = 2;\n                while (k--) {\n                    item = items[k];\n                    if (item) {\n                        nes.push(item);\n                        out = out.concat(item.f || []);\n                    }\n                }\n            }\n            es = nes;\n        }\n        return out;\n    };\n    /*\\\n     * eve.separator\n     [ method ]\n\n     * If for some reasons you don’t like default separators (`.` or `/`) you can specify yours\n     * here. Be aware that if you pass a string longer than one character it will be treated as\n     * a list of characters.\n\n     - separator (string) new separator. Empty string resets to default: `.` or `/`.\n    \\*/\n    eve.separator = function (sep) {\n        if (sep) {\n            sep = Str(sep).replace(/(?=[\\.\\^\\]\\[\\-])/g, \"\\\\\");\n            sep = \"[\" + sep + \"]\";\n            separator = new RegExp(sep);\n        } else {\n            separator = /[\\.\\/]/;\n        }\n    };\n    /*\\\n     * eve.on\n     [ method ]\n     **\n     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:\n     | eve.on(\"*.under.*\", f);\n     | eve(\"mouse.under.floor\"); // triggers f\n     * Use @eve to trigger the listener.\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     - name (array) if you don’t want to use separators, you can use array of strings\n     - f (function) event handler function\n     **\n     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. \n     > Example:\n     | eve.on(\"mouse\", eatIt)(2);\n     | eve.on(\"mouse\", scream);\n     | eve.on(\"mouse\", catchIt)(1);\n     * This will ensure that `catchIt` function will be called before `eatIt`.\n     *\n     * If you want to put your handler before non-indexed handlers, specify a negative value.\n     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.\n    \\*/\n    eve.on = function (name, f) {\n        if (typeof f != \"function\") {\n            return function () {};\n        }\n        var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);\n        for (var i = 0, ii = names.length; i < ii; i++) {\n            (function (name) {\n                var names = isArray(name) ? name : Str(name).split(separator),\n                    e = events,\n                    exist;\n                for (var i = 0, ii = names.length; i < ii; i++) {\n                    e = e.n;\n                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});\n                }\n                e.f = e.f || [];\n                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {\n                    exist = true;\n                    break;\n                }\n                !exist && e.f.push(f);\n            }(names[i]));\n        }\n        return function (zIndex) {\n            if (+zIndex == +zIndex) {\n                f.zIndex = +zIndex;\n            }\n        };\n    };\n    /*\\\n     * eve.f\n     [ method ]\n     **\n     * Returns function that will fire given event with optional arguments.\n     * Arguments that will be passed to the result function will be also\n     * concated to the list of final arguments.\n     | el.onclick = eve.f(\"click\", 1, 2);\n     | eve.on(\"click\", function (a, b, c) {\n     |     console.log(a, b, c); // 1, 2, [event object]\n     | });\n     > Arguments\n     - event (string) event name\n     - varargs (…) and any other arguments\n     = (function) possible event handler function\n    \\*/\n    eve.f = function (event) {\n        var attrs = [].slice.call(arguments, 1);\n        return function () {\n            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\n        };\n    };\n    /*\\\n     * eve.stop\n     [ method ]\n     **\n     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\n    \\*/\n    eve.stop = function () {\n        stop = 1;\n    };\n    /*\\\n     * eve.nt\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     > Arguments\n     **\n     - subname (string) #optional subname of the event\n     **\n     = (string) name of the event, if `subname` is not specified\n     * or\n     = (boolean) `true`, if current event’s name contains `subname`\n    \\*/\n    eve.nt = function (subname) {\n        var cur = isArray(current_event) ? current_event.join(\".\") : current_event;\n        if (subname) {\n            return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(cur);\n        }\n        return cur;\n    };\n    /*\\\n     * eve.nts\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     **\n     = (array) names of the event\n    \\*/\n    eve.nts = function () {\n        return isArray(current_event) ? current_event : current_event.split(separator);\n    };\n    /*\\\n     * eve.off\n     [ method ]\n     **\n     * Removes given function from the list of event listeners assigned to given name.\n     * If no arguments specified all the events will be cleared.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n    \\*/\n    /*\\\n     * eve.unbind\n     [ method ]\n     **\n     * See @eve.off\n    \\*/\n    eve.off = eve.unbind = function (name, f) {\n        if (!name) {\n            eve._events = events = {n: {}};\n            return;\n        }\n        var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);\n        if (names.length > 1) {\n            for (var i = 0, ii = names.length; i < ii; i++) {\n                eve.off(names[i], f);\n            }\n            return;\n        }\n        names = isArray(name) ? name : Str(name).split(separator);\n        var e,\n            key,\n            splice,\n            i, ii, j, jj,\n            cur = [events];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            for (j = 0; j < cur.length; j += splice.length - 2) {\n                splice = [j, 1];\n                e = cur[j].n;\n                if (names[i] != wildcard) {\n                    if (e[names[i]]) {\n                        splice.push(e[names[i]]);\n                    }\n                } else {\n                    for (key in e) if (e[has](key)) {\n                        splice.push(e[key]);\n                    }\n                }\n                cur.splice.apply(cur, splice);\n            }\n        }\n        for (i = 0, ii = cur.length; i < ii; i++) {\n            e = cur[i];\n            while (e.n) {\n                if (f) {\n                    if (e.f) {\n                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {\n                            e.f.splice(j, 1);\n                            break;\n                        }\n                        !e.f.length && delete e.f;\n                    }\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        var funcs = e.n[key].f;\n                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {\n                            funcs.splice(j, 1);\n                            break;\n                        }\n                        !funcs.length && delete e.n[key].f;\n                    }\n                } else {\n                    delete e.f;\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        delete e.n[key].f;\n                    }\n                }\n                e = e.n;\n            }\n        }\n    };\n    /*\\\n     * eve.once\n     [ method ]\n     **\n     * Binds given event handler with a given name to only run once then unbind itself.\n     | eve.once(\"login\", f);\n     | eve(\"login\"); // triggers f\n     | eve(\"login\"); // no listeners\n     * Use @eve to trigger the listener.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     = (function) same return function as @eve.on\n    \\*/\n    eve.once = function (name, f) {\n        var f2 = function () {\n            eve.off(name, f2);\n            return f.apply(this, arguments);\n        };\n        return eve.on(name, f2);\n    };\n    /*\\\n     * eve.version\n     [ property (string) ]\n     **\n     * Current version of the library.\n    \\*/\n    eve.version = version;\n    eve.toString = function () {\n        return \"You are running Eve \" + version;\n    };\n    ( true && module.exports) ? (module.exports = eve) : ( true ? (!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() { return eve; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))) : (0));\n})(this);\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/eve-raphael/eve.js?");

/***/ }),

/***/ "./node_modules/inversify/es/annotation/decorator_utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/inversify/es/annotation/decorator_utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createTaggedDecorator: () => (/* binding */ createTaggedDecorator),\n/* harmony export */   decorate: () => (/* binding */ decorate),\n/* harmony export */   tagParameter: () => (/* binding */ tagParameter),\n/* harmony export */   tagProperty: () => (/* binding */ tagProperty)\n/* harmony export */ });\n/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/error_msgs */ \"./node_modules/inversify/es/constants/error_msgs.js\");\n/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/metadata_keys */ \"./node_modules/inversify/es/constants/metadata_keys.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/js */ \"./node_modules/inversify/es/utils/js.js\");\n\r\n\r\n\r\nfunction targetIsConstructorFunction(target) {\r\n    return target.prototype !== undefined;\r\n}\r\nfunction _throwIfMethodParameter(parameterName) {\r\n    if (parameterName !== undefined) {\r\n        throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.INVALID_DECORATOR_OPERATION);\r\n    }\r\n}\r\nfunction tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {\r\n    _throwIfMethodParameter(parameterName);\r\n    _tagParameterOrProperty(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__.TAGGED, annotationTarget, parameterIndex.toString(), metadata);\r\n}\r\nfunction tagProperty(annotationTarget, propertyName, metadata) {\r\n    if (targetIsConstructorFunction(annotationTarget)) {\r\n        throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.INVALID_DECORATOR_OPERATION);\r\n    }\r\n    _tagParameterOrProperty(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__.TAGGED_PROP, annotationTarget.constructor, propertyName, metadata);\r\n}\r\nfunction _ensureNoMetadataKeyDuplicates(metadata) {\r\n    var metadatas = [];\r\n    if (Array.isArray(metadata)) {\r\n        metadatas = metadata;\r\n        var duplicate = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.getFirstArrayDuplicate)(metadatas.map(function (md) { return md.key; }));\r\n        if (duplicate !== undefined) {\r\n            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.DUPLICATED_METADATA + \" \" + duplicate.toString());\r\n        }\r\n    }\r\n    else {\r\n        metadatas = [metadata];\r\n    }\r\n    return metadatas;\r\n}\r\nfunction _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {\r\n    var metadatas = _ensureNoMetadataKeyDuplicates(metadata);\r\n    var paramsOrPropertiesMetadata = {};\r\n    if (Reflect.hasOwnMetadata(metadataKey, annotationTarget)) {\r\n        paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);\r\n    }\r\n    var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];\r\n    if (paramOrPropertyMetadata === undefined) {\r\n        paramOrPropertyMetadata = [];\r\n    }\r\n    else {\r\n        var _loop_1 = function (m) {\r\n            if (metadatas.some(function (md) { return md.key === m.key; })) {\r\n                throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.DUPLICATED_METADATA + \" \" + m.key.toString());\r\n            }\r\n        };\r\n        for (var _i = 0, paramOrPropertyMetadata_1 = paramOrPropertyMetadata; _i < paramOrPropertyMetadata_1.length; _i++) {\r\n            var m = paramOrPropertyMetadata_1[_i];\r\n            _loop_1(m);\r\n        }\r\n    }\r\n    paramOrPropertyMetadata.push.apply(paramOrPropertyMetadata, metadatas);\r\n    paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;\r\n    Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);\r\n}\r\nfunction createTaggedDecorator(metadata) {\r\n    return function (target, targetKey, indexOrPropertyDescriptor) {\r\n        if (typeof indexOrPropertyDescriptor === 'number') {\r\n            tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);\r\n        }\r\n        else {\r\n            tagProperty(target, targetKey, metadata);\r\n        }\r\n    };\r\n}\r\nfunction _decorate(decorators, target) {\r\n    Reflect.decorate(decorators, target);\r\n}\r\nfunction _param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); };\r\n}\r\nfunction decorate(decorator, target, parameterIndexOrProperty) {\r\n    if (typeof parameterIndexOrProperty === 'number') {\r\n        _decorate([_param(parameterIndexOrProperty, decorator)], target);\r\n    }\r\n    else if (typeof parameterIndexOrProperty === 'string') {\r\n        Reflect.decorate([decorator], target, parameterIndexOrProperty);\r\n    }\r\n    else {\r\n        _decorate([decorator], target);\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/annotation/decorator_utils.js?");

/***/ }),

/***/ "./node_modules/inversify/es/annotation/inject.js":
/*!********************************************************!*\
  !*** ./node_modules/inversify/es/annotation/inject.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   inject: () => (/* binding */ inject)\n/* harmony export */ });\n/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/metadata_keys */ \"./node_modules/inversify/es/constants/metadata_keys.js\");\n/* harmony import */ var _inject_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inject_base */ \"./node_modules/inversify/es/annotation/inject_base.js\");\n\r\n\r\nvar inject = (0,_inject_base__WEBPACK_IMPORTED_MODULE_0__.injectBase)(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__.INJECT_TAG);\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/annotation/inject.js?");

/***/ }),

/***/ "./node_modules/inversify/es/annotation/inject_base.js":
/*!*************************************************************!*\
  !*** ./node_modules/inversify/es/annotation/inject_base.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   injectBase: () => (/* binding */ injectBase)\n/* harmony export */ });\n/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/error_msgs */ \"./node_modules/inversify/es/constants/error_msgs.js\");\n/* harmony import */ var _planning_metadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../planning/metadata */ \"./node_modules/inversify/es/planning/metadata.js\");\n/* harmony import */ var _decorator_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decorator_utils */ \"./node_modules/inversify/es/annotation/decorator_utils.js\");\n\r\n\r\n\r\nfunction injectBase(metadataKey) {\r\n    return function (serviceIdentifier) {\r\n        return function (target, targetKey, indexOrPropertyDescriptor) {\r\n            if (serviceIdentifier === undefined) {\r\n                var className = typeof target === 'function' ? target.name : target.constructor.name;\r\n                throw new Error((0,_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.UNDEFINED_INJECT_ANNOTATION)(className));\r\n            }\r\n            return (0,_decorator_utils__WEBPACK_IMPORTED_MODULE_1__.createTaggedDecorator)(new _planning_metadata__WEBPACK_IMPORTED_MODULE_2__.Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);\r\n        };\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/annotation/inject_base.js?");

/***/ }),

/***/ "./node_modules/inversify/es/annotation/injectable.js":
/*!************************************************************!*\
  !*** ./node_modules/inversify/es/annotation/injectable.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   injectable: () => (/* binding */ injectable)\n/* harmony export */ });\n/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/error_msgs */ \"./node_modules/inversify/es/constants/error_msgs.js\");\n/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/metadata_keys */ \"./node_modules/inversify/es/constants/metadata_keys.js\");\n\r\n\r\nfunction injectable() {\r\n    return function (target) {\r\n        if (Reflect.hasOwnMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__.PARAM_TYPES, target)) {\r\n            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_1__.DUPLICATED_INJECTABLE_DECORATOR);\r\n        }\r\n        var types = Reflect.getMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__.DESIGN_PARAM_TYPES, target) || [];\r\n        Reflect.defineMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__.PARAM_TYPES, types, target);\r\n        return target;\r\n    };\r\n}\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/annotation/injectable.js?");

/***/ }),

/***/ "./node_modules/inversify/es/annotation/lazy_service_identifier.js":
/*!*************************************************************************!*\
  !*** ./node_modules/inversify/es/annotation/lazy_service_identifier.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LazyServiceIdentifier: () => (/* binding */ LazyServiceIdentifier)\n/* harmony export */ });\nvar LazyServiceIdentifier = (function () {\r\n    function LazyServiceIdentifier(cb) {\r\n        this._cb = cb;\r\n    }\r\n    LazyServiceIdentifier.prototype.unwrap = function () {\r\n        return this._cb();\r\n    };\r\n    return LazyServiceIdentifier;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/annotation/lazy_service_identifier.js?");

/***/ }),

/***/ "./node_modules/inversify/es/annotation/multi_inject.js":
/*!**************************************************************!*\
  !*** ./node_modules/inversify/es/annotation/multi_inject.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   multiInject: () => (/* binding */ multiInject)\n/* harmony export */ });\n/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/metadata_keys */ \"./node_modules/inversify/es/constants/metadata_keys.js\");\n/* harmony import */ var _inject_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inject_base */ \"./node_modules/inversify/es/annotation/inject_base.js\");\n\r\n\r\nvar multiInject = (0,_inject_base__WEBPACK_IMPORTED_MODULE_0__.injectBase)(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__.MULTI_INJECT_TAG);\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/annotation/multi_inject.js?");

/***/ }),

/***/ "./node_modules/inversify/es/annotation/named.js":
/*!*******************************************************!*\
  !*** ./node_modules/inversify/es/annotation/named.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   named: () => (/* binding */ named)\n/* harmony export */ });\n/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/metadata_keys */ \"./node_modules/inversify/es/constants/metadata_keys.js\");\n/* harmony import */ var _planning_metadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../planning/metadata */ \"./node_modules/inversify/es/planning/metadata.js\");\n/* harmony import */ var _decorator_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decorator_utils */ \"./node_modules/inversify/es/annotation/decorator_utils.js\");\n\r\n\r\n\r\nfunction named(name) {\r\n    return (0,_decorator_utils__WEBPACK_IMPORTED_MODULE_0__.createTaggedDecorator)(new _planning_metadata__WEBPACK_IMPORTED_MODULE_1__.Metadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_2__.NAMED_TAG, name));\r\n}\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/annotation/named.js?");

/***/ }),

/***/ "./node_modules/inversify/es/annotation/optional.js":
/*!**********************************************************!*\
  !*** ./node_modules/inversify/es/annotation/optional.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   optional: () => (/* binding */ optional)\n/* harmony export */ });\n/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/metadata_keys */ \"./node_modules/inversify/es/constants/metadata_keys.js\");\n/* harmony import */ var _planning_metadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../planning/metadata */ \"./node_modules/inversify/es/planning/metadata.js\");\n/* harmony import */ var _decorator_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decorator_utils */ \"./node_modules/inversify/es/annotation/decorator_utils.js\");\n\r\n\r\n\r\nfunction optional() {\r\n    return (0,_decorator_utils__WEBPACK_IMPORTED_MODULE_0__.createTaggedDecorator)(new _planning_metadata__WEBPACK_IMPORTED_MODULE_1__.Metadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_2__.OPTIONAL_TAG, true));\r\n}\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/annotation/optional.js?");

/***/ }),

/***/ "./node_modules/inversify/es/annotation/post_construct.js":
/*!****************************************************************!*\
  !*** ./node_modules/inversify/es/annotation/post_construct.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   postConstruct: () => (/* binding */ postConstruct)\n/* harmony export */ });\n/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/error_msgs */ \"./node_modules/inversify/es/constants/error_msgs.js\");\n/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/metadata_keys */ \"./node_modules/inversify/es/constants/metadata_keys.js\");\n/* harmony import */ var _property_event_decorator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./property_event_decorator */ \"./node_modules/inversify/es/annotation/property_event_decorator.js\");\n\r\n\r\n\r\nvar postConstruct = (0,_property_event_decorator__WEBPACK_IMPORTED_MODULE_0__.propertyEventDecorator)(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__.POST_CONSTRUCT, _constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__.MULTIPLE_POST_CONSTRUCT_METHODS);\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/annotation/post_construct.js?");

/***/ }),

/***/ "./node_modules/inversify/es/annotation/pre_destroy.js":
/*!*************************************************************!*\
  !*** ./node_modules/inversify/es/annotation/pre_destroy.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   preDestroy: () => (/* binding */ preDestroy)\n/* harmony export */ });\n/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/error_msgs */ \"./node_modules/inversify/es/constants/error_msgs.js\");\n/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/metadata_keys */ \"./node_modules/inversify/es/constants/metadata_keys.js\");\n/* harmony import */ var _property_event_decorator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./property_event_decorator */ \"./node_modules/inversify/es/annotation/property_event_decorator.js\");\n\r\n\r\n\r\nvar preDestroy = (0,_property_event_decorator__WEBPACK_IMPORTED_MODULE_0__.propertyEventDecorator)(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__.PRE_DESTROY, _constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__.MULTIPLE_PRE_DESTROY_METHODS);\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/annotation/pre_destroy.js?");

/***/ }),

/***/ "./node_modules/inversify/es/annotation/property_event_decorator.js":
/*!**************************************************************************!*\
  !*** ./node_modules/inversify/es/annotation/property_event_decorator.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   propertyEventDecorator: () => (/* binding */ propertyEventDecorator)\n/* harmony export */ });\n/* harmony import */ var _planning_metadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../planning/metadata */ \"./node_modules/inversify/es/planning/metadata.js\");\n\r\nfunction propertyEventDecorator(eventKey, errorMessage) {\r\n    return function () {\r\n        return function (target, propertyKey) {\r\n            var metadata = new _planning_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata(eventKey, propertyKey);\r\n            if (Reflect.hasOwnMetadata(eventKey, target.constructor)) {\r\n                throw new Error(errorMessage);\r\n            }\r\n            Reflect.defineMetadata(eventKey, metadata, target.constructor);\r\n        };\r\n    };\r\n}\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/annotation/property_event_decorator.js?");

/***/ }),

/***/ "./node_modules/inversify/es/annotation/tagged.js":
/*!********************************************************!*\
  !*** ./node_modules/inversify/es/annotation/tagged.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   tagged: () => (/* binding */ tagged)\n/* harmony export */ });\n/* harmony import */ var _planning_metadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../planning/metadata */ \"./node_modules/inversify/es/planning/metadata.js\");\n/* harmony import */ var _decorator_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decorator_utils */ \"./node_modules/inversify/es/annotation/decorator_utils.js\");\n\r\n\r\nfunction tagged(metadataKey, metadataValue) {\r\n    return (0,_decorator_utils__WEBPACK_IMPORTED_MODULE_0__.createTaggedDecorator)(new _planning_metadata__WEBPACK_IMPORTED_MODULE_1__.Metadata(metadataKey, metadataValue));\r\n}\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/annotation/tagged.js?");

/***/ }),

/***/ "./node_modules/inversify/es/annotation/target_name.js":
/*!*************************************************************!*\
  !*** ./node_modules/inversify/es/annotation/target_name.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   targetName: () => (/* binding */ targetName)\n/* harmony export */ });\n/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/metadata_keys */ \"./node_modules/inversify/es/constants/metadata_keys.js\");\n/* harmony import */ var _planning_metadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../planning/metadata */ \"./node_modules/inversify/es/planning/metadata.js\");\n/* harmony import */ var _decorator_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./decorator_utils */ \"./node_modules/inversify/es/annotation/decorator_utils.js\");\n\r\n\r\n\r\nfunction targetName(name) {\r\n    return function (target, targetKey, index) {\r\n        var metadata = new _planning_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__.NAME_TAG, name);\r\n        (0,_decorator_utils__WEBPACK_IMPORTED_MODULE_2__.tagParameter)(target, targetKey, index, metadata);\r\n    };\r\n}\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/annotation/target_name.js?");

/***/ }),

/***/ "./node_modules/inversify/es/annotation/unmanaged.js":
/*!***********************************************************!*\
  !*** ./node_modules/inversify/es/annotation/unmanaged.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   unmanaged: () => (/* binding */ unmanaged)\n/* harmony export */ });\n/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/metadata_keys */ \"./node_modules/inversify/es/constants/metadata_keys.js\");\n/* harmony import */ var _planning_metadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../planning/metadata */ \"./node_modules/inversify/es/planning/metadata.js\");\n/* harmony import */ var _decorator_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./decorator_utils */ \"./node_modules/inversify/es/annotation/decorator_utils.js\");\n\r\n\r\n\r\nfunction unmanaged() {\r\n    return function (target, targetKey, index) {\r\n        var metadata = new _planning_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__.UNMANAGED_TAG, true);\r\n        (0,_decorator_utils__WEBPACK_IMPORTED_MODULE_2__.tagParameter)(target, targetKey, index, metadata);\r\n    };\r\n}\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/annotation/unmanaged.js?");

/***/ }),

/***/ "./node_modules/inversify/es/bindings/binding.js":
/*!*******************************************************!*\
  !*** ./node_modules/inversify/es/bindings/binding.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Binding: () => (/* binding */ Binding)\n/* harmony export */ });\n/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/literal_types */ \"./node_modules/inversify/es/constants/literal_types.js\");\n/* harmony import */ var _utils_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/id */ \"./node_modules/inversify/es/utils/id.js\");\n\r\n\r\nvar Binding = (function () {\r\n    function Binding(serviceIdentifier, scope) {\r\n        this.id = (0,_utils_id__WEBPACK_IMPORTED_MODULE_0__.id)();\r\n        this.activated = false;\r\n        this.serviceIdentifier = serviceIdentifier;\r\n        this.scope = scope;\r\n        this.type = _constants_literal_types__WEBPACK_IMPORTED_MODULE_1__.BindingTypeEnum.Invalid;\r\n        this.constraint = function (request) { return true; };\r\n        this.implementationType = null;\r\n        this.cache = null;\r\n        this.factory = null;\r\n        this.provider = null;\r\n        this.onActivation = null;\r\n        this.onDeactivation = null;\r\n        this.dynamicValue = null;\r\n    }\r\n    Binding.prototype.clone = function () {\r\n        var clone = new Binding(this.serviceIdentifier, this.scope);\r\n        clone.activated = (clone.scope === _constants_literal_types__WEBPACK_IMPORTED_MODULE_1__.BindingScopeEnum.Singleton) ? this.activated : false;\r\n        clone.implementationType = this.implementationType;\r\n        clone.dynamicValue = this.dynamicValue;\r\n        clone.scope = this.scope;\r\n        clone.type = this.type;\r\n        clone.factory = this.factory;\r\n        clone.provider = this.provider;\r\n        clone.constraint = this.constraint;\r\n        clone.onActivation = this.onActivation;\r\n        clone.onDeactivation = this.onDeactivation;\r\n        clone.cache = this.cache;\r\n        return clone;\r\n    };\r\n    return Binding;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/bindings/binding.js?");

/***/ }),

/***/ "./node_modules/inversify/es/bindings/binding_count.js":
/*!*************************************************************!*\
  !*** ./node_modules/inversify/es/bindings/binding_count.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BindingCount: () => (/* binding */ BindingCount)\n/* harmony export */ });\nvar BindingCount = {\r\n    MultipleBindingsAvailable: 2,\r\n    NoBindingsAvailable: 0,\r\n    OnlyOneBindingAvailable: 1\r\n};\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/bindings/binding_count.js?");

/***/ }),

/***/ "./node_modules/inversify/es/constants/error_msgs.js":
/*!***********************************************************!*\
  !*** ./node_modules/inversify/es/constants/error_msgs.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AMBIGUOUS_MATCH: () => (/* binding */ AMBIGUOUS_MATCH),\n/* harmony export */   ARGUMENTS_LENGTH_MISMATCH: () => (/* binding */ ARGUMENTS_LENGTH_MISMATCH),\n/* harmony export */   ASYNC_UNBIND_REQUIRED: () => (/* binding */ ASYNC_UNBIND_REQUIRED),\n/* harmony export */   CANNOT_UNBIND: () => (/* binding */ CANNOT_UNBIND),\n/* harmony export */   CIRCULAR_DEPENDENCY: () => (/* binding */ CIRCULAR_DEPENDENCY),\n/* harmony export */   CIRCULAR_DEPENDENCY_IN_FACTORY: () => (/* binding */ CIRCULAR_DEPENDENCY_IN_FACTORY),\n/* harmony export */   CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE: () => (/* binding */ CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE),\n/* harmony export */   CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE: () => (/* binding */ CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE),\n/* harmony export */   CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK: () => (/* binding */ CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK),\n/* harmony export */   CONTAINER_OPTIONS_MUST_BE_AN_OBJECT: () => (/* binding */ CONTAINER_OPTIONS_MUST_BE_AN_OBJECT),\n/* harmony export */   DUPLICATED_INJECTABLE_DECORATOR: () => (/* binding */ DUPLICATED_INJECTABLE_DECORATOR),\n/* harmony export */   DUPLICATED_METADATA: () => (/* binding */ DUPLICATED_METADATA),\n/* harmony export */   INVALID_BINDING_TYPE: () => (/* binding */ INVALID_BINDING_TYPE),\n/* harmony export */   INVALID_DECORATOR_OPERATION: () => (/* binding */ INVALID_DECORATOR_OPERATION),\n/* harmony export */   INVALID_FUNCTION_BINDING: () => (/* binding */ INVALID_FUNCTION_BINDING),\n/* harmony export */   INVALID_MIDDLEWARE_RETURN: () => (/* binding */ INVALID_MIDDLEWARE_RETURN),\n/* harmony export */   INVALID_TO_SELF_VALUE: () => (/* binding */ INVALID_TO_SELF_VALUE),\n/* harmony export */   KEY_NOT_FOUND: () => (/* binding */ KEY_NOT_FOUND),\n/* harmony export */   LAZY_IN_SYNC: () => (/* binding */ LAZY_IN_SYNC),\n/* harmony export */   MISSING_INJECTABLE_ANNOTATION: () => (/* binding */ MISSING_INJECTABLE_ANNOTATION),\n/* harmony export */   MISSING_INJECT_ANNOTATION: () => (/* binding */ MISSING_INJECT_ANNOTATION),\n/* harmony export */   MULTIPLE_POST_CONSTRUCT_METHODS: () => (/* binding */ MULTIPLE_POST_CONSTRUCT_METHODS),\n/* harmony export */   MULTIPLE_PRE_DESTROY_METHODS: () => (/* binding */ MULTIPLE_PRE_DESTROY_METHODS),\n/* harmony export */   NOT_IMPLEMENTED: () => (/* binding */ NOT_IMPLEMENTED),\n/* harmony export */   NOT_REGISTERED: () => (/* binding */ NOT_REGISTERED),\n/* harmony export */   NO_MORE_SNAPSHOTS_AVAILABLE: () => (/* binding */ NO_MORE_SNAPSHOTS_AVAILABLE),\n/* harmony export */   NULL_ARGUMENT: () => (/* binding */ NULL_ARGUMENT),\n/* harmony export */   ON_DEACTIVATION_ERROR: () => (/* binding */ ON_DEACTIVATION_ERROR),\n/* harmony export */   POST_CONSTRUCT_ERROR: () => (/* binding */ POST_CONSTRUCT_ERROR),\n/* harmony export */   PRE_DESTROY_ERROR: () => (/* binding */ PRE_DESTROY_ERROR),\n/* harmony export */   STACK_OVERFLOW: () => (/* binding */ STACK_OVERFLOW),\n/* harmony export */   UNDEFINED_INJECT_ANNOTATION: () => (/* binding */ UNDEFINED_INJECT_ANNOTATION)\n/* harmony export */ });\nvar DUPLICATED_INJECTABLE_DECORATOR = 'Cannot apply @injectable decorator multiple times.';\r\nvar DUPLICATED_METADATA = 'Metadata key was used more than once in a parameter:';\r\nvar NULL_ARGUMENT = 'NULL argument';\r\nvar KEY_NOT_FOUND = 'Key Not Found';\r\nvar AMBIGUOUS_MATCH = 'Ambiguous match found for serviceIdentifier:';\r\nvar CANNOT_UNBIND = 'Could not unbind serviceIdentifier:';\r\nvar NOT_REGISTERED = 'No matching bindings found for serviceIdentifier:';\r\nvar MISSING_INJECTABLE_ANNOTATION = 'Missing required @injectable annotation in:';\r\nvar MISSING_INJECT_ANNOTATION = 'Missing required @inject or @multiInject annotation in:';\r\nvar UNDEFINED_INJECT_ANNOTATION = function (name) {\r\n    return \"@inject called with undefined this could mean that the class \" + name + \" has \" +\r\n        'a circular dependency problem. You can use a LazyServiceIdentifier to  ' +\r\n        'overcome this limitation.';\r\n};\r\nvar CIRCULAR_DEPENDENCY = 'Circular dependency found:';\r\nvar NOT_IMPLEMENTED = 'Sorry, this feature is not fully implemented yet.';\r\nvar INVALID_BINDING_TYPE = 'Invalid binding type:';\r\nvar NO_MORE_SNAPSHOTS_AVAILABLE = 'No snapshot available to restore.';\r\nvar INVALID_MIDDLEWARE_RETURN = 'Invalid return type in middleware. Middleware must return!';\r\nvar INVALID_FUNCTION_BINDING = 'Value provided to function binding must be a function!';\r\nvar LAZY_IN_SYNC = function (key) { return \"You are attempting to construct '\" + key + \"' in a synchronous way\\n but it has asynchronous dependencies.\"; };\r\nvar INVALID_TO_SELF_VALUE = 'The toSelf function can only be applied when a constructor is ' +\r\n    'used as service identifier';\r\nvar INVALID_DECORATOR_OPERATION = 'The @inject @multiInject @tagged and @named decorators ' +\r\n    'must be applied to the parameters of a class constructor or a class property.';\r\nvar ARGUMENTS_LENGTH_MISMATCH = function () {\r\n    var values = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        values[_i] = arguments[_i];\r\n    }\r\n    return 'The number of constructor arguments in the derived class ' +\r\n        (values[0] + \" must be >= than the number of constructor arguments of its base class.\");\r\n};\r\nvar CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = 'Invalid Container constructor argument. Container options ' +\r\n    'must be an object.';\r\nvar CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = 'Invalid Container option. Default scope must ' +\r\n    'be a string (\"singleton\" or \"transient\").';\r\nvar CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = 'Invalid Container option. Auto bind injectable must ' +\r\n    'be a boolean';\r\nvar CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = 'Invalid Container option. Skip base check must ' +\r\n    'be a boolean';\r\nvar MULTIPLE_PRE_DESTROY_METHODS = 'Cannot apply @preDestroy decorator multiple times in the same class';\r\nvar MULTIPLE_POST_CONSTRUCT_METHODS = 'Cannot apply @postConstruct decorator multiple times in the same class';\r\nvar ASYNC_UNBIND_REQUIRED = 'Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)';\r\nvar POST_CONSTRUCT_ERROR = function (clazz, errorMessage) { return \"@postConstruct error in class \" + clazz + \": \" + errorMessage; };\r\nvar PRE_DESTROY_ERROR = function (clazz, errorMessage) { return \"@preDestroy error in class \" + clazz + \": \" + errorMessage; };\r\nvar ON_DEACTIVATION_ERROR = function (clazz, errorMessage) { return \"onDeactivation() error in class \" + clazz + \": \" + errorMessage; };\r\nvar CIRCULAR_DEPENDENCY_IN_FACTORY = function (factoryType, serviceIdentifier) {\r\n    return \"It looks like there is a circular dependency in one of the '\" + factoryType + \"' bindings. Please investigate bindings with \" +\r\n        (\"service identifier '\" + serviceIdentifier + \"'.\");\r\n};\r\nvar STACK_OVERFLOW = 'Maximum call stack size exceeded';\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/constants/error_msgs.js?");

/***/ }),

/***/ "./node_modules/inversify/es/constants/literal_types.js":
/*!**************************************************************!*\
  !*** ./node_modules/inversify/es/constants/literal_types.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BindingScopeEnum: () => (/* binding */ BindingScopeEnum),\n/* harmony export */   BindingTypeEnum: () => (/* binding */ BindingTypeEnum),\n/* harmony export */   TargetTypeEnum: () => (/* binding */ TargetTypeEnum)\n/* harmony export */ });\nvar BindingScopeEnum = {\r\n    Request: 'Request',\r\n    Singleton: 'Singleton',\r\n    Transient: 'Transient'\r\n};\r\nvar BindingTypeEnum = {\r\n    ConstantValue: 'ConstantValue',\r\n    Constructor: 'Constructor',\r\n    DynamicValue: 'DynamicValue',\r\n    Factory: 'Factory',\r\n    Function: 'Function',\r\n    Instance: 'Instance',\r\n    Invalid: 'Invalid',\r\n    Provider: 'Provider'\r\n};\r\nvar TargetTypeEnum = {\r\n    ClassProperty: 'ClassProperty',\r\n    ConstructorArgument: 'ConstructorArgument',\r\n    Variable: 'Variable'\r\n};\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/constants/literal_types.js?");

/***/ }),

/***/ "./node_modules/inversify/es/constants/metadata_keys.js":
/*!**************************************************************!*\
  !*** ./node_modules/inversify/es/constants/metadata_keys.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DESIGN_PARAM_TYPES: () => (/* binding */ DESIGN_PARAM_TYPES),\n/* harmony export */   INJECT_TAG: () => (/* binding */ INJECT_TAG),\n/* harmony export */   MULTI_INJECT_TAG: () => (/* binding */ MULTI_INJECT_TAG),\n/* harmony export */   NAMED_TAG: () => (/* binding */ NAMED_TAG),\n/* harmony export */   NAME_TAG: () => (/* binding */ NAME_TAG),\n/* harmony export */   NON_CUSTOM_TAG_KEYS: () => (/* binding */ NON_CUSTOM_TAG_KEYS),\n/* harmony export */   OPTIONAL_TAG: () => (/* binding */ OPTIONAL_TAG),\n/* harmony export */   PARAM_TYPES: () => (/* binding */ PARAM_TYPES),\n/* harmony export */   POST_CONSTRUCT: () => (/* binding */ POST_CONSTRUCT),\n/* harmony export */   PRE_DESTROY: () => (/* binding */ PRE_DESTROY),\n/* harmony export */   TAGGED: () => (/* binding */ TAGGED),\n/* harmony export */   TAGGED_PROP: () => (/* binding */ TAGGED_PROP),\n/* harmony export */   UNMANAGED_TAG: () => (/* binding */ UNMANAGED_TAG)\n/* harmony export */ });\nvar NAMED_TAG = 'named';\r\nvar NAME_TAG = 'name';\r\nvar UNMANAGED_TAG = 'unmanaged';\r\nvar OPTIONAL_TAG = 'optional';\r\nvar INJECT_TAG = 'inject';\r\nvar MULTI_INJECT_TAG = 'multi_inject';\r\nvar TAGGED = 'inversify:tagged';\r\nvar TAGGED_PROP = 'inversify:tagged_props';\r\nvar PARAM_TYPES = 'inversify:paramtypes';\r\nvar DESIGN_PARAM_TYPES = 'design:paramtypes';\r\nvar POST_CONSTRUCT = 'post_construct';\r\nvar PRE_DESTROY = 'pre_destroy';\r\nfunction getNonCustomTagKeys() {\r\n    return [\r\n        INJECT_TAG,\r\n        MULTI_INJECT_TAG,\r\n        NAME_TAG,\r\n        UNMANAGED_TAG,\r\n        NAMED_TAG,\r\n        OPTIONAL_TAG,\r\n    ];\r\n}\r\nvar NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/constants/metadata_keys.js?");

/***/ }),

/***/ "./node_modules/inversify/es/container/container.js":
/*!**********************************************************!*\
  !*** ./node_modules/inversify/es/container/container.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Container: () => (/* binding */ Container)\n/* harmony export */ });\n/* harmony import */ var _bindings_binding__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../bindings/binding */ \"./node_modules/inversify/es/bindings/binding.js\");\n/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/error_msgs */ \"./node_modules/inversify/es/constants/error_msgs.js\");\n/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/literal_types */ \"./node_modules/inversify/es/constants/literal_types.js\");\n/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constants/metadata_keys */ \"./node_modules/inversify/es/constants/metadata_keys.js\");\n/* harmony import */ var _planning_metadata_reader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../planning/metadata_reader */ \"./node_modules/inversify/es/planning/metadata_reader.js\");\n/* harmony import */ var _planning_planner__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../planning/planner */ \"./node_modules/inversify/es/planning/planner.js\");\n/* harmony import */ var _resolution_resolver__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../resolution/resolver */ \"./node_modules/inversify/es/resolution/resolver.js\");\n/* harmony import */ var _syntax_binding_to_syntax__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../syntax/binding_to_syntax */ \"./node_modules/inversify/es/syntax/binding_to_syntax.js\");\n/* harmony import */ var _utils_async__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utils/async */ \"./node_modules/inversify/es/utils/async.js\");\n/* harmony import */ var _utils_id__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/id */ \"./node_modules/inversify/es/utils/id.js\");\n/* harmony import */ var _utils_serialization__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/serialization */ \"./node_modules/inversify/es/utils/serialization.js\");\n/* harmony import */ var _container_snapshot__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./container_snapshot */ \"./node_modules/inversify/es/container/container_snapshot.js\");\n/* harmony import */ var _lookup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lookup */ \"./node_modules/inversify/es/container/lookup.js\");\n/* harmony import */ var _module_activation_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./module_activation_store */ \"./node_modules/inversify/es/container/module_activation_store.js\");\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar Container = (function () {\r\n    function Container(containerOptions) {\r\n        var options = containerOptions || {};\r\n        if (typeof options !== 'object') {\r\n            throw new Error(\"\" + _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT);\r\n        }\r\n        if (options.defaultScope === undefined) {\r\n            options.defaultScope = _constants_literal_types__WEBPACK_IMPORTED_MODULE_1__.BindingScopeEnum.Transient;\r\n        }\r\n        else if (options.defaultScope !== _constants_literal_types__WEBPACK_IMPORTED_MODULE_1__.BindingScopeEnum.Singleton &&\r\n            options.defaultScope !== _constants_literal_types__WEBPACK_IMPORTED_MODULE_1__.BindingScopeEnum.Transient &&\r\n            options.defaultScope !== _constants_literal_types__WEBPACK_IMPORTED_MODULE_1__.BindingScopeEnum.Request) {\r\n            throw new Error(\"\" + _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE);\r\n        }\r\n        if (options.autoBindInjectable === undefined) {\r\n            options.autoBindInjectable = false;\r\n        }\r\n        else if (typeof options.autoBindInjectable !== 'boolean') {\r\n            throw new Error(\"\" + _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE);\r\n        }\r\n        if (options.skipBaseClassChecks === undefined) {\r\n            options.skipBaseClassChecks = false;\r\n        }\r\n        else if (typeof options.skipBaseClassChecks !== 'boolean') {\r\n            throw new Error(\"\" + _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK);\r\n        }\r\n        this.options = {\r\n            autoBindInjectable: options.autoBindInjectable,\r\n            defaultScope: options.defaultScope,\r\n            skipBaseClassChecks: options.skipBaseClassChecks\r\n        };\r\n        this.id = (0,_utils_id__WEBPACK_IMPORTED_MODULE_2__.id)();\r\n        this._bindingDictionary = new _lookup__WEBPACK_IMPORTED_MODULE_3__.Lookup();\r\n        this._snapshots = [];\r\n        this._middleware = null;\r\n        this._activations = new _lookup__WEBPACK_IMPORTED_MODULE_3__.Lookup();\r\n        this._deactivations = new _lookup__WEBPACK_IMPORTED_MODULE_3__.Lookup();\r\n        this.parent = null;\r\n        this._metadataReader = new _planning_metadata_reader__WEBPACK_IMPORTED_MODULE_4__.MetadataReader();\r\n        this._moduleActivationStore = new _module_activation_store__WEBPACK_IMPORTED_MODULE_5__.ModuleActivationStore();\r\n    }\r\n    Container.merge = function (container1, container2) {\r\n        var containers = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n            containers[_i - 2] = arguments[_i];\r\n        }\r\n        var container = new Container();\r\n        var targetContainers = __spreadArray([container1, container2], containers, true).map(function (targetContainer) { return (0,_planning_planner__WEBPACK_IMPORTED_MODULE_6__.getBindingDictionary)(targetContainer); });\r\n        var bindingDictionary = (0,_planning_planner__WEBPACK_IMPORTED_MODULE_6__.getBindingDictionary)(container);\r\n        function copyDictionary(origin, destination) {\r\n            origin.traverse(function (_key, value) {\r\n                value.forEach(function (binding) {\r\n                    destination.add(binding.serviceIdentifier, binding.clone());\r\n                });\r\n            });\r\n        }\r\n        targetContainers.forEach(function (targetBindingDictionary) {\r\n            copyDictionary(targetBindingDictionary, bindingDictionary);\r\n        });\r\n        return container;\r\n    };\r\n    Container.prototype.load = function () {\r\n        var modules = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            modules[_i] = arguments[_i];\r\n        }\r\n        var getHelpers = this._getContainerModuleHelpersFactory();\r\n        for (var _a = 0, modules_1 = modules; _a < modules_1.length; _a++) {\r\n            var currentModule = modules_1[_a];\r\n            var containerModuleHelpers = getHelpers(currentModule.id);\r\n            currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction);\r\n        }\r\n    };\r\n    Container.prototype.loadAsync = function () {\r\n        var modules = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            modules[_i] = arguments[_i];\r\n        }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var getHelpers, _a, modules_2, currentModule, containerModuleHelpers;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        getHelpers = this._getContainerModuleHelpersFactory();\r\n                        _a = 0, modules_2 = modules;\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        if (!(_a < modules_2.length)) return [3, 4];\r\n                        currentModule = modules_2[_a];\r\n                        containerModuleHelpers = getHelpers(currentModule.id);\r\n                        return [4, currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction)];\r\n                    case 2:\r\n                        _b.sent();\r\n                        _b.label = 3;\r\n                    case 3:\r\n                        _a++;\r\n                        return [3, 1];\r\n                    case 4: return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Container.prototype.unload = function () {\r\n        var _this = this;\r\n        var modules = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            modules[_i] = arguments[_i];\r\n        }\r\n        modules.forEach(function (module) {\r\n            var deactivations = _this._removeModuleBindings(module.id);\r\n            _this._deactivateSingletons(deactivations);\r\n            _this._removeModuleHandlers(module.id);\r\n        });\r\n    };\r\n    Container.prototype.unloadAsync = function () {\r\n        var modules = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            modules[_i] = arguments[_i];\r\n        }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _a, modules_3, module_1, deactivations;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        _a = 0, modules_3 = modules;\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        if (!(_a < modules_3.length)) return [3, 4];\r\n                        module_1 = modules_3[_a];\r\n                        deactivations = this._removeModuleBindings(module_1.id);\r\n                        return [4, this._deactivateSingletonsAsync(deactivations)];\r\n                    case 2:\r\n                        _b.sent();\r\n                        this._removeModuleHandlers(module_1.id);\r\n                        _b.label = 3;\r\n                    case 3:\r\n                        _a++;\r\n                        return [3, 1];\r\n                    case 4: return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Container.prototype.bind = function (serviceIdentifier) {\r\n        var scope = this.options.defaultScope || _constants_literal_types__WEBPACK_IMPORTED_MODULE_1__.BindingScopeEnum.Transient;\r\n        var binding = new _bindings_binding__WEBPACK_IMPORTED_MODULE_7__.Binding(serviceIdentifier, scope);\r\n        this._bindingDictionary.add(serviceIdentifier, binding);\r\n        return new _syntax_binding_to_syntax__WEBPACK_IMPORTED_MODULE_8__.BindingToSyntax(binding);\r\n    };\r\n    Container.prototype.rebind = function (serviceIdentifier) {\r\n        this.unbind(serviceIdentifier);\r\n        return this.bind(serviceIdentifier);\r\n    };\r\n    Container.prototype.rebindAsync = function (serviceIdentifier) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4, this.unbindAsync(serviceIdentifier)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2, this.bind(serviceIdentifier)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Container.prototype.unbind = function (serviceIdentifier) {\r\n        if (this._bindingDictionary.hasKey(serviceIdentifier)) {\r\n            var bindings = this._bindingDictionary.get(serviceIdentifier);\r\n            this._deactivateSingletons(bindings);\r\n        }\r\n        this._removeServiceFromDictionary(serviceIdentifier);\r\n    };\r\n    Container.prototype.unbindAsync = function (serviceIdentifier) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var bindings;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (!this._bindingDictionary.hasKey(serviceIdentifier)) return [3, 2];\r\n                        bindings = this._bindingDictionary.get(serviceIdentifier);\r\n                        return [4, this._deactivateSingletonsAsync(bindings)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        _a.label = 2;\r\n                    case 2:\r\n                        this._removeServiceFromDictionary(serviceIdentifier);\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Container.prototype.unbindAll = function () {\r\n        var _this = this;\r\n        this._bindingDictionary.traverse(function (_key, value) {\r\n            _this._deactivateSingletons(value);\r\n        });\r\n        this._bindingDictionary = new _lookup__WEBPACK_IMPORTED_MODULE_3__.Lookup();\r\n    };\r\n    Container.prototype.unbindAllAsync = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var promises;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        promises = [];\r\n                        this._bindingDictionary.traverse(function (_key, value) {\r\n                            promises.push(_this._deactivateSingletonsAsync(value));\r\n                        });\r\n                        return [4, Promise.all(promises)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        this._bindingDictionary = new _lookup__WEBPACK_IMPORTED_MODULE_3__.Lookup();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Container.prototype.onActivation = function (serviceIdentifier, onActivation) {\r\n        this._activations.add(serviceIdentifier, onActivation);\r\n    };\r\n    Container.prototype.onDeactivation = function (serviceIdentifier, onDeactivation) {\r\n        this._deactivations.add(serviceIdentifier, onDeactivation);\r\n    };\r\n    Container.prototype.isBound = function (serviceIdentifier) {\r\n        var bound = this._bindingDictionary.hasKey(serviceIdentifier);\r\n        if (!bound && this.parent) {\r\n            bound = this.parent.isBound(serviceIdentifier);\r\n        }\r\n        return bound;\r\n    };\r\n    Container.prototype.isCurrentBound = function (serviceIdentifier) {\r\n        return this._bindingDictionary.hasKey(serviceIdentifier);\r\n    };\r\n    Container.prototype.isBoundNamed = function (serviceIdentifier, named) {\r\n        return this.isBoundTagged(serviceIdentifier, _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_9__.NAMED_TAG, named);\r\n    };\r\n    Container.prototype.isBoundTagged = function (serviceIdentifier, key, value) {\r\n        var bound = false;\r\n        if (this._bindingDictionary.hasKey(serviceIdentifier)) {\r\n            var bindings = this._bindingDictionary.get(serviceIdentifier);\r\n            var request_1 = (0,_planning_planner__WEBPACK_IMPORTED_MODULE_6__.createMockRequest)(this, serviceIdentifier, key, value);\r\n            bound = bindings.some(function (b) { return b.constraint(request_1); });\r\n        }\r\n        if (!bound && this.parent) {\r\n            bound = this.parent.isBoundTagged(serviceIdentifier, key, value);\r\n        }\r\n        return bound;\r\n    };\r\n    Container.prototype.snapshot = function () {\r\n        this._snapshots.push(_container_snapshot__WEBPACK_IMPORTED_MODULE_10__.ContainerSnapshot.of(this._bindingDictionary.clone(), this._middleware, this._activations.clone(), this._deactivations.clone(), this._moduleActivationStore.clone()));\r\n    };\r\n    Container.prototype.restore = function () {\r\n        var snapshot = this._snapshots.pop();\r\n        if (snapshot === undefined) {\r\n            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.NO_MORE_SNAPSHOTS_AVAILABLE);\r\n        }\r\n        this._bindingDictionary = snapshot.bindings;\r\n        this._activations = snapshot.activations;\r\n        this._deactivations = snapshot.deactivations;\r\n        this._middleware = snapshot.middleware;\r\n        this._moduleActivationStore = snapshot.moduleActivationStore;\r\n    };\r\n    Container.prototype.createChild = function (containerOptions) {\r\n        var child = new Container(containerOptions || this.options);\r\n        child.parent = this;\r\n        return child;\r\n    };\r\n    Container.prototype.applyMiddleware = function () {\r\n        var middlewares = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            middlewares[_i] = arguments[_i];\r\n        }\r\n        var initial = (this._middleware) ? this._middleware : this._planAndResolve();\r\n        this._middleware = middlewares.reduce(function (prev, curr) { return curr(prev); }, initial);\r\n    };\r\n    Container.prototype.applyCustomMetadataReader = function (metadataReader) {\r\n        this._metadataReader = metadataReader;\r\n    };\r\n    Container.prototype.get = function (serviceIdentifier) {\r\n        var getArgs = this._getNotAllArgs(serviceIdentifier, false);\r\n        return this._getButThrowIfAsync(getArgs);\r\n    };\r\n    Container.prototype.getAsync = function (serviceIdentifier) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var getArgs;\r\n            return __generator(this, function (_a) {\r\n                getArgs = this._getNotAllArgs(serviceIdentifier, false);\r\n                return [2, this._get(getArgs)];\r\n            });\r\n        });\r\n    };\r\n    Container.prototype.getTagged = function (serviceIdentifier, key, value) {\r\n        var getArgs = this._getNotAllArgs(serviceIdentifier, false, key, value);\r\n        return this._getButThrowIfAsync(getArgs);\r\n    };\r\n    Container.prototype.getTaggedAsync = function (serviceIdentifier, key, value) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var getArgs;\r\n            return __generator(this, function (_a) {\r\n                getArgs = this._getNotAllArgs(serviceIdentifier, false, key, value);\r\n                return [2, this._get(getArgs)];\r\n            });\r\n        });\r\n    };\r\n    Container.prototype.getNamed = function (serviceIdentifier, named) {\r\n        return this.getTagged(serviceIdentifier, _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_9__.NAMED_TAG, named);\r\n    };\r\n    Container.prototype.getNamedAsync = function (serviceIdentifier, named) {\r\n        return this.getTaggedAsync(serviceIdentifier, _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_9__.NAMED_TAG, named);\r\n    };\r\n    Container.prototype.getAll = function (serviceIdentifier) {\r\n        var getArgs = this._getAllArgs(serviceIdentifier);\r\n        return this._getButThrowIfAsync(getArgs);\r\n    };\r\n    Container.prototype.getAllAsync = function (serviceIdentifier) {\r\n        var getArgs = this._getAllArgs(serviceIdentifier);\r\n        return this._getAll(getArgs);\r\n    };\r\n    Container.prototype.getAllTagged = function (serviceIdentifier, key, value) {\r\n        var getArgs = this._getNotAllArgs(serviceIdentifier, true, key, value);\r\n        return this._getButThrowIfAsync(getArgs);\r\n    };\r\n    Container.prototype.getAllTaggedAsync = function (serviceIdentifier, key, value) {\r\n        var getArgs = this._getNotAllArgs(serviceIdentifier, true, key, value);\r\n        return this._getAll(getArgs);\r\n    };\r\n    Container.prototype.getAllNamed = function (serviceIdentifier, named) {\r\n        return this.getAllTagged(serviceIdentifier, _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_9__.NAMED_TAG, named);\r\n    };\r\n    Container.prototype.getAllNamedAsync = function (serviceIdentifier, named) {\r\n        return this.getAllTaggedAsync(serviceIdentifier, _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_9__.NAMED_TAG, named);\r\n    };\r\n    Container.prototype.resolve = function (constructorFunction) {\r\n        var isBound = this.isBound(constructorFunction);\r\n        if (!isBound) {\r\n            this.bind(constructorFunction).toSelf();\r\n        }\r\n        var resolved = this.get(constructorFunction);\r\n        if (!isBound) {\r\n            this.unbind(constructorFunction);\r\n        }\r\n        return resolved;\r\n    };\r\n    Container.prototype._preDestroy = function (constructor, instance) {\r\n        var _a, _b;\r\n        if (Reflect.hasMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_9__.PRE_DESTROY, constructor)) {\r\n            var data = Reflect.getMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_9__.PRE_DESTROY, constructor);\r\n            return (_b = (_a = instance)[data.value]) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n        }\r\n    };\r\n    Container.prototype._removeModuleHandlers = function (moduleId) {\r\n        var moduleActivationsHandlers = this._moduleActivationStore.remove(moduleId);\r\n        this._activations.removeIntersection(moduleActivationsHandlers.onActivations);\r\n        this._deactivations.removeIntersection(moduleActivationsHandlers.onDeactivations);\r\n    };\r\n    Container.prototype._removeModuleBindings = function (moduleId) {\r\n        return this._bindingDictionary.removeByCondition(function (binding) { return binding.moduleId === moduleId; });\r\n    };\r\n    Container.prototype._deactivate = function (binding, instance) {\r\n        var _this = this;\r\n        var constructor = Object.getPrototypeOf(instance).constructor;\r\n        try {\r\n            if (this._deactivations.hasKey(binding.serviceIdentifier)) {\r\n                var result = this._deactivateContainer(instance, this._deactivations.get(binding.serviceIdentifier).values());\r\n                if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_11__.isPromise)(result)) {\r\n                    return this._handleDeactivationError(result.then(function () { return _this._propagateContainerDeactivationThenBindingAndPreDestroyAsync(binding, instance, constructor); }), constructor);\r\n                }\r\n            }\r\n            var propagateDeactivationResult = this._propagateContainerDeactivationThenBindingAndPreDestroy(binding, instance, constructor);\r\n            if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_11__.isPromise)(propagateDeactivationResult)) {\r\n                return this._handleDeactivationError(propagateDeactivationResult, constructor);\r\n            }\r\n        }\r\n        catch (ex) {\r\n            if (ex instanceof Error) {\r\n                throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.ON_DEACTIVATION_ERROR(constructor.name, ex.message));\r\n            }\r\n        }\r\n    };\r\n    Container.prototype._handleDeactivationError = function (asyncResult, constructor) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var ex_1;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        _a.trys.push([0, 2, , 3]);\r\n                        return [4, asyncResult];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [3, 3];\r\n                    case 2:\r\n                        ex_1 = _a.sent();\r\n                        if (ex_1 instanceof Error) {\r\n                            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.ON_DEACTIVATION_ERROR(constructor.name, ex_1.message));\r\n                        }\r\n                        return [3, 3];\r\n                    case 3: return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Container.prototype._deactivateContainer = function (instance, deactivationsIterator) {\r\n        var _this = this;\r\n        var deactivation = deactivationsIterator.next();\r\n        while (deactivation.value) {\r\n            var result = deactivation.value(instance);\r\n            if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_11__.isPromise)(result)) {\r\n                return result.then(function () {\r\n                    return _this._deactivateContainerAsync(instance, deactivationsIterator);\r\n                });\r\n            }\r\n            deactivation = deactivationsIterator.next();\r\n        }\r\n    };\r\n    Container.prototype._deactivateContainerAsync = function (instance, deactivationsIterator) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var deactivation;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        deactivation = deactivationsIterator.next();\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        if (!deactivation.value) return [3, 3];\r\n                        return [4, deactivation.value(instance)];\r\n                    case 2:\r\n                        _a.sent();\r\n                        deactivation = deactivationsIterator.next();\r\n                        return [3, 1];\r\n                    case 3: return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Container.prototype._getContainerModuleHelpersFactory = function () {\r\n        var _this = this;\r\n        var setModuleId = function (bindingToSyntax, moduleId) {\r\n            bindingToSyntax._binding.moduleId = moduleId;\r\n        };\r\n        var getBindFunction = function (moduleId) {\r\n            return function (serviceIdentifier) {\r\n                var bindingToSyntax = _this.bind(serviceIdentifier);\r\n                setModuleId(bindingToSyntax, moduleId);\r\n                return bindingToSyntax;\r\n            };\r\n        };\r\n        var getUnbindFunction = function () {\r\n            return function (serviceIdentifier) {\r\n                return _this.unbind(serviceIdentifier);\r\n            };\r\n        };\r\n        var getUnbindAsyncFunction = function () {\r\n            return function (serviceIdentifier) {\r\n                return _this.unbindAsync(serviceIdentifier);\r\n            };\r\n        };\r\n        var getIsboundFunction = function () {\r\n            return function (serviceIdentifier) {\r\n                return _this.isBound(serviceIdentifier);\r\n            };\r\n        };\r\n        var getRebindFunction = function (moduleId) {\r\n            return function (serviceIdentifier) {\r\n                var bindingToSyntax = _this.rebind(serviceIdentifier);\r\n                setModuleId(bindingToSyntax, moduleId);\r\n                return bindingToSyntax;\r\n            };\r\n        };\r\n        var getOnActivationFunction = function (moduleId) {\r\n            return function (serviceIdentifier, onActivation) {\r\n                _this._moduleActivationStore.addActivation(moduleId, serviceIdentifier, onActivation);\r\n                _this.onActivation(serviceIdentifier, onActivation);\r\n            };\r\n        };\r\n        var getOnDeactivationFunction = function (moduleId) {\r\n            return function (serviceIdentifier, onDeactivation) {\r\n                _this._moduleActivationStore.addDeactivation(moduleId, serviceIdentifier, onDeactivation);\r\n                _this.onDeactivation(serviceIdentifier, onDeactivation);\r\n            };\r\n        };\r\n        return function (mId) { return ({\r\n            bindFunction: getBindFunction(mId),\r\n            isboundFunction: getIsboundFunction(),\r\n            onActivationFunction: getOnActivationFunction(mId),\r\n            onDeactivationFunction: getOnDeactivationFunction(mId),\r\n            rebindFunction: getRebindFunction(mId),\r\n            unbindFunction: getUnbindFunction(),\r\n            unbindAsyncFunction: getUnbindAsyncFunction()\r\n        }); };\r\n    };\r\n    Container.prototype._getAll = function (getArgs) {\r\n        return Promise.all(this._get(getArgs));\r\n    };\r\n    Container.prototype._get = function (getArgs) {\r\n        var planAndResolveArgs = __assign(__assign({}, getArgs), { contextInterceptor: function (context) { return context; }, targetType: _constants_literal_types__WEBPACK_IMPORTED_MODULE_1__.TargetTypeEnum.Variable });\r\n        if (this._middleware) {\r\n            var middlewareResult = this._middleware(planAndResolveArgs);\r\n            if (middlewareResult === undefined || middlewareResult === null) {\r\n                throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.INVALID_MIDDLEWARE_RETURN);\r\n            }\r\n            return middlewareResult;\r\n        }\r\n        return this._planAndResolve()(planAndResolveArgs);\r\n    };\r\n    Container.prototype._getButThrowIfAsync = function (getArgs) {\r\n        var result = this._get(getArgs);\r\n        if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_11__.isPromiseOrContainsPromise)(result)) {\r\n            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.LAZY_IN_SYNC(getArgs.serviceIdentifier));\r\n        }\r\n        return result;\r\n    };\r\n    Container.prototype._getAllArgs = function (serviceIdentifier) {\r\n        var getAllArgs = {\r\n            avoidConstraints: true,\r\n            isMultiInject: true,\r\n            serviceIdentifier: serviceIdentifier,\r\n        };\r\n        return getAllArgs;\r\n    };\r\n    Container.prototype._getNotAllArgs = function (serviceIdentifier, isMultiInject, key, value) {\r\n        var getNotAllArgs = {\r\n            avoidConstraints: false,\r\n            isMultiInject: isMultiInject,\r\n            serviceIdentifier: serviceIdentifier,\r\n            key: key,\r\n            value: value,\r\n        };\r\n        return getNotAllArgs;\r\n    };\r\n    Container.prototype._planAndResolve = function () {\r\n        var _this = this;\r\n        return function (args) {\r\n            var context = (0,_planning_planner__WEBPACK_IMPORTED_MODULE_6__.plan)(_this._metadataReader, _this, args.isMultiInject, args.targetType, args.serviceIdentifier, args.key, args.value, args.avoidConstraints);\r\n            context = args.contextInterceptor(context);\r\n            var result = (0,_resolution_resolver__WEBPACK_IMPORTED_MODULE_12__.resolve)(context);\r\n            return result;\r\n        };\r\n    };\r\n    Container.prototype._deactivateIfSingleton = function (binding) {\r\n        var _this = this;\r\n        if (!binding.activated) {\r\n            return;\r\n        }\r\n        if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_11__.isPromise)(binding.cache)) {\r\n            return binding.cache.then(function (resolved) { return _this._deactivate(binding, resolved); });\r\n        }\r\n        return this._deactivate(binding, binding.cache);\r\n    };\r\n    Container.prototype._deactivateSingletons = function (bindings) {\r\n        for (var _i = 0, bindings_1 = bindings; _i < bindings_1.length; _i++) {\r\n            var binding = bindings_1[_i];\r\n            var result = this._deactivateIfSingleton(binding);\r\n            if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_11__.isPromise)(result)) {\r\n                throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.ASYNC_UNBIND_REQUIRED);\r\n            }\r\n        }\r\n    };\r\n    Container.prototype._deactivateSingletonsAsync = function (bindings) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4, Promise.all(bindings.map(function (b) { return _this._deactivateIfSingleton(b); }))];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Container.prototype._propagateContainerDeactivationThenBindingAndPreDestroy = function (binding, instance, constructor) {\r\n        if (this.parent) {\r\n            return this._deactivate.bind(this.parent)(binding, instance);\r\n        }\r\n        else {\r\n            return this._bindingDeactivationAndPreDestroy(binding, instance, constructor);\r\n        }\r\n    };\r\n    Container.prototype._propagateContainerDeactivationThenBindingAndPreDestroyAsync = function (binding, instance, constructor) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (!this.parent) return [3, 2];\r\n                        return [4, this._deactivate.bind(this.parent)(binding, instance)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [3, 4];\r\n                    case 2: return [4, this._bindingDeactivationAndPreDestroyAsync(binding, instance, constructor)];\r\n                    case 3:\r\n                        _a.sent();\r\n                        _a.label = 4;\r\n                    case 4: return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Container.prototype._removeServiceFromDictionary = function (serviceIdentifier) {\r\n        try {\r\n            this._bindingDictionary.remove(serviceIdentifier);\r\n        }\r\n        catch (e) {\r\n            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.CANNOT_UNBIND + \" \" + (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_13__.getServiceIdentifierAsString)(serviceIdentifier));\r\n        }\r\n    };\r\n    Container.prototype._bindingDeactivationAndPreDestroy = function (binding, instance, constructor) {\r\n        var _this = this;\r\n        if (typeof binding.onDeactivation === 'function') {\r\n            var result = binding.onDeactivation(instance);\r\n            if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_11__.isPromise)(result)) {\r\n                return result.then(function () { return _this._preDestroy(constructor, instance); });\r\n            }\r\n        }\r\n        return this._preDestroy(constructor, instance);\r\n    };\r\n    Container.prototype._bindingDeactivationAndPreDestroyAsync = function (binding, instance, constructor) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (!(typeof binding.onDeactivation === 'function')) return [3, 2];\r\n                        return [4, binding.onDeactivation(instance)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        _a.label = 2;\r\n                    case 2: return [4, this._preDestroy(constructor, instance)];\r\n                    case 3:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return Container;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/container/container.js?");

/***/ }),

/***/ "./node_modules/inversify/es/container/container_module.js":
/*!*****************************************************************!*\
  !*** ./node_modules/inversify/es/container/container_module.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncContainerModule: () => (/* binding */ AsyncContainerModule),\n/* harmony export */   ContainerModule: () => (/* binding */ ContainerModule)\n/* harmony export */ });\n/* harmony import */ var _utils_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/id */ \"./node_modules/inversify/es/utils/id.js\");\n\r\nvar ContainerModule = (function () {\r\n    function ContainerModule(registry) {\r\n        this.id = (0,_utils_id__WEBPACK_IMPORTED_MODULE_0__.id)();\r\n        this.registry = registry;\r\n    }\r\n    return ContainerModule;\r\n}());\r\n\r\nvar AsyncContainerModule = (function () {\r\n    function AsyncContainerModule(registry) {\r\n        this.id = (0,_utils_id__WEBPACK_IMPORTED_MODULE_0__.id)();\r\n        this.registry = registry;\r\n    }\r\n    return AsyncContainerModule;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/container/container_module.js?");

/***/ }),

/***/ "./node_modules/inversify/es/container/container_snapshot.js":
/*!*******************************************************************!*\
  !*** ./node_modules/inversify/es/container/container_snapshot.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContainerSnapshot: () => (/* binding */ ContainerSnapshot)\n/* harmony export */ });\nvar ContainerSnapshot = (function () {\r\n    function ContainerSnapshot() {\r\n    }\r\n    ContainerSnapshot.of = function (bindings, middleware, activations, deactivations, moduleActivationStore) {\r\n        var snapshot = new ContainerSnapshot();\r\n        snapshot.bindings = bindings;\r\n        snapshot.middleware = middleware;\r\n        snapshot.deactivations = deactivations;\r\n        snapshot.activations = activations;\r\n        snapshot.moduleActivationStore = moduleActivationStore;\r\n        return snapshot;\r\n    };\r\n    return ContainerSnapshot;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/container/container_snapshot.js?");

/***/ }),

/***/ "./node_modules/inversify/es/container/lookup.js":
/*!*******************************************************!*\
  !*** ./node_modules/inversify/es/container/lookup.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Lookup: () => (/* binding */ Lookup)\n/* harmony export */ });\n/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/error_msgs */ \"./node_modules/inversify/es/constants/error_msgs.js\");\n/* harmony import */ var _utils_clonable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/clonable */ \"./node_modules/inversify/es/utils/clonable.js\");\n\r\n\r\nvar Lookup = (function () {\r\n    function Lookup() {\r\n        this._map = new Map();\r\n    }\r\n    Lookup.prototype.getMap = function () {\r\n        return this._map;\r\n    };\r\n    Lookup.prototype.add = function (serviceIdentifier, value) {\r\n        if (serviceIdentifier === null || serviceIdentifier === undefined) {\r\n            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.NULL_ARGUMENT);\r\n        }\r\n        if (value === null || value === undefined) {\r\n            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.NULL_ARGUMENT);\r\n        }\r\n        var entry = this._map.get(serviceIdentifier);\r\n        if (entry !== undefined) {\r\n            entry.push(value);\r\n        }\r\n        else {\r\n            this._map.set(serviceIdentifier, [value]);\r\n        }\r\n    };\r\n    Lookup.prototype.get = function (serviceIdentifier) {\r\n        if (serviceIdentifier === null || serviceIdentifier === undefined) {\r\n            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.NULL_ARGUMENT);\r\n        }\r\n        var entry = this._map.get(serviceIdentifier);\r\n        if (entry !== undefined) {\r\n            return entry;\r\n        }\r\n        else {\r\n            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.KEY_NOT_FOUND);\r\n        }\r\n    };\r\n    Lookup.prototype.remove = function (serviceIdentifier) {\r\n        if (serviceIdentifier === null || serviceIdentifier === undefined) {\r\n            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.NULL_ARGUMENT);\r\n        }\r\n        if (!this._map.delete(serviceIdentifier)) {\r\n            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.KEY_NOT_FOUND);\r\n        }\r\n    };\r\n    Lookup.prototype.removeIntersection = function (lookup) {\r\n        var _this = this;\r\n        this.traverse(function (serviceIdentifier, value) {\r\n            var lookupActivations = lookup.hasKey(serviceIdentifier) ? lookup.get(serviceIdentifier) : undefined;\r\n            if (lookupActivations !== undefined) {\r\n                var filteredValues = value.filter(function (lookupValue) {\r\n                    return !lookupActivations.some(function (moduleActivation) { return lookupValue === moduleActivation; });\r\n                });\r\n                _this._setValue(serviceIdentifier, filteredValues);\r\n            }\r\n        });\r\n    };\r\n    Lookup.prototype.removeByCondition = function (condition) {\r\n        var _this = this;\r\n        var removals = [];\r\n        this._map.forEach(function (entries, key) {\r\n            var updatedEntries = [];\r\n            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\r\n                var entry = entries_1[_i];\r\n                var remove = condition(entry);\r\n                if (remove) {\r\n                    removals.push(entry);\r\n                }\r\n                else {\r\n                    updatedEntries.push(entry);\r\n                }\r\n            }\r\n            _this._setValue(key, updatedEntries);\r\n        });\r\n        return removals;\r\n    };\r\n    Lookup.prototype.hasKey = function (serviceIdentifier) {\r\n        if (serviceIdentifier === null || serviceIdentifier === undefined) {\r\n            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.NULL_ARGUMENT);\r\n        }\r\n        return this._map.has(serviceIdentifier);\r\n    };\r\n    Lookup.prototype.clone = function () {\r\n        var copy = new Lookup();\r\n        this._map.forEach(function (value, key) {\r\n            value.forEach(function (b) { return copy.add(key, (0,_utils_clonable__WEBPACK_IMPORTED_MODULE_1__.isClonable)(b) ? b.clone() : b); });\r\n        });\r\n        return copy;\r\n    };\r\n    Lookup.prototype.traverse = function (func) {\r\n        this._map.forEach(function (value, key) {\r\n            func(key, value);\r\n        });\r\n    };\r\n    Lookup.prototype._setValue = function (serviceIdentifier, value) {\r\n        if (value.length > 0) {\r\n            this._map.set(serviceIdentifier, value);\r\n        }\r\n        else {\r\n            this._map.delete(serviceIdentifier);\r\n        }\r\n    };\r\n    return Lookup;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/container/lookup.js?");

/***/ }),

/***/ "./node_modules/inversify/es/container/module_activation_store.js":
/*!************************************************************************!*\
  !*** ./node_modules/inversify/es/container/module_activation_store.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ModuleActivationStore: () => (/* binding */ ModuleActivationStore)\n/* harmony export */ });\n/* harmony import */ var _lookup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lookup */ \"./node_modules/inversify/es/container/lookup.js\");\n\r\nvar ModuleActivationStore = (function () {\r\n    function ModuleActivationStore() {\r\n        this._map = new Map();\r\n    }\r\n    ModuleActivationStore.prototype.remove = function (moduleId) {\r\n        if (this._map.has(moduleId)) {\r\n            var handlers = this._map.get(moduleId);\r\n            this._map.delete(moduleId);\r\n            return handlers;\r\n        }\r\n        return this._getEmptyHandlersStore();\r\n    };\r\n    ModuleActivationStore.prototype.addDeactivation = function (moduleId, serviceIdentifier, onDeactivation) {\r\n        this._getModuleActivationHandlers(moduleId)\r\n            .onDeactivations.add(serviceIdentifier, onDeactivation);\r\n    };\r\n    ModuleActivationStore.prototype.addActivation = function (moduleId, serviceIdentifier, onActivation) {\r\n        this._getModuleActivationHandlers(moduleId)\r\n            .onActivations.add(serviceIdentifier, onActivation);\r\n    };\r\n    ModuleActivationStore.prototype.clone = function () {\r\n        var clone = new ModuleActivationStore();\r\n        this._map.forEach(function (handlersStore, moduleId) {\r\n            clone._map.set(moduleId, {\r\n                onActivations: handlersStore.onActivations.clone(),\r\n                onDeactivations: handlersStore.onDeactivations.clone(),\r\n            });\r\n        });\r\n        return clone;\r\n    };\r\n    ModuleActivationStore.prototype._getModuleActivationHandlers = function (moduleId) {\r\n        var moduleActivationHandlers = this._map.get(moduleId);\r\n        if (moduleActivationHandlers === undefined) {\r\n            moduleActivationHandlers = this._getEmptyHandlersStore();\r\n            this._map.set(moduleId, moduleActivationHandlers);\r\n        }\r\n        return moduleActivationHandlers;\r\n    };\r\n    ModuleActivationStore.prototype._getEmptyHandlersStore = function () {\r\n        var handlersStore = {\r\n            onActivations: new _lookup__WEBPACK_IMPORTED_MODULE_0__.Lookup(),\r\n            onDeactivations: new _lookup__WEBPACK_IMPORTED_MODULE_0__.Lookup()\r\n        };\r\n        return handlersStore;\r\n    };\r\n    return ModuleActivationStore;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/container/module_activation_store.js?");

/***/ }),

/***/ "./node_modules/inversify/es/interfaces/interfaces.js":
/*!************************************************************!*\
  !*** ./node_modules/inversify/es/interfaces/interfaces.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   interfaces: () => (/* binding */ interfaces)\n/* harmony export */ });\nvar interfaces;\r\n(function (interfaces) {\r\n    ;\r\n})(interfaces || (interfaces = {}));\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/interfaces/interfaces.js?");

/***/ }),

/***/ "./node_modules/inversify/es/inversify.js":
/*!************************************************!*\
  !*** ./node_modules/inversify/es/inversify.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncContainerModule: () => (/* reexport safe */ _container_container_module__WEBPACK_IMPORTED_MODULE_3__.AsyncContainerModule),\n/* harmony export */   BindingScopeEnum: () => (/* reexport safe */ _constants_literal_types__WEBPACK_IMPORTED_MODULE_2__.BindingScopeEnum),\n/* harmony export */   BindingTypeEnum: () => (/* reexport safe */ _constants_literal_types__WEBPACK_IMPORTED_MODULE_2__.BindingTypeEnum),\n/* harmony export */   Container: () => (/* reexport safe */ _container_container__WEBPACK_IMPORTED_MODULE_1__.Container),\n/* harmony export */   ContainerModule: () => (/* reexport safe */ _container_container_module__WEBPACK_IMPORTED_MODULE_3__.ContainerModule),\n/* harmony export */   LazyServiceIdentifer: () => (/* reexport safe */ _annotation_lazy_service_identifier__WEBPACK_IMPORTED_MODULE_9__.LazyServiceIdentifier),\n/* harmony export */   LazyServiceIdentifier: () => (/* reexport safe */ _annotation_lazy_service_identifier__WEBPACK_IMPORTED_MODULE_9__.LazyServiceIdentifier),\n/* harmony export */   METADATA_KEY: () => (/* binding */ METADATA_KEY),\n/* harmony export */   MetadataReader: () => (/* reexport safe */ _planning_metadata_reader__WEBPACK_IMPORTED_MODULE_16__.MetadataReader),\n/* harmony export */   TargetTypeEnum: () => (/* reexport safe */ _constants_literal_types__WEBPACK_IMPORTED_MODULE_2__.TargetTypeEnum),\n/* harmony export */   createTaggedDecorator: () => (/* reexport safe */ _annotation_decorator_utils__WEBPACK_IMPORTED_MODULE_4__.createTaggedDecorator),\n/* harmony export */   decorate: () => (/* reexport safe */ _annotation_decorator_utils__WEBPACK_IMPORTED_MODULE_4__.decorate),\n/* harmony export */   getServiceIdentifierAsString: () => (/* reexport safe */ _utils_serialization__WEBPACK_IMPORTED_MODULE_20__.getServiceIdentifierAsString),\n/* harmony export */   id: () => (/* reexport safe */ _utils_id__WEBPACK_IMPORTED_MODULE_17__.id),\n/* harmony export */   inject: () => (/* reexport safe */ _annotation_inject__WEBPACK_IMPORTED_MODULE_8__.inject),\n/* harmony export */   injectable: () => (/* reexport safe */ _annotation_injectable__WEBPACK_IMPORTED_MODULE_5__.injectable),\n/* harmony export */   interfaces: () => (/* reexport safe */ _interfaces_interfaces__WEBPACK_IMPORTED_MODULE_18__.interfaces),\n/* harmony export */   multiBindToService: () => (/* reexport safe */ _utils_binding_utils__WEBPACK_IMPORTED_MODULE_21__.multiBindToService),\n/* harmony export */   multiInject: () => (/* reexport safe */ _annotation_multi_inject__WEBPACK_IMPORTED_MODULE_12__.multiInject),\n/* harmony export */   named: () => (/* reexport safe */ _annotation_named__WEBPACK_IMPORTED_MODULE_7__.named),\n/* harmony export */   namedConstraint: () => (/* reexport safe */ _syntax_constraint_helpers__WEBPACK_IMPORTED_MODULE_19__.namedConstraint),\n/* harmony export */   optional: () => (/* reexport safe */ _annotation_optional__WEBPACK_IMPORTED_MODULE_10__.optional),\n/* harmony export */   postConstruct: () => (/* reexport safe */ _annotation_post_construct__WEBPACK_IMPORTED_MODULE_14__.postConstruct),\n/* harmony export */   preDestroy: () => (/* reexport safe */ _annotation_pre_destroy__WEBPACK_IMPORTED_MODULE_15__.preDestroy),\n/* harmony export */   tagged: () => (/* reexport safe */ _annotation_tagged__WEBPACK_IMPORTED_MODULE_6__.tagged),\n/* harmony export */   taggedConstraint: () => (/* reexport safe */ _syntax_constraint_helpers__WEBPACK_IMPORTED_MODULE_19__.taggedConstraint),\n/* harmony export */   targetName: () => (/* reexport safe */ _annotation_target_name__WEBPACK_IMPORTED_MODULE_13__.targetName),\n/* harmony export */   traverseAncerstors: () => (/* reexport safe */ _syntax_constraint_helpers__WEBPACK_IMPORTED_MODULE_19__.traverseAncerstors),\n/* harmony export */   typeConstraint: () => (/* reexport safe */ _syntax_constraint_helpers__WEBPACK_IMPORTED_MODULE_19__.typeConstraint),\n/* harmony export */   unmanaged: () => (/* reexport safe */ _annotation_unmanaged__WEBPACK_IMPORTED_MODULE_11__.unmanaged)\n/* harmony export */ });\n/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/metadata_keys */ \"./node_modules/inversify/es/constants/metadata_keys.js\");\n/* harmony import */ var _container_container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./container/container */ \"./node_modules/inversify/es/container/container.js\");\n/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants/literal_types */ \"./node_modules/inversify/es/constants/literal_types.js\");\n/* harmony import */ var _container_container_module__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./container/container_module */ \"./node_modules/inversify/es/container/container_module.js\");\n/* harmony import */ var _annotation_decorator_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./annotation/decorator_utils */ \"./node_modules/inversify/es/annotation/decorator_utils.js\");\n/* harmony import */ var _annotation_injectable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./annotation/injectable */ \"./node_modules/inversify/es/annotation/injectable.js\");\n/* harmony import */ var _annotation_tagged__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./annotation/tagged */ \"./node_modules/inversify/es/annotation/tagged.js\");\n/* harmony import */ var _annotation_named__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./annotation/named */ \"./node_modules/inversify/es/annotation/named.js\");\n/* harmony import */ var _annotation_inject__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./annotation/inject */ \"./node_modules/inversify/es/annotation/inject.js\");\n/* harmony import */ var _annotation_lazy_service_identifier__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./annotation/lazy_service_identifier */ \"./node_modules/inversify/es/annotation/lazy_service_identifier.js\");\n/* harmony import */ var _annotation_optional__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./annotation/optional */ \"./node_modules/inversify/es/annotation/optional.js\");\n/* harmony import */ var _annotation_unmanaged__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./annotation/unmanaged */ \"./node_modules/inversify/es/annotation/unmanaged.js\");\n/* harmony import */ var _annotation_multi_inject__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./annotation/multi_inject */ \"./node_modules/inversify/es/annotation/multi_inject.js\");\n/* harmony import */ var _annotation_target_name__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./annotation/target_name */ \"./node_modules/inversify/es/annotation/target_name.js\");\n/* harmony import */ var _annotation_post_construct__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./annotation/post_construct */ \"./node_modules/inversify/es/annotation/post_construct.js\");\n/* harmony import */ var _annotation_pre_destroy__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./annotation/pre_destroy */ \"./node_modules/inversify/es/annotation/pre_destroy.js\");\n/* harmony import */ var _planning_metadata_reader__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./planning/metadata_reader */ \"./node_modules/inversify/es/planning/metadata_reader.js\");\n/* harmony import */ var _utils_id__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./utils/id */ \"./node_modules/inversify/es/utils/id.js\");\n/* harmony import */ var _interfaces_interfaces__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./interfaces/interfaces */ \"./node_modules/inversify/es/interfaces/interfaces.js\");\n/* harmony import */ var _syntax_constraint_helpers__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./syntax/constraint_helpers */ \"./node_modules/inversify/es/syntax/constraint_helpers.js\");\n/* harmony import */ var _utils_serialization__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./utils/serialization */ \"./node_modules/inversify/es/utils/serialization.js\");\n/* harmony import */ var _utils_binding_utils__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./utils/binding_utils */ \"./node_modules/inversify/es/utils/binding_utils.js\");\n\r\nvar METADATA_KEY = _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/inversify.js?");

/***/ }),

/***/ "./node_modules/inversify/es/planning/context.js":
/*!*******************************************************!*\
  !*** ./node_modules/inversify/es/planning/context.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Context: () => (/* binding */ Context)\n/* harmony export */ });\n/* harmony import */ var _utils_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/id */ \"./node_modules/inversify/es/utils/id.js\");\n\r\nvar Context = (function () {\r\n    function Context(container) {\r\n        this.id = (0,_utils_id__WEBPACK_IMPORTED_MODULE_0__.id)();\r\n        this.container = container;\r\n    }\r\n    Context.prototype.addPlan = function (plan) {\r\n        this.plan = plan;\r\n    };\r\n    Context.prototype.setCurrentRequest = function (currentRequest) {\r\n        this.currentRequest = currentRequest;\r\n    };\r\n    return Context;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/planning/context.js?");

/***/ }),

/***/ "./node_modules/inversify/es/planning/metadata.js":
/*!********************************************************!*\
  !*** ./node_modules/inversify/es/planning/metadata.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Metadata: () => (/* binding */ Metadata)\n/* harmony export */ });\n/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/metadata_keys */ \"./node_modules/inversify/es/constants/metadata_keys.js\");\n\r\nvar Metadata = (function () {\r\n    function Metadata(key, value) {\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n    Metadata.prototype.toString = function () {\r\n        if (this.key === _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__.NAMED_TAG) {\r\n            return \"named: \" + String(this.value).toString() + \" \";\r\n        }\r\n        else {\r\n            return \"tagged: { key:\" + this.key.toString() + \", value: \" + String(this.value) + \" }\";\r\n        }\r\n    };\r\n    return Metadata;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/planning/metadata.js?");

/***/ }),

/***/ "./node_modules/inversify/es/planning/metadata_reader.js":
/*!***************************************************************!*\
  !*** ./node_modules/inversify/es/planning/metadata_reader.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MetadataReader: () => (/* binding */ MetadataReader)\n/* harmony export */ });\n/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/metadata_keys */ \"./node_modules/inversify/es/constants/metadata_keys.js\");\n\r\nvar MetadataReader = (function () {\r\n    function MetadataReader() {\r\n    }\r\n    MetadataReader.prototype.getConstructorMetadata = function (constructorFunc) {\r\n        var compilerGeneratedMetadata = Reflect.getMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__.PARAM_TYPES, constructorFunc);\r\n        var userGeneratedMetadata = Reflect.getMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__.TAGGED, constructorFunc);\r\n        return {\r\n            compilerGeneratedMetadata: compilerGeneratedMetadata,\r\n            userGeneratedMetadata: userGeneratedMetadata || {}\r\n        };\r\n    };\r\n    MetadataReader.prototype.getPropertiesMetadata = function (constructorFunc) {\r\n        var userGeneratedMetadata = Reflect.getMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__.TAGGED_PROP, constructorFunc) || [];\r\n        return userGeneratedMetadata;\r\n    };\r\n    return MetadataReader;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/planning/metadata_reader.js?");

/***/ }),

/***/ "./node_modules/inversify/es/planning/plan.js":
/*!****************************************************!*\
  !*** ./node_modules/inversify/es/planning/plan.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Plan: () => (/* binding */ Plan)\n/* harmony export */ });\nvar Plan = (function () {\r\n    function Plan(parentContext, rootRequest) {\r\n        this.parentContext = parentContext;\r\n        this.rootRequest = rootRequest;\r\n    }\r\n    return Plan;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/planning/plan.js?");

/***/ }),

/***/ "./node_modules/inversify/es/planning/planner.js":
/*!*******************************************************!*\
  !*** ./node_modules/inversify/es/planning/planner.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createMockRequest: () => (/* binding */ createMockRequest),\n/* harmony export */   getBindingDictionary: () => (/* binding */ getBindingDictionary),\n/* harmony export */   plan: () => (/* binding */ plan)\n/* harmony export */ });\n/* harmony import */ var _bindings_binding_count__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../bindings/binding_count */ \"./node_modules/inversify/es/bindings/binding_count.js\");\n/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constants/error_msgs */ \"./node_modules/inversify/es/constants/error_msgs.js\");\n/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../constants/literal_types */ \"./node_modules/inversify/es/constants/literal_types.js\");\n/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/metadata_keys */ \"./node_modules/inversify/es/constants/metadata_keys.js\");\n/* harmony import */ var _utils_exceptions__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utils/exceptions */ \"./node_modules/inversify/es/utils/exceptions.js\");\n/* harmony import */ var _utils_serialization__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./reflection_utils */ \"./node_modules/inversify/es/utils/serialization.js\");\n/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./context */ \"./node_modules/inversify/es/planning/context.js\");\n/* harmony import */ var _metadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./metadata */ \"./node_modules/inversify/es/planning/metadata.js\");\n/* harmony import */ var _plan__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./plan */ \"./node_modules/inversify/es/planning/plan.js\");\n/* harmony import */ var _reflection_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./reflection_utils */ \"./node_modules/inversify/es/planning/reflection_utils.js\");\n/* harmony import */ var _request__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./request */ \"./node_modules/inversify/es/planning/request.js\");\n/* harmony import */ var _target__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./target */ \"./node_modules/inversify/es/planning/target.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction getBindingDictionary(cntnr) {\r\n    return cntnr._bindingDictionary;\r\n}\r\nfunction _createTarget(isMultiInject, targetType, serviceIdentifier, name, key, value) {\r\n    var metadataKey = isMultiInject ? _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__.MULTI_INJECT_TAG : _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__.INJECT_TAG;\r\n    var injectMetadata = new _metadata__WEBPACK_IMPORTED_MODULE_1__.Metadata(metadataKey, serviceIdentifier);\r\n    var target = new _target__WEBPACK_IMPORTED_MODULE_2__.Target(targetType, name, serviceIdentifier, injectMetadata);\r\n    if (key !== undefined) {\r\n        var tagMetadata = new _metadata__WEBPACK_IMPORTED_MODULE_1__.Metadata(key, value);\r\n        target.metadata.push(tagMetadata);\r\n    }\r\n    return target;\r\n}\r\nfunction _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target) {\r\n    var bindings = getBindings(context.container, target.serviceIdentifier);\r\n    var activeBindings = [];\r\n    if (bindings.length === _bindings_binding_count__WEBPACK_IMPORTED_MODULE_3__.BindingCount.NoBindingsAvailable &&\r\n        context.container.options.autoBindInjectable &&\r\n        typeof target.serviceIdentifier === 'function' &&\r\n        metadataReader.getConstructorMetadata(target.serviceIdentifier).compilerGeneratedMetadata) {\r\n        context.container.bind(target.serviceIdentifier).toSelf();\r\n        bindings = getBindings(context.container, target.serviceIdentifier);\r\n    }\r\n    if (!avoidConstraints) {\r\n        activeBindings = bindings.filter(function (binding) {\r\n            var request = new _request__WEBPACK_IMPORTED_MODULE_4__.Request(binding.serviceIdentifier, context, parentRequest, binding, target);\r\n            return binding.constraint(request);\r\n        });\r\n    }\r\n    else {\r\n        activeBindings = bindings;\r\n    }\r\n    _validateActiveBindingCount(target.serviceIdentifier, activeBindings, target, context.container);\r\n    return activeBindings;\r\n}\r\nfunction _validateActiveBindingCount(serviceIdentifier, bindings, target, container) {\r\n    switch (bindings.length) {\r\n        case _bindings_binding_count__WEBPACK_IMPORTED_MODULE_3__.BindingCount.NoBindingsAvailable:\r\n            if (target.isOptional()) {\r\n                return bindings;\r\n            }\r\n            else {\r\n                var serviceIdentifierString = (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_5__.getServiceIdentifierAsString)(serviceIdentifier);\r\n                var msg = _constants_error_msgs__WEBPACK_IMPORTED_MODULE_6__.NOT_REGISTERED;\r\n                msg += (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_5__.listMetadataForTarget)(serviceIdentifierString, target);\r\n                msg += (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_5__.listRegisteredBindingsForServiceIdentifier)(container, serviceIdentifierString, getBindings);\r\n                throw new Error(msg);\r\n            }\r\n        case _bindings_binding_count__WEBPACK_IMPORTED_MODULE_3__.BindingCount.OnlyOneBindingAvailable:\r\n            return bindings;\r\n        case _bindings_binding_count__WEBPACK_IMPORTED_MODULE_3__.BindingCount.MultipleBindingsAvailable:\r\n        default:\r\n            if (!target.isArray()) {\r\n                var serviceIdentifierString = (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_5__.getServiceIdentifierAsString)(serviceIdentifier);\r\n                var msg = _constants_error_msgs__WEBPACK_IMPORTED_MODULE_6__.AMBIGUOUS_MATCH + \" \" + serviceIdentifierString;\r\n                msg += (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_5__.listRegisteredBindingsForServiceIdentifier)(container, serviceIdentifierString, getBindings);\r\n                throw new Error(msg);\r\n            }\r\n            else {\r\n                return bindings;\r\n            }\r\n    }\r\n}\r\nfunction _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, parentRequest, target) {\r\n    var activeBindings;\r\n    var childRequest;\r\n    if (parentRequest === null) {\r\n        activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, null, target);\r\n        childRequest = new _request__WEBPACK_IMPORTED_MODULE_4__.Request(serviceIdentifier, context, null, activeBindings, target);\r\n        var thePlan = new _plan__WEBPACK_IMPORTED_MODULE_7__.Plan(context, childRequest);\r\n        context.addPlan(thePlan);\r\n    }\r\n    else {\r\n        activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target);\r\n        childRequest = parentRequest.addChildRequest(target.serviceIdentifier, activeBindings, target);\r\n    }\r\n    activeBindings.forEach(function (binding) {\r\n        var subChildRequest = null;\r\n        if (target.isArray()) {\r\n            subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target);\r\n        }\r\n        else {\r\n            if (binding.cache) {\r\n                return;\r\n            }\r\n            subChildRequest = childRequest;\r\n        }\r\n        if (binding.type === _constants_literal_types__WEBPACK_IMPORTED_MODULE_8__.BindingTypeEnum.Instance && binding.implementationType !== null) {\r\n            var dependencies = (0,_reflection_utils__WEBPACK_IMPORTED_MODULE_9__.getDependencies)(metadataReader, binding.implementationType);\r\n            if (!context.container.options.skipBaseClassChecks) {\r\n                var baseClassDependencyCount = (0,_reflection_utils__WEBPACK_IMPORTED_MODULE_9__.getBaseClassDependencyCount)(metadataReader, binding.implementationType);\r\n                if (dependencies.length < baseClassDependencyCount) {\r\n                    var error = _constants_error_msgs__WEBPACK_IMPORTED_MODULE_6__.ARGUMENTS_LENGTH_MISMATCH((0,_utils_serialization__WEBPACK_IMPORTED_MODULE_5__.getFunctionName)(binding.implementationType));\r\n                    throw new Error(error);\r\n                }\r\n            }\r\n            dependencies.forEach(function (dependency) {\r\n                _createSubRequests(metadataReader, false, dependency.serviceIdentifier, context, subChildRequest, dependency);\r\n            });\r\n        }\r\n    });\r\n}\r\nfunction getBindings(container, serviceIdentifier) {\r\n    var bindings = [];\r\n    var bindingDictionary = getBindingDictionary(container);\r\n    if (bindingDictionary.hasKey(serviceIdentifier)) {\r\n        bindings = bindingDictionary.get(serviceIdentifier);\r\n    }\r\n    else if (container.parent !== null) {\r\n        bindings = getBindings(container.parent, serviceIdentifier);\r\n    }\r\n    return bindings;\r\n}\r\nfunction plan(metadataReader, container, isMultiInject, targetType, serviceIdentifier, key, value, avoidConstraints) {\r\n    if (avoidConstraints === void 0) { avoidConstraints = false; }\r\n    var context = new _context__WEBPACK_IMPORTED_MODULE_10__.Context(container);\r\n    var target = _createTarget(isMultiInject, targetType, serviceIdentifier, '', key, value);\r\n    try {\r\n        _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, null, target);\r\n        return context;\r\n    }\r\n    catch (error) {\r\n        if ((0,_utils_exceptions__WEBPACK_IMPORTED_MODULE_11__.isStackOverflowExeption)(error)) {\r\n            (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_5__.circularDependencyToException)(context.plan.rootRequest);\r\n        }\r\n        throw error;\r\n    }\r\n}\r\nfunction createMockRequest(container, serviceIdentifier, key, value) {\r\n    var target = new _target__WEBPACK_IMPORTED_MODULE_2__.Target(_constants_literal_types__WEBPACK_IMPORTED_MODULE_8__.TargetTypeEnum.Variable, '', serviceIdentifier, new _metadata__WEBPACK_IMPORTED_MODULE_1__.Metadata(key, value));\r\n    var context = new _context__WEBPACK_IMPORTED_MODULE_10__.Context(container);\r\n    var request = new _request__WEBPACK_IMPORTED_MODULE_4__.Request(serviceIdentifier, context, null, [], target);\r\n    return request;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/planning/planner.js?");

/***/ }),

/***/ "./node_modules/inversify/es/planning/queryable_string.js":
/*!****************************************************************!*\
  !*** ./node_modules/inversify/es/planning/queryable_string.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryableString: () => (/* binding */ QueryableString)\n/* harmony export */ });\nvar QueryableString = (function () {\r\n    function QueryableString(str) {\r\n        this.str = str;\r\n    }\r\n    QueryableString.prototype.startsWith = function (searchString) {\r\n        return this.str.indexOf(searchString) === 0;\r\n    };\r\n    QueryableString.prototype.endsWith = function (searchString) {\r\n        var reverseString = '';\r\n        var reverseSearchString = searchString.split('').reverse().join('');\r\n        reverseString = this.str.split('').reverse().join('');\r\n        return this.startsWith.call({ str: reverseString }, reverseSearchString);\r\n    };\r\n    QueryableString.prototype.contains = function (searchString) {\r\n        return (this.str.indexOf(searchString) !== -1);\r\n    };\r\n    QueryableString.prototype.equals = function (compareString) {\r\n        return this.str === compareString;\r\n    };\r\n    QueryableString.prototype.value = function () {\r\n        return this.str;\r\n    };\r\n    return QueryableString;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/planning/queryable_string.js?");

/***/ }),

/***/ "./node_modules/inversify/es/planning/reflection_utils.js":
/*!****************************************************************!*\
  !*** ./node_modules/inversify/es/planning/reflection_utils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBaseClassDependencyCount: () => (/* binding */ getBaseClassDependencyCount),\n/* harmony export */   getDependencies: () => (/* binding */ getDependencies),\n/* harmony export */   getFunctionName: () => (/* reexport safe */ _utils_serialization__WEBPACK_IMPORTED_MODULE_0__.getFunctionName)\n/* harmony export */ });\n/* harmony import */ var _annotation_lazy_service_identifier__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../annotation/lazy_service_identifier */ \"./node_modules/inversify/es/annotation/lazy_service_identifier.js\");\n/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/error_msgs */ \"./node_modules/inversify/es/constants/error_msgs.js\");\n/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/literal_types */ \"./node_modules/inversify/es/constants/literal_types.js\");\n/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants/metadata_keys */ \"./node_modules/inversify/es/constants/metadata_keys.js\");\n/* harmony import */ var _utils_serialization__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/serialization */ \"./node_modules/inversify/es/utils/serialization.js\");\n/* harmony import */ var _target__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./target */ \"./node_modules/inversify/es/planning/target.js\");\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction getDependencies(metadataReader, func) {\r\n    var constructorName = (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_0__.getFunctionName)(func);\r\n    return getTargets(metadataReader, constructorName, func, false);\r\n}\r\nfunction getTargets(metadataReader, constructorName, func, isBaseClass) {\r\n    var metadata = metadataReader.getConstructorMetadata(func);\r\n    var serviceIdentifiers = metadata.compilerGeneratedMetadata;\r\n    if (serviceIdentifiers === undefined) {\r\n        var msg = _constants_error_msgs__WEBPACK_IMPORTED_MODULE_1__.MISSING_INJECTABLE_ANNOTATION + \" \" + constructorName + \".\";\r\n        throw new Error(msg);\r\n    }\r\n    var constructorArgsMetadata = metadata.userGeneratedMetadata;\r\n    var keys = Object.keys(constructorArgsMetadata);\r\n    var hasUserDeclaredUnknownInjections = (func.length === 0 && keys.length > 0);\r\n    var hasOptionalParameters = keys.length > func.length;\r\n    var iterations = (hasUserDeclaredUnknownInjections || hasOptionalParameters) ? keys.length : func.length;\r\n    var constructorTargets = getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations);\r\n    var propertyTargets = getClassPropsAsTargets(metadataReader, func, constructorName);\r\n    var targets = __spreadArray(__spreadArray([], constructorTargets, true), propertyTargets, true);\r\n    return targets;\r\n}\r\nfunction getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata) {\r\n    var targetMetadata = constructorArgsMetadata[index.toString()] || [];\r\n    var metadata = formatTargetMetadata(targetMetadata);\r\n    var isManaged = metadata.unmanaged !== true;\r\n    var serviceIdentifier = serviceIdentifiers[index];\r\n    var injectIdentifier = metadata.inject || metadata.multiInject;\r\n    serviceIdentifier = (injectIdentifier ? injectIdentifier : serviceIdentifier);\r\n    if (serviceIdentifier instanceof _annotation_lazy_service_identifier__WEBPACK_IMPORTED_MODULE_2__.LazyServiceIdentifier) {\r\n        serviceIdentifier = serviceIdentifier.unwrap();\r\n    }\r\n    if (isManaged) {\r\n        var isObject = serviceIdentifier === Object;\r\n        var isFunction = serviceIdentifier === Function;\r\n        var isUndefined = serviceIdentifier === undefined;\r\n        var isUnknownType = isObject || isFunction || isUndefined;\r\n        if (!isBaseClass && isUnknownType) {\r\n            var msg = _constants_error_msgs__WEBPACK_IMPORTED_MODULE_1__.MISSING_INJECT_ANNOTATION + \" argument \" + index + \" in class \" + constructorName + \".\";\r\n            throw new Error(msg);\r\n        }\r\n        var target = new _target__WEBPACK_IMPORTED_MODULE_3__.Target(_constants_literal_types__WEBPACK_IMPORTED_MODULE_4__.TargetTypeEnum.ConstructorArgument, metadata.targetName, serviceIdentifier);\r\n        target.metadata = targetMetadata;\r\n        return target;\r\n    }\r\n    return null;\r\n}\r\nfunction getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations) {\r\n    var targets = [];\r\n    for (var i = 0; i < iterations; i++) {\r\n        var index = i;\r\n        var target = getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata);\r\n        if (target !== null) {\r\n            targets.push(target);\r\n        }\r\n    }\r\n    return targets;\r\n}\r\nfunction _getServiceIdentifierForProperty(inject, multiInject, propertyName, className) {\r\n    var serviceIdentifier = (inject || multiInject);\r\n    if (serviceIdentifier === undefined) {\r\n        var msg = _constants_error_msgs__WEBPACK_IMPORTED_MODULE_1__.MISSING_INJECTABLE_ANNOTATION + \" for property \" + String(propertyName) + \" in class \" + className + \".\";\r\n        throw new Error(msg);\r\n    }\r\n    return serviceIdentifier;\r\n}\r\nfunction getClassPropsAsTargets(metadataReader, constructorFunc, constructorName) {\r\n    var classPropsMetadata = metadataReader.getPropertiesMetadata(constructorFunc);\r\n    var targets = [];\r\n    var symbolKeys = Object.getOwnPropertySymbols(classPropsMetadata);\r\n    var stringKeys = Object.keys(classPropsMetadata);\r\n    var keys = stringKeys.concat(symbolKeys);\r\n    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\r\n        var key = keys_1[_i];\r\n        var targetMetadata = classPropsMetadata[key];\r\n        var metadata = formatTargetMetadata(targetMetadata);\r\n        var identifier = metadata.targetName || key;\r\n        var serviceIdentifier = _getServiceIdentifierForProperty(metadata.inject, metadata.multiInject, key, constructorName);\r\n        var target = new _target__WEBPACK_IMPORTED_MODULE_3__.Target(_constants_literal_types__WEBPACK_IMPORTED_MODULE_4__.TargetTypeEnum.ClassProperty, identifier, serviceIdentifier);\r\n        target.metadata = targetMetadata;\r\n        targets.push(target);\r\n    }\r\n    var baseConstructor = Object.getPrototypeOf(constructorFunc.prototype).constructor;\r\n    if (baseConstructor !== Object) {\r\n        var baseTargets = getClassPropsAsTargets(metadataReader, baseConstructor, constructorName);\r\n        targets = __spreadArray(__spreadArray([], targets, true), baseTargets, true);\r\n    }\r\n    return targets;\r\n}\r\nfunction getBaseClassDependencyCount(metadataReader, func) {\r\n    var baseConstructor = Object.getPrototypeOf(func.prototype).constructor;\r\n    if (baseConstructor !== Object) {\r\n        var baseConstructorName = (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_0__.getFunctionName)(baseConstructor);\r\n        var targets = getTargets(metadataReader, baseConstructorName, baseConstructor, true);\r\n        var metadata = targets.map(function (t) { return t.metadata.filter(function (m) { return m.key === _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_5__.UNMANAGED_TAG; }); });\r\n        var unmanagedCount = [].concat.apply([], metadata).length;\r\n        var dependencyCount = targets.length - unmanagedCount;\r\n        if (dependencyCount > 0) {\r\n            return dependencyCount;\r\n        }\r\n        else {\r\n            return getBaseClassDependencyCount(metadataReader, baseConstructor);\r\n        }\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n}\r\nfunction formatTargetMetadata(targetMetadata) {\r\n    var targetMetadataMap = {};\r\n    targetMetadata.forEach(function (m) {\r\n        targetMetadataMap[m.key.toString()] = m.value;\r\n    });\r\n    return {\r\n        inject: targetMetadataMap[_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_5__.INJECT_TAG],\r\n        multiInject: targetMetadataMap[_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_5__.MULTI_INJECT_TAG],\r\n        targetName: targetMetadataMap[_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_5__.NAME_TAG],\r\n        unmanaged: targetMetadataMap[_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_5__.UNMANAGED_TAG]\r\n    };\r\n}\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/planning/reflection_utils.js?");

/***/ }),

/***/ "./node_modules/inversify/es/planning/request.js":
/*!*******************************************************!*\
  !*** ./node_modules/inversify/es/planning/request.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Request: () => (/* binding */ Request)\n/* harmony export */ });\n/* harmony import */ var _utils_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/id */ \"./node_modules/inversify/es/utils/id.js\");\n\r\nvar Request = (function () {\r\n    function Request(serviceIdentifier, parentContext, parentRequest, bindings, target) {\r\n        this.id = (0,_utils_id__WEBPACK_IMPORTED_MODULE_0__.id)();\r\n        this.serviceIdentifier = serviceIdentifier;\r\n        this.parentContext = parentContext;\r\n        this.parentRequest = parentRequest;\r\n        this.target = target;\r\n        this.childRequests = [];\r\n        this.bindings = (Array.isArray(bindings) ? bindings : [bindings]);\r\n        this.requestScope = parentRequest === null\r\n            ? new Map()\r\n            : null;\r\n    }\r\n    Request.prototype.addChildRequest = function (serviceIdentifier, bindings, target) {\r\n        var child = new Request(serviceIdentifier, this.parentContext, this, bindings, target);\r\n        this.childRequests.push(child);\r\n        return child;\r\n    };\r\n    return Request;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/planning/request.js?");

/***/ }),

/***/ "./node_modules/inversify/es/planning/target.js":
/*!******************************************************!*\
  !*** ./node_modules/inversify/es/planning/target.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Target: () => (/* binding */ Target)\n/* harmony export */ });\n/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/metadata_keys */ \"./node_modules/inversify/es/constants/metadata_keys.js\");\n/* harmony import */ var _utils_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/id */ \"./node_modules/inversify/es/utils/id.js\");\n/* harmony import */ var _utils_serialization__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/serialization */ \"./node_modules/inversify/es/utils/serialization.js\");\n/* harmony import */ var _metadata__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./metadata */ \"./node_modules/inversify/es/planning/metadata.js\");\n/* harmony import */ var _queryable_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./queryable_string */ \"./node_modules/inversify/es/planning/queryable_string.js\");\n\r\n\r\n\r\n\r\n\r\nvar Target = (function () {\r\n    function Target(type, identifier, serviceIdentifier, namedOrTagged) {\r\n        this.id = (0,_utils_id__WEBPACK_IMPORTED_MODULE_0__.id)();\r\n        this.type = type;\r\n        this.serviceIdentifier = serviceIdentifier;\r\n        var queryableName = typeof identifier === 'symbol' ? (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_1__.getSymbolDescription)(identifier) : identifier;\r\n        this.name = new _queryable_string__WEBPACK_IMPORTED_MODULE_2__.QueryableString(queryableName || '');\r\n        this.identifier = identifier;\r\n        this.metadata = new Array();\r\n        var metadataItem = null;\r\n        if (typeof namedOrTagged === 'string') {\r\n            metadataItem = new _metadata__WEBPACK_IMPORTED_MODULE_3__.Metadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_4__.NAMED_TAG, namedOrTagged);\r\n        }\r\n        else if (namedOrTagged instanceof _metadata__WEBPACK_IMPORTED_MODULE_3__.Metadata) {\r\n            metadataItem = namedOrTagged;\r\n        }\r\n        if (metadataItem !== null) {\r\n            this.metadata.push(metadataItem);\r\n        }\r\n    }\r\n    Target.prototype.hasTag = function (key) {\r\n        for (var _i = 0, _a = this.metadata; _i < _a.length; _i++) {\r\n            var m = _a[_i];\r\n            if (m.key === key) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    Target.prototype.isArray = function () {\r\n        return this.hasTag(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_4__.MULTI_INJECT_TAG);\r\n    };\r\n    Target.prototype.matchesArray = function (name) {\r\n        return this.matchesTag(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_4__.MULTI_INJECT_TAG)(name);\r\n    };\r\n    Target.prototype.isNamed = function () {\r\n        return this.hasTag(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_4__.NAMED_TAG);\r\n    };\r\n    Target.prototype.isTagged = function () {\r\n        return this.metadata.some(function (metadata) { return _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_4__.NON_CUSTOM_TAG_KEYS.every(function (key) { return metadata.key !== key; }); });\r\n    };\r\n    Target.prototype.isOptional = function () {\r\n        return this.matchesTag(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_4__.OPTIONAL_TAG)(true);\r\n    };\r\n    Target.prototype.getNamedTag = function () {\r\n        if (this.isNamed()) {\r\n            return this.metadata.filter(function (m) { return m.key === _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_4__.NAMED_TAG; })[0];\r\n        }\r\n        return null;\r\n    };\r\n    Target.prototype.getCustomTags = function () {\r\n        if (this.isTagged()) {\r\n            return this.metadata.filter(function (metadata) { return _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_4__.NON_CUSTOM_TAG_KEYS.every(function (key) { return metadata.key !== key; }); });\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    Target.prototype.matchesNamedTag = function (name) {\r\n        return this.matchesTag(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_4__.NAMED_TAG)(name);\r\n    };\r\n    Target.prototype.matchesTag = function (key) {\r\n        var _this = this;\r\n        return function (value) {\r\n            for (var _i = 0, _a = _this.metadata; _i < _a.length; _i++) {\r\n                var m = _a[_i];\r\n                if (m.key === key && m.value === value) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n    };\r\n    return Target;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/planning/target.js?");

/***/ }),

/***/ "./node_modules/inversify/es/resolution/instantiation.js":
/*!***************************************************************!*\
  !*** ./node_modules/inversify/es/resolution/instantiation.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   resolveInstance: () => (/* binding */ resolveInstance)\n/* harmony export */ });\n/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants/error_msgs */ \"./node_modules/inversify/es/constants/error_msgs.js\");\n/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/literal_types */ \"./node_modules/inversify/es/constants/literal_types.js\");\n/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/metadata_keys */ \"./node_modules/inversify/es/constants/metadata_keys.js\");\n/* harmony import */ var _utils_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/async */ \"./node_modules/inversify/es/utils/async.js\");\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\n\r\n\r\n\r\n\r\nfunction _resolveRequests(childRequests, resolveRequest) {\r\n    return childRequests.reduce(function (resolvedRequests, childRequest) {\r\n        var injection = resolveRequest(childRequest);\r\n        var targetType = childRequest.target.type;\r\n        if (targetType === _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.TargetTypeEnum.ConstructorArgument) {\r\n            resolvedRequests.constructorInjections.push(injection);\r\n        }\r\n        else {\r\n            resolvedRequests.propertyRequests.push(childRequest);\r\n            resolvedRequests.propertyInjections.push(injection);\r\n        }\r\n        if (!resolvedRequests.isAsync) {\r\n            resolvedRequests.isAsync = (0,_utils_async__WEBPACK_IMPORTED_MODULE_1__.isPromiseOrContainsPromise)(injection);\r\n        }\r\n        return resolvedRequests;\r\n    }, { constructorInjections: [], propertyInjections: [], propertyRequests: [], isAsync: false });\r\n}\r\nfunction _createInstance(constr, childRequests, resolveRequest) {\r\n    var result;\r\n    if (childRequests.length > 0) {\r\n        var resolved = _resolveRequests(childRequests, resolveRequest);\r\n        var createInstanceWithInjectionsArg = __assign(__assign({}, resolved), { constr: constr });\r\n        if (resolved.isAsync) {\r\n            result = createInstanceWithInjectionsAsync(createInstanceWithInjectionsArg);\r\n        }\r\n        else {\r\n            result = createInstanceWithInjections(createInstanceWithInjectionsArg);\r\n        }\r\n    }\r\n    else {\r\n        result = new constr();\r\n    }\r\n    return result;\r\n}\r\nfunction createInstanceWithInjections(args) {\r\n    var _a;\r\n    var instance = new ((_a = args.constr).bind.apply(_a, __spreadArray([void 0], args.constructorInjections, false)))();\r\n    args.propertyRequests.forEach(function (r, index) {\r\n        var property = r.target.identifier;\r\n        var injection = args.propertyInjections[index];\r\n        if (!r.target.isOptional() || injection !== undefined) {\r\n            instance[property] = injection;\r\n        }\r\n    });\r\n    return instance;\r\n}\r\nfunction createInstanceWithInjectionsAsync(args) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var constructorInjections, propertyInjections;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4, possiblyWaitInjections(args.constructorInjections)];\r\n                case 1:\r\n                    constructorInjections = _a.sent();\r\n                    return [4, possiblyWaitInjections(args.propertyInjections)];\r\n                case 2:\r\n                    propertyInjections = _a.sent();\r\n                    return [2, createInstanceWithInjections(__assign(__assign({}, args), { constructorInjections: constructorInjections, propertyInjections: propertyInjections }))];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction possiblyWaitInjections(possiblePromiseinjections) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var injections, _i, possiblePromiseinjections_1, injection;\r\n        return __generator(this, function (_a) {\r\n            injections = [];\r\n            for (_i = 0, possiblePromiseinjections_1 = possiblePromiseinjections; _i < possiblePromiseinjections_1.length; _i++) {\r\n                injection = possiblePromiseinjections_1[_i];\r\n                if (Array.isArray(injection)) {\r\n                    injections.push(Promise.all(injection));\r\n                }\r\n                else {\r\n                    injections.push(injection);\r\n                }\r\n            }\r\n            return [2, Promise.all(injections)];\r\n        });\r\n    });\r\n}\r\nfunction _getInstanceAfterPostConstruct(constr, result) {\r\n    var postConstructResult = _postConstruct(constr, result);\r\n    if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_1__.isPromise)(postConstructResult)) {\r\n        return postConstructResult.then(function () { return result; });\r\n    }\r\n    else {\r\n        return result;\r\n    }\r\n}\r\nfunction _postConstruct(constr, instance) {\r\n    var _a, _b;\r\n    if (Reflect.hasMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_2__.POST_CONSTRUCT, constr)) {\r\n        var data = Reflect.getMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_2__.POST_CONSTRUCT, constr);\r\n        try {\r\n            return (_b = (_a = instance)[data.value]) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n        }\r\n        catch (e) {\r\n            if (e instanceof Error) {\r\n                throw new Error((0,_constants_error_msgs__WEBPACK_IMPORTED_MODULE_3__.POST_CONSTRUCT_ERROR)(constr.name, e.message));\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction _validateInstanceResolution(binding, constr) {\r\n    if (binding.scope !== _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Singleton) {\r\n        _throwIfHandlingDeactivation(binding, constr);\r\n    }\r\n}\r\nfunction _throwIfHandlingDeactivation(binding, constr) {\r\n    var scopeErrorMessage = \"Class cannot be instantiated in \" + (binding.scope === _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Request ?\r\n        'request' :\r\n        'transient') + \" scope.\";\r\n    if (typeof binding.onDeactivation === 'function') {\r\n        throw new Error((0,_constants_error_msgs__WEBPACK_IMPORTED_MODULE_3__.ON_DEACTIVATION_ERROR)(constr.name, scopeErrorMessage));\r\n    }\r\n    if (Reflect.hasMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_2__.PRE_DESTROY, constr)) {\r\n        throw new Error((0,_constants_error_msgs__WEBPACK_IMPORTED_MODULE_3__.PRE_DESTROY_ERROR)(constr.name, scopeErrorMessage));\r\n    }\r\n}\r\nfunction resolveInstance(binding, constr, childRequests, resolveRequest) {\r\n    _validateInstanceResolution(binding, constr);\r\n    var result = _createInstance(constr, childRequests, resolveRequest);\r\n    if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_1__.isPromise)(result)) {\r\n        return result.then(function (resolvedResult) { return _getInstanceAfterPostConstruct(constr, resolvedResult); });\r\n    }\r\n    else {\r\n        return _getInstanceAfterPostConstruct(constr, result);\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/resolution/instantiation.js?");

/***/ }),

/***/ "./node_modules/inversify/es/resolution/resolver.js":
/*!**********************************************************!*\
  !*** ./node_modules/inversify/es/resolution/resolver.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   resolve: () => (/* binding */ resolve)\n/* harmony export */ });\n/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/error_msgs */ \"./node_modules/inversify/es/constants/error_msgs.js\");\n/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants/literal_types */ \"./node_modules/inversify/es/constants/literal_types.js\");\n/* harmony import */ var _planning_planner__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../planning/planner */ \"./node_modules/inversify/es/planning/planner.js\");\n/* harmony import */ var _scope_scope__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../scope/scope */ \"./node_modules/inversify/es/scope/scope.js\");\n/* harmony import */ var _utils_async__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/async */ \"./node_modules/inversify/es/utils/async.js\");\n/* harmony import */ var _utils_binding_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/binding_utils */ \"./node_modules/inversify/es/utils/binding_utils.js\");\n/* harmony import */ var _utils_exceptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/exceptions */ \"./node_modules/inversify/es/utils/exceptions.js\");\n/* harmony import */ var _instantiation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./instantiation */ \"./node_modules/inversify/es/resolution/instantiation.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar _resolveRequest = function (requestScope) {\r\n    return function (request) {\r\n        request.parentContext.setCurrentRequest(request);\r\n        var bindings = request.bindings;\r\n        var childRequests = request.childRequests;\r\n        var targetIsAnArray = request.target && request.target.isArray();\r\n        var targetParentIsNotAnArray = !request.parentRequest ||\r\n            !request.parentRequest.target ||\r\n            !request.target ||\r\n            !request.parentRequest.target.matchesArray(request.target.serviceIdentifier);\r\n        if (targetIsAnArray && targetParentIsNotAnArray) {\r\n            return childRequests.map(function (childRequest) {\r\n                var _f = _resolveRequest(requestScope);\r\n                return _f(childRequest);\r\n            });\r\n        }\r\n        else {\r\n            if (request.target.isOptional() && bindings.length === 0) {\r\n                return undefined;\r\n            }\r\n            var binding = bindings[0];\r\n            return _resolveBinding(requestScope, request, binding);\r\n        }\r\n    };\r\n};\r\nvar _resolveFactoryFromBinding = function (binding, context) {\r\n    var factoryDetails = (0,_utils_binding_utils__WEBPACK_IMPORTED_MODULE_0__.getFactoryDetails)(binding);\r\n    return (0,_utils_exceptions__WEBPACK_IMPORTED_MODULE_1__.tryAndThrowErrorIfStackOverflow)(function () { return factoryDetails.factory.bind(binding)(context); }, function () { return new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__.CIRCULAR_DEPENDENCY_IN_FACTORY(factoryDetails.factoryType, context.currentRequest.serviceIdentifier.toString())); });\r\n};\r\nvar _getResolvedFromBinding = function (requestScope, request, binding) {\r\n    var result;\r\n    var childRequests = request.childRequests;\r\n    (0,_utils_binding_utils__WEBPACK_IMPORTED_MODULE_0__.ensureFullyBound)(binding);\r\n    switch (binding.type) {\r\n        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_3__.BindingTypeEnum.ConstantValue:\r\n        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_3__.BindingTypeEnum.Function:\r\n            result = binding.cache;\r\n            break;\r\n        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_3__.BindingTypeEnum.Constructor:\r\n            result = binding.implementationType;\r\n            break;\r\n        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_3__.BindingTypeEnum.Instance:\r\n            result = (0,_instantiation__WEBPACK_IMPORTED_MODULE_4__.resolveInstance)(binding, binding.implementationType, childRequests, _resolveRequest(requestScope));\r\n            break;\r\n        default:\r\n            result = _resolveFactoryFromBinding(binding, request.parentContext);\r\n    }\r\n    return result;\r\n};\r\nvar _resolveInScope = function (requestScope, binding, resolveFromBinding) {\r\n    var result = (0,_scope_scope__WEBPACK_IMPORTED_MODULE_5__.tryGetFromScope)(requestScope, binding);\r\n    if (result !== null) {\r\n        return result;\r\n    }\r\n    result = resolveFromBinding();\r\n    (0,_scope_scope__WEBPACK_IMPORTED_MODULE_5__.saveToScope)(requestScope, binding, result);\r\n    return result;\r\n};\r\nvar _resolveBinding = function (requestScope, request, binding) {\r\n    return _resolveInScope(requestScope, binding, function () {\r\n        var result = _getResolvedFromBinding(requestScope, request, binding);\r\n        if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_6__.isPromise)(result)) {\r\n            result = result.then(function (resolved) { return _onActivation(request, binding, resolved); });\r\n        }\r\n        else {\r\n            result = _onActivation(request, binding, result);\r\n        }\r\n        return result;\r\n    });\r\n};\r\nfunction _onActivation(request, binding, resolved) {\r\n    var result = _bindingActivation(request.parentContext, binding, resolved);\r\n    var containersIterator = _getContainersIterator(request.parentContext.container);\r\n    var container;\r\n    var containersIteratorResult = containersIterator.next();\r\n    do {\r\n        container = containersIteratorResult.value;\r\n        var context_1 = request.parentContext;\r\n        var serviceIdentifier = request.serviceIdentifier;\r\n        var activationsIterator = _getContainerActivationsForService(container, serviceIdentifier);\r\n        if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_6__.isPromise)(result)) {\r\n            result = _activateContainerAsync(activationsIterator, context_1, result);\r\n        }\r\n        else {\r\n            result = _activateContainer(activationsIterator, context_1, result);\r\n        }\r\n        containersIteratorResult = containersIterator.next();\r\n    } while (containersIteratorResult.done !== true && !(0,_planning_planner__WEBPACK_IMPORTED_MODULE_7__.getBindingDictionary)(container).hasKey(request.serviceIdentifier));\r\n    return result;\r\n}\r\nvar _bindingActivation = function (context, binding, previousResult) {\r\n    var result;\r\n    if (typeof binding.onActivation === 'function') {\r\n        result = binding.onActivation(context, previousResult);\r\n    }\r\n    else {\r\n        result = previousResult;\r\n    }\r\n    return result;\r\n};\r\nvar _activateContainer = function (activationsIterator, context, result) {\r\n    var activation = activationsIterator.next();\r\n    while (!activation.done) {\r\n        result = activation.value(context, result);\r\n        if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_6__.isPromise)(result)) {\r\n            return _activateContainerAsync(activationsIterator, context, result);\r\n        }\r\n        activation = activationsIterator.next();\r\n    }\r\n    return result;\r\n};\r\nvar _activateContainerAsync = function (activationsIterator, context, resultPromise) { return __awaiter(void 0, void 0, void 0, function () {\r\n    var result, activation;\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0: return [4, resultPromise];\r\n            case 1:\r\n                result = _a.sent();\r\n                activation = activationsIterator.next();\r\n                _a.label = 2;\r\n            case 2:\r\n                if (!!activation.done) return [3, 4];\r\n                return [4, activation.value(context, result)];\r\n            case 3:\r\n                result = _a.sent();\r\n                activation = activationsIterator.next();\r\n                return [3, 2];\r\n            case 4: return [2, result];\r\n        }\r\n    });\r\n}); };\r\nvar _getContainerActivationsForService = function (container, serviceIdentifier) {\r\n    var activations = container._activations;\r\n    return activations.hasKey(serviceIdentifier) ? activations.get(serviceIdentifier).values() : [].values();\r\n};\r\nvar _getContainersIterator = function (container) {\r\n    var containersStack = [container];\r\n    var parent = container.parent;\r\n    while (parent !== null) {\r\n        containersStack.push(parent);\r\n        parent = parent.parent;\r\n    }\r\n    var getNextContainer = function () {\r\n        var nextContainer = containersStack.pop();\r\n        if (nextContainer !== undefined) {\r\n            return { done: false, value: nextContainer };\r\n        }\r\n        else {\r\n            return { done: true, value: undefined };\r\n        }\r\n    };\r\n    var containersIterator = {\r\n        next: getNextContainer,\r\n    };\r\n    return containersIterator;\r\n};\r\nfunction resolve(context) {\r\n    var _f = _resolveRequest(context.plan.rootRequest.requestScope);\r\n    return _f(context.plan.rootRequest);\r\n}\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/resolution/resolver.js?");

/***/ }),

/***/ "./node_modules/inversify/es/scope/scope.js":
/*!**************************************************!*\
  !*** ./node_modules/inversify/es/scope/scope.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   saveToScope: () => (/* binding */ saveToScope),\n/* harmony export */   tryGetFromScope: () => (/* binding */ tryGetFromScope)\n/* harmony export */ });\n/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/literal_types */ \"./node_modules/inversify/es/constants/literal_types.js\");\n/* harmony import */ var _utils_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/async */ \"./node_modules/inversify/es/utils/async.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\n\r\n\r\nvar tryGetFromScope = function (requestScope, binding) {\r\n    if ((binding.scope === _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Singleton) && binding.activated) {\r\n        return binding.cache;\r\n    }\r\n    if (binding.scope === _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Request &&\r\n        requestScope.has(binding.id)) {\r\n        return requestScope.get(binding.id);\r\n    }\r\n    return null;\r\n};\r\nvar saveToScope = function (requestScope, binding, result) {\r\n    if (binding.scope === _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Singleton) {\r\n        _saveToSingletonScope(binding, result);\r\n    }\r\n    if (binding.scope === _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Request) {\r\n        _saveToRequestScope(requestScope, binding, result);\r\n    }\r\n};\r\nvar _saveToRequestScope = function (requestScope, binding, result) {\r\n    if (!requestScope.has(binding.id)) {\r\n        requestScope.set(binding.id, result);\r\n    }\r\n};\r\nvar _saveToSingletonScope = function (binding, result) {\r\n    binding.cache = result;\r\n    binding.activated = true;\r\n    if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_1__.isPromise)(result)) {\r\n        void _saveAsyncResultToSingletonScope(binding, result);\r\n    }\r\n};\r\nvar _saveAsyncResultToSingletonScope = function (binding, asyncResult) { return __awaiter(void 0, void 0, void 0, function () {\r\n    var result, ex_1;\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                _a.trys.push([0, 2, , 3]);\r\n                return [4, asyncResult];\r\n            case 1:\r\n                result = _a.sent();\r\n                binding.cache = result;\r\n                return [3, 3];\r\n            case 2:\r\n                ex_1 = _a.sent();\r\n                binding.cache = null;\r\n                binding.activated = false;\r\n                throw ex_1;\r\n            case 3: return [2];\r\n        }\r\n    });\r\n}); };\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/scope/scope.js?");

/***/ }),

/***/ "./node_modules/inversify/es/syntax/binding_in_syntax.js":
/*!***************************************************************!*\
  !*** ./node_modules/inversify/es/syntax/binding_in_syntax.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BindingInSyntax: () => (/* binding */ BindingInSyntax)\n/* harmony export */ });\n/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/literal_types */ \"./node_modules/inversify/es/constants/literal_types.js\");\n/* harmony import */ var _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binding_when_on_syntax */ \"./node_modules/inversify/es/syntax/binding_when_on_syntax.js\");\n\r\n\r\nvar BindingInSyntax = (function () {\r\n    function BindingInSyntax(binding) {\r\n        this._binding = binding;\r\n    }\r\n    BindingInSyntax.prototype.inRequestScope = function () {\r\n        this._binding.scope = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Request;\r\n        return new _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_1__.BindingWhenOnSyntax(this._binding);\r\n    };\r\n    BindingInSyntax.prototype.inSingletonScope = function () {\r\n        this._binding.scope = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Singleton;\r\n        return new _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_1__.BindingWhenOnSyntax(this._binding);\r\n    };\r\n    BindingInSyntax.prototype.inTransientScope = function () {\r\n        this._binding.scope = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Transient;\r\n        return new _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_1__.BindingWhenOnSyntax(this._binding);\r\n    };\r\n    return BindingInSyntax;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/syntax/binding_in_syntax.js?");

/***/ }),

/***/ "./node_modules/inversify/es/syntax/binding_in_when_on_syntax.js":
/*!***********************************************************************!*\
  !*** ./node_modules/inversify/es/syntax/binding_in_when_on_syntax.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BindingInWhenOnSyntax: () => (/* binding */ BindingInWhenOnSyntax)\n/* harmony export */ });\n/* harmony import */ var _binding_in_syntax__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./binding_in_syntax */ \"./node_modules/inversify/es/syntax/binding_in_syntax.js\");\n/* harmony import */ var _binding_on_syntax__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binding_on_syntax */ \"./node_modules/inversify/es/syntax/binding_on_syntax.js\");\n/* harmony import */ var _binding_when_syntax__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./binding_when_syntax */ \"./node_modules/inversify/es/syntax/binding_when_syntax.js\");\n\r\n\r\n\r\nvar BindingInWhenOnSyntax = (function () {\r\n    function BindingInWhenOnSyntax(binding) {\r\n        this._binding = binding;\r\n        this._bindingWhenSyntax = new _binding_when_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingWhenSyntax(this._binding);\r\n        this._bindingOnSyntax = new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_1__.BindingOnSyntax(this._binding);\r\n        this._bindingInSyntax = new _binding_in_syntax__WEBPACK_IMPORTED_MODULE_2__.BindingInSyntax(binding);\r\n    }\r\n    BindingInWhenOnSyntax.prototype.inRequestScope = function () {\r\n        return this._bindingInSyntax.inRequestScope();\r\n    };\r\n    BindingInWhenOnSyntax.prototype.inSingletonScope = function () {\r\n        return this._bindingInSyntax.inSingletonScope();\r\n    };\r\n    BindingInWhenOnSyntax.prototype.inTransientScope = function () {\r\n        return this._bindingInSyntax.inTransientScope();\r\n    };\r\n    BindingInWhenOnSyntax.prototype.when = function (constraint) {\r\n        return this._bindingWhenSyntax.when(constraint);\r\n    };\r\n    BindingInWhenOnSyntax.prototype.whenTargetNamed = function (name) {\r\n        return this._bindingWhenSyntax.whenTargetNamed(name);\r\n    };\r\n    BindingInWhenOnSyntax.prototype.whenTargetIsDefault = function () {\r\n        return this._bindingWhenSyntax.whenTargetIsDefault();\r\n    };\r\n    BindingInWhenOnSyntax.prototype.whenTargetTagged = function (tag, value) {\r\n        return this._bindingWhenSyntax.whenTargetTagged(tag, value);\r\n    };\r\n    BindingInWhenOnSyntax.prototype.whenInjectedInto = function (parent) {\r\n        return this._bindingWhenSyntax.whenInjectedInto(parent);\r\n    };\r\n    BindingInWhenOnSyntax.prototype.whenParentNamed = function (name) {\r\n        return this._bindingWhenSyntax.whenParentNamed(name);\r\n    };\r\n    BindingInWhenOnSyntax.prototype.whenParentTagged = function (tag, value) {\r\n        return this._bindingWhenSyntax.whenParentTagged(tag, value);\r\n    };\r\n    BindingInWhenOnSyntax.prototype.whenAnyAncestorIs = function (ancestor) {\r\n        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);\r\n    };\r\n    BindingInWhenOnSyntax.prototype.whenNoAncestorIs = function (ancestor) {\r\n        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);\r\n    };\r\n    BindingInWhenOnSyntax.prototype.whenAnyAncestorNamed = function (name) {\r\n        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);\r\n    };\r\n    BindingInWhenOnSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {\r\n        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);\r\n    };\r\n    BindingInWhenOnSyntax.prototype.whenNoAncestorNamed = function (name) {\r\n        return this._bindingWhenSyntax.whenNoAncestorNamed(name);\r\n    };\r\n    BindingInWhenOnSyntax.prototype.whenNoAncestorTagged = function (tag, value) {\r\n        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);\r\n    };\r\n    BindingInWhenOnSyntax.prototype.whenAnyAncestorMatches = function (constraint) {\r\n        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);\r\n    };\r\n    BindingInWhenOnSyntax.prototype.whenNoAncestorMatches = function (constraint) {\r\n        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);\r\n    };\r\n    BindingInWhenOnSyntax.prototype.onActivation = function (handler) {\r\n        return this._bindingOnSyntax.onActivation(handler);\r\n    };\r\n    BindingInWhenOnSyntax.prototype.onDeactivation = function (handler) {\r\n        return this._bindingOnSyntax.onDeactivation(handler);\r\n    };\r\n    return BindingInWhenOnSyntax;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/syntax/binding_in_when_on_syntax.js?");

/***/ }),

/***/ "./node_modules/inversify/es/syntax/binding_on_syntax.js":
/*!***************************************************************!*\
  !*** ./node_modules/inversify/es/syntax/binding_on_syntax.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BindingOnSyntax: () => (/* binding */ BindingOnSyntax)\n/* harmony export */ });\n/* harmony import */ var _binding_when_syntax__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./binding_when_syntax */ \"./node_modules/inversify/es/syntax/binding_when_syntax.js\");\n\r\nvar BindingOnSyntax = (function () {\r\n    function BindingOnSyntax(binding) {\r\n        this._binding = binding;\r\n    }\r\n    BindingOnSyntax.prototype.onActivation = function (handler) {\r\n        this._binding.onActivation = handler;\r\n        return new _binding_when_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingWhenSyntax(this._binding);\r\n    };\r\n    BindingOnSyntax.prototype.onDeactivation = function (handler) {\r\n        this._binding.onDeactivation = handler;\r\n        return new _binding_when_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingWhenSyntax(this._binding);\r\n    };\r\n    return BindingOnSyntax;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/syntax/binding_on_syntax.js?");

/***/ }),

/***/ "./node_modules/inversify/es/syntax/binding_to_syntax.js":
/*!***************************************************************!*\
  !*** ./node_modules/inversify/es/syntax/binding_to_syntax.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BindingToSyntax: () => (/* binding */ BindingToSyntax)\n/* harmony export */ });\n/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/error_msgs */ \"./node_modules/inversify/es/constants/error_msgs.js\");\n/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/literal_types */ \"./node_modules/inversify/es/constants/literal_types.js\");\n/* harmony import */ var _binding_in_when_on_syntax__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binding_in_when_on_syntax */ \"./node_modules/inversify/es/syntax/binding_in_when_on_syntax.js\");\n/* harmony import */ var _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./binding_when_on_syntax */ \"./node_modules/inversify/es/syntax/binding_when_on_syntax.js\");\n\r\n\r\n\r\n\r\nvar BindingToSyntax = (function () {\r\n    function BindingToSyntax(binding) {\r\n        this._binding = binding;\r\n    }\r\n    BindingToSyntax.prototype.to = function (constructor) {\r\n        this._binding.type = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Instance;\r\n        this._binding.implementationType = constructor;\r\n        return new _binding_in_when_on_syntax__WEBPACK_IMPORTED_MODULE_1__.BindingInWhenOnSyntax(this._binding);\r\n    };\r\n    BindingToSyntax.prototype.toSelf = function () {\r\n        if (typeof this._binding.serviceIdentifier !== \"function\") {\r\n            throw new Error(\"\" + _constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__.INVALID_TO_SELF_VALUE);\r\n        }\r\n        var self = this._binding.serviceIdentifier;\r\n        return this.to(self);\r\n    };\r\n    BindingToSyntax.prototype.toConstantValue = function (value) {\r\n        this._binding.type = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.ConstantValue;\r\n        this._binding.cache = value;\r\n        this._binding.dynamicValue = null;\r\n        this._binding.implementationType = null;\r\n        this._binding.scope = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Singleton;\r\n        return new _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_3__.BindingWhenOnSyntax(this._binding);\r\n    };\r\n    BindingToSyntax.prototype.toDynamicValue = function (func) {\r\n        this._binding.type = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.DynamicValue;\r\n        this._binding.cache = null;\r\n        this._binding.dynamicValue = func;\r\n        this._binding.implementationType = null;\r\n        return new _binding_in_when_on_syntax__WEBPACK_IMPORTED_MODULE_1__.BindingInWhenOnSyntax(this._binding);\r\n    };\r\n    BindingToSyntax.prototype.toConstructor = function (constructor) {\r\n        this._binding.type = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Constructor;\r\n        this._binding.implementationType = constructor;\r\n        this._binding.scope = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Singleton;\r\n        return new _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_3__.BindingWhenOnSyntax(this._binding);\r\n    };\r\n    BindingToSyntax.prototype.toFactory = function (factory) {\r\n        this._binding.type = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Factory;\r\n        this._binding.factory = factory;\r\n        this._binding.scope = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Singleton;\r\n        return new _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_3__.BindingWhenOnSyntax(this._binding);\r\n    };\r\n    BindingToSyntax.prototype.toFunction = function (func) {\r\n        if (typeof func !== \"function\") {\r\n            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__.INVALID_FUNCTION_BINDING);\r\n        }\r\n        var bindingWhenOnSyntax = this.toConstantValue(func);\r\n        this._binding.type = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Function;\r\n        this._binding.scope = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Singleton;\r\n        return bindingWhenOnSyntax;\r\n    };\r\n    BindingToSyntax.prototype.toAutoFactory = function (serviceIdentifier) {\r\n        this._binding.type = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Factory;\r\n        this._binding.factory = function (context) {\r\n            var autofactory = function () { return context.container.get(serviceIdentifier); };\r\n            return autofactory;\r\n        };\r\n        this._binding.scope = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Singleton;\r\n        return new _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_3__.BindingWhenOnSyntax(this._binding);\r\n    };\r\n    BindingToSyntax.prototype.toAutoNamedFactory = function (serviceIdentifier) {\r\n        this._binding.type = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Factory;\r\n        this._binding.factory = function (context) {\r\n            return function (named) { return context.container.getNamed(serviceIdentifier, named); };\r\n        };\r\n        return new _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_3__.BindingWhenOnSyntax(this._binding);\r\n    };\r\n    BindingToSyntax.prototype.toProvider = function (provider) {\r\n        this._binding.type = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Provider;\r\n        this._binding.provider = provider;\r\n        this._binding.scope = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Singleton;\r\n        return new _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_3__.BindingWhenOnSyntax(this._binding);\r\n    };\r\n    BindingToSyntax.prototype.toService = function (service) {\r\n        this.toDynamicValue(function (context) { return context.container.get(service); });\r\n    };\r\n    return BindingToSyntax;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/syntax/binding_to_syntax.js?");

/***/ }),

/***/ "./node_modules/inversify/es/syntax/binding_when_on_syntax.js":
/*!********************************************************************!*\
  !*** ./node_modules/inversify/es/syntax/binding_when_on_syntax.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BindingWhenOnSyntax: () => (/* binding */ BindingWhenOnSyntax)\n/* harmony export */ });\n/* harmony import */ var _binding_on_syntax__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binding_on_syntax */ \"./node_modules/inversify/es/syntax/binding_on_syntax.js\");\n/* harmony import */ var _binding_when_syntax__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./binding_when_syntax */ \"./node_modules/inversify/es/syntax/binding_when_syntax.js\");\n\r\n\r\nvar BindingWhenOnSyntax = (function () {\r\n    function BindingWhenOnSyntax(binding) {\r\n        this._binding = binding;\r\n        this._bindingWhenSyntax = new _binding_when_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingWhenSyntax(this._binding);\r\n        this._bindingOnSyntax = new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_1__.BindingOnSyntax(this._binding);\r\n    }\r\n    BindingWhenOnSyntax.prototype.when = function (constraint) {\r\n        return this._bindingWhenSyntax.when(constraint);\r\n    };\r\n    BindingWhenOnSyntax.prototype.whenTargetNamed = function (name) {\r\n        return this._bindingWhenSyntax.whenTargetNamed(name);\r\n    };\r\n    BindingWhenOnSyntax.prototype.whenTargetIsDefault = function () {\r\n        return this._bindingWhenSyntax.whenTargetIsDefault();\r\n    };\r\n    BindingWhenOnSyntax.prototype.whenTargetTagged = function (tag, value) {\r\n        return this._bindingWhenSyntax.whenTargetTagged(tag, value);\r\n    };\r\n    BindingWhenOnSyntax.prototype.whenInjectedInto = function (parent) {\r\n        return this._bindingWhenSyntax.whenInjectedInto(parent);\r\n    };\r\n    BindingWhenOnSyntax.prototype.whenParentNamed = function (name) {\r\n        return this._bindingWhenSyntax.whenParentNamed(name);\r\n    };\r\n    BindingWhenOnSyntax.prototype.whenParentTagged = function (tag, value) {\r\n        return this._bindingWhenSyntax.whenParentTagged(tag, value);\r\n    };\r\n    BindingWhenOnSyntax.prototype.whenAnyAncestorIs = function (ancestor) {\r\n        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);\r\n    };\r\n    BindingWhenOnSyntax.prototype.whenNoAncestorIs = function (ancestor) {\r\n        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);\r\n    };\r\n    BindingWhenOnSyntax.prototype.whenAnyAncestorNamed = function (name) {\r\n        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);\r\n    };\r\n    BindingWhenOnSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {\r\n        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);\r\n    };\r\n    BindingWhenOnSyntax.prototype.whenNoAncestorNamed = function (name) {\r\n        return this._bindingWhenSyntax.whenNoAncestorNamed(name);\r\n    };\r\n    BindingWhenOnSyntax.prototype.whenNoAncestorTagged = function (tag, value) {\r\n        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);\r\n    };\r\n    BindingWhenOnSyntax.prototype.whenAnyAncestorMatches = function (constraint) {\r\n        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);\r\n    };\r\n    BindingWhenOnSyntax.prototype.whenNoAncestorMatches = function (constraint) {\r\n        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);\r\n    };\r\n    BindingWhenOnSyntax.prototype.onActivation = function (handler) {\r\n        return this._bindingOnSyntax.onActivation(handler);\r\n    };\r\n    BindingWhenOnSyntax.prototype.onDeactivation = function (handler) {\r\n        return this._bindingOnSyntax.onDeactivation(handler);\r\n    };\r\n    return BindingWhenOnSyntax;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/syntax/binding_when_on_syntax.js?");

/***/ }),

/***/ "./node_modules/inversify/es/syntax/binding_when_syntax.js":
/*!*****************************************************************!*\
  !*** ./node_modules/inversify/es/syntax/binding_when_syntax.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BindingWhenSyntax: () => (/* binding */ BindingWhenSyntax)\n/* harmony export */ });\n/* harmony import */ var _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./binding_on_syntax */ \"./node_modules/inversify/es/syntax/binding_on_syntax.js\");\n/* harmony import */ var _constraint_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constraint_helpers */ \"./node_modules/inversify/es/syntax/constraint_helpers.js\");\n\r\n\r\nvar BindingWhenSyntax = (function () {\r\n    function BindingWhenSyntax(binding) {\r\n        this._binding = binding;\r\n    }\r\n    BindingWhenSyntax.prototype.when = function (constraint) {\r\n        this._binding.constraint = constraint;\r\n        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);\r\n    };\r\n    BindingWhenSyntax.prototype.whenTargetNamed = function (name) {\r\n        this._binding.constraint = (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.namedConstraint)(name);\r\n        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);\r\n    };\r\n    BindingWhenSyntax.prototype.whenTargetIsDefault = function () {\r\n        this._binding.constraint = function (request) {\r\n            if (request === null) {\r\n                return false;\r\n            }\r\n            var targetIsDefault = (request.target !== null) &&\r\n                (!request.target.isNamed()) &&\r\n                (!request.target.isTagged());\r\n            return targetIsDefault;\r\n        };\r\n        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);\r\n    };\r\n    BindingWhenSyntax.prototype.whenTargetTagged = function (tag, value) {\r\n        this._binding.constraint = (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.taggedConstraint)(tag)(value);\r\n        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);\r\n    };\r\n    BindingWhenSyntax.prototype.whenInjectedInto = function (parent) {\r\n        this._binding.constraint = function (request) {\r\n            return request !== null && (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.typeConstraint)(parent)(request.parentRequest);\r\n        };\r\n        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);\r\n    };\r\n    BindingWhenSyntax.prototype.whenParentNamed = function (name) {\r\n        this._binding.constraint = function (request) {\r\n            return request !== null && (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.namedConstraint)(name)(request.parentRequest);\r\n        };\r\n        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);\r\n    };\r\n    BindingWhenSyntax.prototype.whenParentTagged = function (tag, value) {\r\n        this._binding.constraint = function (request) {\r\n            return request !== null && (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.taggedConstraint)(tag)(value)(request.parentRequest);\r\n        };\r\n        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);\r\n    };\r\n    BindingWhenSyntax.prototype.whenAnyAncestorIs = function (ancestor) {\r\n        this._binding.constraint = function (request) {\r\n            return request !== null && (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.traverseAncerstors)(request, (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.typeConstraint)(ancestor));\r\n        };\r\n        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);\r\n    };\r\n    BindingWhenSyntax.prototype.whenNoAncestorIs = function (ancestor) {\r\n        this._binding.constraint = function (request) {\r\n            return request !== null && !(0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.traverseAncerstors)(request, (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.typeConstraint)(ancestor));\r\n        };\r\n        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);\r\n    };\r\n    BindingWhenSyntax.prototype.whenAnyAncestorNamed = function (name) {\r\n        this._binding.constraint = function (request) {\r\n            return request !== null && (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.traverseAncerstors)(request, (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.namedConstraint)(name));\r\n        };\r\n        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);\r\n    };\r\n    BindingWhenSyntax.prototype.whenNoAncestorNamed = function (name) {\r\n        this._binding.constraint = function (request) {\r\n            return request !== null && !(0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.traverseAncerstors)(request, (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.namedConstraint)(name));\r\n        };\r\n        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);\r\n    };\r\n    BindingWhenSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {\r\n        this._binding.constraint = function (request) {\r\n            return request !== null && (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.traverseAncerstors)(request, (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.taggedConstraint)(tag)(value));\r\n        };\r\n        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);\r\n    };\r\n    BindingWhenSyntax.prototype.whenNoAncestorTagged = function (tag, value) {\r\n        this._binding.constraint = function (request) {\r\n            return request !== null && !(0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.traverseAncerstors)(request, (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.taggedConstraint)(tag)(value));\r\n        };\r\n        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);\r\n    };\r\n    BindingWhenSyntax.prototype.whenAnyAncestorMatches = function (constraint) {\r\n        this._binding.constraint = function (request) {\r\n            return request !== null && (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.traverseAncerstors)(request, constraint);\r\n        };\r\n        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);\r\n    };\r\n    BindingWhenSyntax.prototype.whenNoAncestorMatches = function (constraint) {\r\n        this._binding.constraint = function (request) {\r\n            return request !== null && !(0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.traverseAncerstors)(request, constraint);\r\n        };\r\n        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);\r\n    };\r\n    return BindingWhenSyntax;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/syntax/binding_when_syntax.js?");

/***/ }),

/***/ "./node_modules/inversify/es/syntax/constraint_helpers.js":
/*!****************************************************************!*\
  !*** ./node_modules/inversify/es/syntax/constraint_helpers.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   namedConstraint: () => (/* binding */ namedConstraint),\n/* harmony export */   taggedConstraint: () => (/* binding */ taggedConstraint),\n/* harmony export */   traverseAncerstors: () => (/* binding */ traverseAncerstors),\n/* harmony export */   typeConstraint: () => (/* binding */ typeConstraint)\n/* harmony export */ });\n/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/metadata_keys */ \"./node_modules/inversify/es/constants/metadata_keys.js\");\n/* harmony import */ var _planning_metadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../planning/metadata */ \"./node_modules/inversify/es/planning/metadata.js\");\n\r\n\r\nvar traverseAncerstors = function (request, constraint) {\r\n    var parent = request.parentRequest;\r\n    if (parent !== null) {\r\n        return constraint(parent) ? true : traverseAncerstors(parent, constraint);\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n};\r\nvar taggedConstraint = function (key) { return function (value) {\r\n    var constraint = function (request) {\r\n        return request !== null && request.target !== null && request.target.matchesTag(key)(value);\r\n    };\r\n    constraint.metaData = new _planning_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata(key, value);\r\n    return constraint;\r\n}; };\r\nvar namedConstraint = taggedConstraint(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__.NAMED_TAG);\r\nvar typeConstraint = function (type) { return function (request) {\r\n    var binding = null;\r\n    if (request !== null) {\r\n        binding = request.bindings[0];\r\n        if (typeof type === 'string') {\r\n            var serviceIdentifier = binding.serviceIdentifier;\r\n            return serviceIdentifier === type;\r\n        }\r\n        else {\r\n            var constructor = request.bindings[0].implementationType;\r\n            return type === constructor;\r\n        }\r\n    }\r\n    return false;\r\n}; };\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/syntax/constraint_helpers.js?");

/***/ }),

/***/ "./node_modules/inversify/es/utils/async.js":
/*!**************************************************!*\
  !*** ./node_modules/inversify/es/utils/async.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPromise: () => (/* binding */ isPromise),\n/* harmony export */   isPromiseOrContainsPromise: () => (/* binding */ isPromiseOrContainsPromise)\n/* harmony export */ });\nfunction isPromise(object) {\r\n    var isObjectOrFunction = (typeof object === 'object' && object !== null) || typeof object === 'function';\r\n    return isObjectOrFunction && typeof object.then === \"function\";\r\n}\r\nfunction isPromiseOrContainsPromise(object) {\r\n    if (isPromise(object)) {\r\n        return true;\r\n    }\r\n    return Array.isArray(object) && object.some(isPromise);\r\n}\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/utils/async.js?");

/***/ }),

/***/ "./node_modules/inversify/es/utils/binding_utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/inversify/es/utils/binding_utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensureFullyBound: () => (/* binding */ ensureFullyBound),\n/* harmony export */   getFactoryDetails: () => (/* binding */ getFactoryDetails),\n/* harmony export */   multiBindToService: () => (/* binding */ multiBindToService)\n/* harmony export */ });\n/* harmony import */ var _utils_serialization__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/serialization */ \"./node_modules/inversify/es/utils/serialization.js\");\n/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/error_msgs */ \"./node_modules/inversify/es/constants/error_msgs.js\");\n/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/literal_types */ \"./node_modules/inversify/es/constants/literal_types.js\");\n/* harmony import */ var _factory_type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./factory_type */ \"./node_modules/inversify/es/utils/factory_type.js\");\n\r\n\r\n\r\n\r\nvar multiBindToService = function (container) {\r\n    return function (service) {\r\n        return function () {\r\n            var types = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                types[_i] = arguments[_i];\r\n            }\r\n            return types.forEach(function (t) { return container.bind(t).toService(service); });\r\n        };\r\n    };\r\n};\r\nvar ensureFullyBound = function (binding) {\r\n    var boundValue = null;\r\n    switch (binding.type) {\r\n        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.ConstantValue:\r\n        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Function:\r\n            boundValue = binding.cache;\r\n            break;\r\n        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Constructor:\r\n        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Instance:\r\n            boundValue = binding.implementationType;\r\n            break;\r\n        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.DynamicValue:\r\n            boundValue = binding.dynamicValue;\r\n            break;\r\n        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Provider:\r\n            boundValue = binding.provider;\r\n            break;\r\n        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Factory:\r\n            boundValue = binding.factory;\r\n            break;\r\n    }\r\n    if (boundValue === null) {\r\n        var serviceIdentifierAsString = (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_1__.getServiceIdentifierAsString)(binding.serviceIdentifier);\r\n        throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__.INVALID_BINDING_TYPE + \" \" + serviceIdentifierAsString);\r\n    }\r\n};\r\nvar getFactoryDetails = function (binding) {\r\n    switch (binding.type) {\r\n        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Factory:\r\n            return { factory: binding.factory, factoryType: _factory_type__WEBPACK_IMPORTED_MODULE_3__.FactoryType.Factory };\r\n        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Provider:\r\n            return { factory: binding.provider, factoryType: _factory_type__WEBPACK_IMPORTED_MODULE_3__.FactoryType.Provider };\r\n        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.DynamicValue:\r\n            return { factory: binding.dynamicValue, factoryType: _factory_type__WEBPACK_IMPORTED_MODULE_3__.FactoryType.DynamicValue };\r\n        default:\r\n            throw new Error(\"Unexpected factory type \" + binding.type);\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/utils/binding_utils.js?");

/***/ }),

/***/ "./node_modules/inversify/es/utils/clonable.js":
/*!*****************************************************!*\
  !*** ./node_modules/inversify/es/utils/clonable.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isClonable: () => (/* binding */ isClonable)\n/* harmony export */ });\nfunction isClonable(obj) {\r\n    return (typeof obj === 'object')\r\n        && (obj !== null)\r\n        && ('clone' in obj)\r\n        && typeof obj.clone === 'function';\r\n}\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/utils/clonable.js?");

/***/ }),

/***/ "./node_modules/inversify/es/utils/exceptions.js":
/*!*******************************************************!*\
  !*** ./node_modules/inversify/es/utils/exceptions.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isStackOverflowExeption: () => (/* binding */ isStackOverflowExeption),\n/* harmony export */   tryAndThrowErrorIfStackOverflow: () => (/* binding */ tryAndThrowErrorIfStackOverflow)\n/* harmony export */ });\n/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/error_msgs */ \"./node_modules/inversify/es/constants/error_msgs.js\");\n\r\nfunction isStackOverflowExeption(error) {\r\n    return (error instanceof RangeError ||\r\n        error.message === _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.STACK_OVERFLOW);\r\n}\r\nvar tryAndThrowErrorIfStackOverflow = function (fn, errorCallback) {\r\n    try {\r\n        return fn();\r\n    }\r\n    catch (error) {\r\n        if (isStackOverflowExeption(error)) {\r\n            error = errorCallback();\r\n        }\r\n        throw error;\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/utils/exceptions.js?");

/***/ }),

/***/ "./node_modules/inversify/es/utils/factory_type.js":
/*!*********************************************************!*\
  !*** ./node_modules/inversify/es/utils/factory_type.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FactoryType: () => (/* binding */ FactoryType)\n/* harmony export */ });\nvar FactoryType;\r\n(function (FactoryType) {\r\n    FactoryType[\"DynamicValue\"] = \"toDynamicValue\";\r\n    FactoryType[\"Factory\"] = \"toFactory\";\r\n    FactoryType[\"Provider\"] = \"toProvider\";\r\n})(FactoryType || (FactoryType = {}));\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/utils/factory_type.js?");

/***/ }),

/***/ "./node_modules/inversify/es/utils/id.js":
/*!***********************************************!*\
  !*** ./node_modules/inversify/es/utils/id.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   id: () => (/* binding */ id)\n/* harmony export */ });\nvar idCounter = 0;\r\nfunction id() {\r\n    return idCounter++;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/utils/id.js?");

/***/ }),

/***/ "./node_modules/inversify/es/utils/js.js":
/*!***********************************************!*\
  !*** ./node_modules/inversify/es/utils/js.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFirstArrayDuplicate: () => (/* binding */ getFirstArrayDuplicate)\n/* harmony export */ });\nfunction getFirstArrayDuplicate(array) {\r\n    var seenValues = new Set();\r\n    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\r\n        var entry = array_1[_i];\r\n        if (seenValues.has(entry)) {\r\n            return entry;\r\n        }\r\n        else {\r\n            seenValues.add(entry);\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/utils/js.js?");

/***/ }),

/***/ "./node_modules/inversify/es/utils/serialization.js":
/*!**********************************************************!*\
  !*** ./node_modules/inversify/es/utils/serialization.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   circularDependencyToException: () => (/* binding */ circularDependencyToException),\n/* harmony export */   getFunctionName: () => (/* binding */ getFunctionName),\n/* harmony export */   getServiceIdentifierAsString: () => (/* binding */ getServiceIdentifierAsString),\n/* harmony export */   getSymbolDescription: () => (/* binding */ getSymbolDescription),\n/* harmony export */   listMetadataForTarget: () => (/* binding */ listMetadataForTarget),\n/* harmony export */   listRegisteredBindingsForServiceIdentifier: () => (/* binding */ listRegisteredBindingsForServiceIdentifier)\n/* harmony export */ });\n/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/error_msgs */ \"./node_modules/inversify/es/constants/error_msgs.js\");\n\r\nfunction getServiceIdentifierAsString(serviceIdentifier) {\r\n    if (typeof serviceIdentifier === 'function') {\r\n        var _serviceIdentifier = serviceIdentifier;\r\n        return _serviceIdentifier.name;\r\n    }\r\n    else if (typeof serviceIdentifier === 'symbol') {\r\n        return serviceIdentifier.toString();\r\n    }\r\n    else {\r\n        var _serviceIdentifier = serviceIdentifier;\r\n        return _serviceIdentifier;\r\n    }\r\n}\r\nfunction listRegisteredBindingsForServiceIdentifier(container, serviceIdentifier, getBindings) {\r\n    var registeredBindingsList = '';\r\n    var registeredBindings = getBindings(container, serviceIdentifier);\r\n    if (registeredBindings.length !== 0) {\r\n        registeredBindingsList = '\\nRegistered bindings:';\r\n        registeredBindings.forEach(function (binding) {\r\n            var name = 'Object';\r\n            if (binding.implementationType !== null) {\r\n                name = getFunctionName(binding.implementationType);\r\n            }\r\n            registeredBindingsList = registeredBindingsList + \"\\n \" + name;\r\n            if (binding.constraint.metaData) {\r\n                registeredBindingsList = registeredBindingsList + \" - \" + binding.constraint.metaData;\r\n            }\r\n        });\r\n    }\r\n    return registeredBindingsList;\r\n}\r\nfunction alreadyDependencyChain(request, serviceIdentifier) {\r\n    if (request.parentRequest === null) {\r\n        return false;\r\n    }\r\n    else if (request.parentRequest.serviceIdentifier === serviceIdentifier) {\r\n        return true;\r\n    }\r\n    else {\r\n        return alreadyDependencyChain(request.parentRequest, serviceIdentifier);\r\n    }\r\n}\r\nfunction dependencyChainToString(request) {\r\n    function _createStringArr(req, result) {\r\n        if (result === void 0) { result = []; }\r\n        var serviceIdentifier = getServiceIdentifierAsString(req.serviceIdentifier);\r\n        result.push(serviceIdentifier);\r\n        if (req.parentRequest !== null) {\r\n            return _createStringArr(req.parentRequest, result);\r\n        }\r\n        return result;\r\n    }\r\n    var stringArr = _createStringArr(request);\r\n    return stringArr.reverse().join(' --> ');\r\n}\r\nfunction circularDependencyToException(request) {\r\n    request.childRequests.forEach(function (childRequest) {\r\n        if (alreadyDependencyChain(childRequest, childRequest.serviceIdentifier)) {\r\n            var services = dependencyChainToString(childRequest);\r\n            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.CIRCULAR_DEPENDENCY + \" \" + services);\r\n        }\r\n        else {\r\n            circularDependencyToException(childRequest);\r\n        }\r\n    });\r\n}\r\nfunction listMetadataForTarget(serviceIdentifierString, target) {\r\n    if (target.isTagged() || target.isNamed()) {\r\n        var m_1 = '';\r\n        var namedTag = target.getNamedTag();\r\n        var otherTags = target.getCustomTags();\r\n        if (namedTag !== null) {\r\n            m_1 += namedTag.toString() + '\\n';\r\n        }\r\n        if (otherTags !== null) {\r\n            otherTags.forEach(function (tag) {\r\n                m_1 += tag.toString() + '\\n';\r\n            });\r\n        }\r\n        return \" \" + serviceIdentifierString + \"\\n \" + serviceIdentifierString + \" - \" + m_1;\r\n    }\r\n    else {\r\n        return \" \" + serviceIdentifierString;\r\n    }\r\n}\r\nfunction getFunctionName(func) {\r\n    if (func.name) {\r\n        return func.name;\r\n    }\r\n    else {\r\n        var name_1 = func.toString();\r\n        var match = name_1.match(/^function\\s*([^\\s(]+)/);\r\n        return match ? match[1] : \"Anonymous function: \" + name_1;\r\n    }\r\n}\r\nfunction getSymbolDescription(symbol) {\r\n    return symbol.toString().slice(7, -1);\r\n}\r\n\r\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/inversify/es/utils/serialization.js?");

/***/ }),

/***/ "./node_modules/jquery.easing/jquery.easing.js":
/*!*****************************************************!*\
  !*** ./node_modules/jquery.easing/jquery.easing.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * jQuery Easing v1.4.1 - http://gsgd.co.uk/sandbox/jquery/easing/\n * Open source under the BSD License.\n * Copyright © 2008 George McGinley Smith\n * All rights reserved.\n * https://raw.github.com/gdsmith/jquery-easing/master/LICENSE\n*/\n\n(function (factory) {\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($) {\n\t\t\treturn factory($);\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n})(function($){\n\n// Preserve the original jQuery \"swing\" easing as \"jswing\"\n$.easing.jswing = $.easing.swing;\n\nvar pow = Math.pow,\n\tsqrt = Math.sqrt,\n\tsin = Math.sin,\n\tcos = Math.cos,\n\tPI = Math.PI,\n\tc1 = 1.70158,\n\tc2 = c1 * 1.525,\n\tc3 = c1 + 1,\n\tc4 = ( 2 * PI ) / 3,\n\tc5 = ( 2 * PI ) / 4.5;\n\n// x is the fraction of animation progress, in the range 0..1\nfunction bounceOut(x) {\n\tvar n1 = 7.5625,\n\t\td1 = 2.75;\n\tif ( x < 1/d1 ) {\n\t\treturn n1*x*x;\n\t} else if ( x < 2/d1 ) {\n\t\treturn n1*(x-=(1.5/d1))*x + 0.75;\n\t} else if ( x < 2.5/d1 ) {\n\t\treturn n1*(x-=(2.25/d1))*x + 0.9375;\n\t} else {\n\t\treturn n1*(x-=(2.625/d1))*x + 0.984375;\n\t}\n}\n\n$.extend( $.easing,\n{\n\tdef: 'easeOutQuad',\n\tswing: function (x) {\n\t\treturn $.easing[$.easing.def](x);\n\t},\n\teaseInQuad: function (x) {\n\t\treturn x * x;\n\t},\n\teaseOutQuad: function (x) {\n\t\treturn 1 - ( 1 - x ) * ( 1 - x );\n\t},\n\teaseInOutQuad: function (x) {\n\t\treturn x < 0.5 ?\n\t\t\t2 * x * x :\n\t\t\t1 - pow( -2 * x + 2, 2 ) / 2;\n\t},\n\teaseInCubic: function (x) {\n\t\treturn x * x * x;\n\t},\n\teaseOutCubic: function (x) {\n\t\treturn 1 - pow( 1 - x, 3 );\n\t},\n\teaseInOutCubic: function (x) {\n\t\treturn x < 0.5 ?\n\t\t\t4 * x * x * x :\n\t\t\t1 - pow( -2 * x + 2, 3 ) / 2;\n\t},\n\teaseInQuart: function (x) {\n\t\treturn x * x * x * x;\n\t},\n\teaseOutQuart: function (x) {\n\t\treturn 1 - pow( 1 - x, 4 );\n\t},\n\teaseInOutQuart: function (x) {\n\t\treturn x < 0.5 ?\n\t\t\t8 * x * x * x * x :\n\t\t\t1 - pow( -2 * x + 2, 4 ) / 2;\n\t},\n\teaseInQuint: function (x) {\n\t\treturn x * x * x * x * x;\n\t},\n\teaseOutQuint: function (x) {\n\t\treturn 1 - pow( 1 - x, 5 );\n\t},\n\teaseInOutQuint: function (x) {\n\t\treturn x < 0.5 ?\n\t\t\t16 * x * x * x * x * x :\n\t\t\t1 - pow( -2 * x + 2, 5 ) / 2;\n\t},\n\teaseInSine: function (x) {\n\t\treturn 1 - cos( x * PI/2 );\n\t},\n\teaseOutSine: function (x) {\n\t\treturn sin( x * PI/2 );\n\t},\n\teaseInOutSine: function (x) {\n\t\treturn -( cos( PI * x ) - 1 ) / 2;\n\t},\n\teaseInExpo: function (x) {\n\t\treturn x === 0 ? 0 : pow( 2, 10 * x - 10 );\n\t},\n\teaseOutExpo: function (x) {\n\t\treturn x === 1 ? 1 : 1 - pow( 2, -10 * x );\n\t},\n\teaseInOutExpo: function (x) {\n\t\treturn x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ?\n\t\t\tpow( 2, 20 * x - 10 ) / 2 :\n\t\t\t( 2 - pow( 2, -20 * x + 10 ) ) / 2;\n\t},\n\teaseInCirc: function (x) {\n\t\treturn 1 - sqrt( 1 - pow( x, 2 ) );\n\t},\n\teaseOutCirc: function (x) {\n\t\treturn sqrt( 1 - pow( x - 1, 2 ) );\n\t},\n\teaseInOutCirc: function (x) {\n\t\treturn x < 0.5 ?\n\t\t\t( 1 - sqrt( 1 - pow( 2 * x, 2 ) ) ) / 2 :\n\t\t\t( sqrt( 1 - pow( -2 * x + 2, 2 ) ) + 1 ) / 2;\n\t},\n\teaseInElastic: function (x) {\n\t\treturn x === 0 ? 0 : x === 1 ? 1 :\n\t\t\t-pow( 2, 10 * x - 10 ) * sin( ( x * 10 - 10.75 ) * c4 );\n\t},\n\teaseOutElastic: function (x) {\n\t\treturn x === 0 ? 0 : x === 1 ? 1 :\n\t\t\tpow( 2, -10 * x ) * sin( ( x * 10 - 0.75 ) * c4 ) + 1;\n\t},\n\teaseInOutElastic: function (x) {\n\t\treturn x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ?\n\t\t\t-( pow( 2, 20 * x - 10 ) * sin( ( 20 * x - 11.125 ) * c5 )) / 2 :\n\t\t\tpow( 2, -20 * x + 10 ) * sin( ( 20 * x - 11.125 ) * c5 ) / 2 + 1;\n\t},\n\teaseInBack: function (x) {\n\t\treturn c3 * x * x * x - c1 * x * x;\n\t},\n\teaseOutBack: function (x) {\n\t\treturn 1 + c3 * pow( x - 1, 3 ) + c1 * pow( x - 1, 2 );\n\t},\n\teaseInOutBack: function (x) {\n\t\treturn x < 0.5 ?\n\t\t\t( pow( 2 * x, 2 ) * ( ( c2 + 1 ) * 2 * x - c2 ) ) / 2 :\n\t\t\t( pow( 2 * x - 2, 2 ) *( ( c2 + 1 ) * ( x * 2 - 2 ) + c2 ) + 2 ) / 2;\n\t},\n\teaseInBounce: function (x) {\n\t\treturn 1 - bounceOut( 1 - x );\n\t},\n\teaseOutBounce: bounceOut,\n\teaseInOutBounce: function (x) {\n\t\treturn x < 0.5 ?\n\t\t\t( 1 - bounceOut( 1 - 2 * x ) ) / 2 :\n\t\t\t( 1 + bounceOut( 2 * x - 1 ) ) / 2;\n\t}\n});\n\n});\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/jquery.easing/jquery.easing.js?");

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v3.7.1\n * https://jquery.com/\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2023-08-28T13:37Z\n */\n( function( global, factory ) {\n\n\t\"use strict\";\n\n\tif (  true && typeof module.exports === \"object\" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket trac-14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n\"use strict\";\n\nvar arr = [];\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar flat = arr.flat ? function( array ) {\n\treturn arr.flat.call( array );\n} : function( array ) {\n\treturn arr.concat.apply( [], array );\n};\n\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\nvar isFunction = function isFunction( obj ) {\n\n\t\t// Support: Chrome <=57, Firefox <=52\n\t\t// In some browsers, typeof returns \"function\" for HTML <object> elements\n\t\t// (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n\t\t// We don't want to classify *any* DOM node as a function.\n\t\t// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5\n\t\t// Plus for old WebKit, typeof returns \"function\" for HTML collections\n\t\t// (e.g., `typeof document.getElementsByTagName(\"div\") === \"function\"`). (gh-4756)\n\t\treturn typeof obj === \"function\" && typeof obj.nodeType !== \"number\" &&\n\t\t\ttypeof obj.item !== \"function\";\n\t};\n\n\nvar isWindow = function isWindow( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t};\n\n\nvar document = window.document;\n\n\n\n\tvar preservedScriptAttributes = {\n\t\ttype: true,\n\t\tsrc: true,\n\t\tnonce: true,\n\t\tnoModule: true\n\t};\n\n\tfunction DOMEval( code, node, doc ) {\n\t\tdoc = doc || document;\n\n\t\tvar i, val,\n\t\t\tscript = doc.createElement( \"script\" );\n\n\t\tscript.text = code;\n\t\tif ( node ) {\n\t\t\tfor ( i in preservedScriptAttributes ) {\n\n\t\t\t\t// Support: Firefox 64+, Edge 18+\n\t\t\t\t// Some browsers don't support the \"nonce\" property on scripts.\n\t\t\t\t// On the other hand, just using `getAttribute` is not enough as\n\t\t\t\t// the `nonce` attribute is reset to an empty string whenever it\n\t\t\t\t// becomes browsing-context connected.\n\t\t\t\t// See https://github.com/whatwg/html/issues/2369\n\t\t\t\t// See https://html.spec.whatwg.org/#nonce-attributes\n\t\t\t\t// The `node.getAttribute` check was added for the sake of\n\t\t\t\t// `jQuery.globalEval` so that it can fake a nonce-containing node\n\t\t\t\t// via an object.\n\t\t\t\tval = node[ i ] || node.getAttribute && node.getAttribute( i );\n\t\t\t\tif ( val ) {\n\t\t\t\t\tscript.setAttribute( i, val );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n\n\nfunction toType( obj ) {\n\tif ( obj == null ) {\n\t\treturn obj + \"\";\n\t}\n\n\t// Support: Android <=2.3 only (functionish RegExp)\n\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\ttypeof obj;\n}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar version = \"3.7.1\",\n\n\trhtmlSuffix = /HTML$/i,\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t};\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teven: function() {\n\t\treturn this.pushStack( jQuery.grep( this, function( _elem, i ) {\n\t\t\treturn ( i + 1 ) % 2;\n\t\t} ) );\n\t},\n\n\todd: function() {\n\t\treturn this.pushStack( jQuery.grep( this, function( _elem, i ) {\n\t\t\treturn i % 2;\n\t\t} ) );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent Object.prototype pollution\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( name === \"__proto__\" || target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n\t\t\t\t\tsrc = target[ name ];\n\n\t\t\t\t\t// Ensure proper type for the source value\n\t\t\t\t\tif ( copyIsArray && !Array.isArray( src ) ) {\n\t\t\t\t\t\tclone = [];\n\t\t\t\t\t} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {\n\t\t\t\t\t\tclone = {};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src;\n\t\t\t\t\t}\n\t\t\t\t\tcopyIsArray = false;\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t// Evaluates a script in a provided context; falls back to the global one\n\t// if not specified.\n\tglobalEval: function( code, options, doc ) {\n\t\tDOMEval( code, { nonce: options && options.nonce }, doc );\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\n\t// Retrieve the text value of an array of DOM nodes\n\ttext: function( elem ) {\n\t\tvar node,\n\t\t\tret = \"\",\n\t\t\ti = 0,\n\t\t\tnodeType = elem.nodeType;\n\n\t\tif ( !nodeType ) {\n\n\t\t\t// If no nodeType, this is expected to be an array\n\t\t\twhile ( ( node = elem[ i++ ] ) ) {\n\n\t\t\t\t// Do not traverse comment nodes\n\t\t\t\tret += jQuery.text( node );\n\t\t\t}\n\t\t}\n\t\tif ( nodeType === 1 || nodeType === 11 ) {\n\t\t\treturn elem.textContent;\n\t\t}\n\t\tif ( nodeType === 9 ) {\n\t\t\treturn elem.documentElement.textContent;\n\t\t}\n\t\tif ( nodeType === 3 || nodeType === 4 ) {\n\t\t\treturn elem.nodeValue;\n\t\t}\n\n\t\t// Do not include comment or processing instruction nodes\n\n\t\treturn ret;\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\tisXMLDoc: function( elem ) {\n\t\tvar namespace = elem && elem.namespaceURI,\n\t\t\tdocElem = elem && ( elem.ownerDocument || elem ).documentElement;\n\n\t\t// Assume HTML when documentElement doesn't yet exist, such as inside\n\t\t// document fragments.\n\t\treturn !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || \"HTML\" );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn flat( ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\n\tfunction( _i, name ) {\n\t\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n\t} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = toType( obj );\n\n\tif ( isFunction( obj ) || isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\n\n\nfunction nodeName( elem, name ) {\n\n\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\n}\nvar pop = arr.pop;\n\n\nvar sort = arr.sort;\n\n\nvar splice = arr.splice;\n\n\nvar whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\";\n\n\nvar rtrimCSS = new RegExp(\n\t\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\",\n\t\"g\"\n);\n\n\n\n\n// Note: an element does not contain itself\njQuery.contains = function( a, b ) {\n\tvar bup = b && b.parentNode;\n\n\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\n\t\t// Support: IE 9 - 11+\n\t\t// IE doesn't have `contains` on SVG.\n\t\ta.contains ?\n\t\t\ta.contains( bup ) :\n\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t) );\n};\n\n\n\n\n// CSS string/identifier serialization\n// https://drafts.csswg.org/cssom/#common-serializing-idioms\nvar rcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\x80-\\uFFFF\\w-]/g;\n\nfunction fcssescape( ch, asCodePoint ) {\n\tif ( asCodePoint ) {\n\n\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\tif ( ch === \"\\0\" ) {\n\t\t\treturn \"\\uFFFD\";\n\t\t}\n\n\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t}\n\n\t// Other potentially-special ASCII characters get backslash-escaped\n\treturn \"\\\\\" + ch;\n}\n\njQuery.escapeSelector = function( sel ) {\n\treturn ( sel + \"\" ).replace( rcssescape, fcssescape );\n};\n\n\n\n\nvar preferredDoc = document,\n\tpushNative = push;\n\n( function() {\n\nvar i,\n\tExpr,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\tpush = pushNative,\n\n\t// Local document vars\n\tdocument,\n\tdocumentElement,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\tmatches,\n\n\t// Instance-specific data\n\texpando = jQuery.expando,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tnonnativeSelectorCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|\" +\n\t\t\"loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram\n\tidentifier = \"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace +\n\t\t\"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",\n\n\t// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" +\n\t\twhitespace + \"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trleadingCombinator = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" +\n\t\twhitespace + \"*\" ),\n\trdescend = new RegExp( whitespace + \"|>\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\tID: new RegExp( \"^#(\" + identifier + \")\" ),\n\t\tCLASS: new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\tTAG: new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\tATTR: new RegExp( \"^\" + attributes ),\n\t\tPSEUDO: new RegExp( \"^\" + pseudos ),\n\t\tCHILD: new RegExp(\n\t\t\t\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" +\n\t\t\t\twhitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" +\n\t\t\t\twhitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\tbool: new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\tneedsContext: new RegExp( \"^\" + whitespace +\n\t\t\t\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace +\n\t\t\t\"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace +\n\t\t\"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\", \"g\" ),\n\tfunescape = function( escape, nonHex ) {\n\t\tvar high = \"0x\" + escape.slice( 1 ) - 0x10000;\n\n\t\tif ( nonHex ) {\n\n\t\t\t// Strip the backslash prefix from a non-hex escape sequence\n\t\t\treturn nonHex;\n\t\t}\n\n\t\t// Replace a hexadecimal escape sequence with the encoded Unicode code point\n\t\t// Support: IE <=11+\n\t\t// For values outside the Basic Multilingual Plane (BMP), manually construct a\n\t\t// surrogate pair\n\t\treturn high < 0 ?\n\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// Used for iframes; see `setDocument`.\n\t// Support: IE 9 - 11+, Edge 12 - 18+\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE/Edge.\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tinDisabledFieldset = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && nodeName( elem, \"fieldset\" );\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Support: IE <=9 only\n// Accessing document.activeElement can throw unexpectedly\n// https://bugs.jquery.com/ticket/13393\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t( arr = slice.call( preferredDoc.childNodes ) ),\n\t\tpreferredDoc.childNodes\n\t);\n\n\t// Support: Android <=4.0\n\t// Detect silently failing push.apply\n\t// eslint-disable-next-line no-unused-expressions\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = {\n\t\tapply: function( target, els ) {\n\t\t\tpushNative.apply( target, slice.call( els ) );\n\t\t},\n\t\tcall: function( target ) {\n\t\t\tpushNative.apply( target, slice.call( arguments, 1 ) );\n\t\t}\n\t};\n}\n\nfunction find( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\t\tsetDocument( context );\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( ( m = match[ 1 ] ) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( ( elem = context.getElementById( m ) ) ) {\n\n\t\t\t\t\t\t\t// Support: IE 9 only\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tpush.call( results, elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE 9 only\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && ( elem = newContext.getElementById( m ) ) &&\n\t\t\t\t\t\t\tfind.contains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tpush.call( results, elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[ 2 ] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( !nonnativeSelectorCache[ selector + \" \" ] &&\n\t\t\t\t( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {\n\n\t\t\t\tnewSelector = selector;\n\t\t\t\tnewContext = context;\n\n\t\t\t\t// qSA considers elements outside a scoping root when evaluating child or\n\t\t\t\t// descendant combinators, which is not what we want.\n\t\t\t\t// In such cases, we work around the behavior by prefixing every selector in the\n\t\t\t\t// list with an ID selector referencing the scope context.\n\t\t\t\t// The technique has to be used as well when a leading combinator is used\n\t\t\t\t// as such selectors are not recognized by querySelectorAll.\n\t\t\t\t// Thanks to Andrew Dupont for this technique.\n\t\t\t\tif ( nodeType === 1 &&\n\t\t\t\t\t( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\n\t\t\t\t\t// We can use :scope instead of the ID hack if the browser\n\t\t\t\t\t// supports it & if we're not changing the context.\n\t\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when\n\t\t\t\t\t// strict-comparing two documents; shallow comparisons work.\n\t\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\t\tif ( newContext != context || !support.scope ) {\n\n\t\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\t\tif ( ( nid = context.getAttribute( \"id\" ) ) ) {\n\t\t\t\t\t\t\tnid = jQuery.escapeSelector( nid );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontext.setAttribute( \"id\", ( nid = expando ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[ i ] = ( nid ? \"#\" + nid : \":scope\" ) + \" \" +\n\t\t\t\t\t\t\ttoSelector( groups[ i ] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\tnonnativeSelectorCache( selector, true );\n\t\t\t\t} finally {\n\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrimCSS, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\n\t\t// Use (key + \" \") to avoid collision with native prototype properties\n\t\t// (see https://github.com/jquery/sizzle/issues/157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn ( cache[ key + \" \" ] = value );\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by jQuery selector module\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement( \"fieldset\" );\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch ( e ) {\n\t\treturn false;\n\t} finally {\n\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\treturn nodeName( elem, \"input\" ) && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\treturn ( nodeName( elem, \"input\" ) || nodeName( elem, \"button\" ) ) &&\n\t\t\telem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11+\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tinDisabledFieldset( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction( function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction( function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ ( j = matchIndexes[ i ] ) ] ) {\n\t\t\t\t\tseed[ j ] = !( matches[ j ] = seed[ j ] );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t} );\n}\n\n/**\n * Checks a node for validity as a jQuery selector context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [node] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nfunction setDocument( node ) {\n\tvar subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocumentElement = document.documentElement;\n\tdocumentIsHTML = !jQuery.isXMLDoc( document );\n\n\t// Support: iOS 7 only, IE 9 - 11+\n\t// Older browsers didn't support unprefixed `matches`.\n\tmatches = documentElement.matches ||\n\t\tdocumentElement.webkitMatchesSelector ||\n\t\tdocumentElement.msMatchesSelector;\n\n\t// Support: IE 9 - 11+, Edge 12 - 18+\n\t// Accessing iframe documents after unload throws \"permission denied\" errors\n\t// (see trac-13936).\n\t// Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,\n\t// all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.\n\tif ( documentElement.msMatchesSelector &&\n\n\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t// two documents; shallow comparisons work.\n\t\t// eslint-disable-next-line eqeqeq\n\t\tpreferredDoc != document &&\n\t\t( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 9 - 11+, Edge 12 - 18+\n\t\tsubWindow.addEventListener( \"unload\", unloadHandler );\n\t}\n\n\t// Support: IE <10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert( function( el ) {\n\t\tdocumentElement.appendChild( el ).id = jQuery.expando;\n\t\treturn !document.getElementsByName ||\n\t\t\t!document.getElementsByName( jQuery.expando ).length;\n\t} );\n\n\t// Support: IE 9 only\n\t// Check to see if it's possible to do matchesSelector\n\t// on a disconnected node.\n\tsupport.disconnectedMatch = assert( function( el ) {\n\t\treturn matches.call( el, \"*\" );\n\t} );\n\n\t// Support: IE 9 - 11+, Edge 12 - 18+\n\t// IE/Edge don't support the :scope pseudo-class.\n\tsupport.scope = assert( function() {\n\t\treturn document.querySelectorAll( \":scope\" );\n\t} );\n\n\t// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only\n\t// Make sure the `:has()` argument is parsed unforgivingly.\n\t// We include `*` in the test to detect buggy implementations that are\n\t// _selectively_ forgiving (specifically when the list includes at least\n\t// one valid selector).\n\t// Note that we treat complete lack of support for `:has()` as if it were\n\t// spec-compliant support, which is fine because use of `:has()` in such\n\t// environments will fail in the qSA path and fall back to jQuery traversal\n\t// anyway.\n\tsupport.cssHas = assert( function() {\n\t\ttry {\n\t\t\tdocument.querySelector( \":has(*,:jqfake)\" );\n\t\t\treturn false;\n\t\t} catch ( e ) {\n\t\t\treturn true;\n\t\t}\n\t} );\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter.ID = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute( \"id\" ) === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find.ID = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter.ID =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode( \"id\" );\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find.ID = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode( \"id\" );\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( ( elem = elems[ i++ ] ) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode( \"id\" );\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find.TAG = function( tag, context ) {\n\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t// DocumentFragment nodes don't have gEBTN\n\t\t} else {\n\t\t\treturn context.querySelectorAll( tag );\n\t\t}\n\t};\n\n\t// Class\n\tExpr.find.CLASS = function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\trbuggyQSA = [];\n\n\t// Build QSA regex\n\t// Regex strategy adopted from Diego Perini\n\tassert( function( el ) {\n\n\t\tvar input;\n\n\t\tdocumentElement.appendChild( el ).innerHTML =\n\t\t\t\"<a id='\" + expando + \"' href='' disabled='disabled'></a>\" +\n\t\t\t\"<select id='\" + expando + \"-\\r\\\\' disabled='disabled'>\" +\n\t\t\t\"<option selected=''></option></select>\";\n\n\t\t// Support: iOS <=7 - 8 only\n\t\t// Boolean attributes and \"value\" are not treated correctly in some XML documents\n\t\tif ( !el.querySelectorAll( \"[selected]\" ).length ) {\n\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t}\n\n\t\t// Support: iOS <=7 - 8 only\n\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\trbuggyQSA.push( \"~=\" );\n\t\t}\n\n\t\t// Support: iOS 8 only\n\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\trbuggyQSA.push( \".#.+[+~]\" );\n\t\t}\n\n\t\t// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+\n\t\t// In some of the document kinds, these selectors wouldn't work natively.\n\t\t// This is probably OK but for backwards compatibility we want to maintain\n\t\t// handling them through jQuery traversal in jQuery 3.x.\n\t\tif ( !el.querySelectorAll( \":checked\" ).length ) {\n\t\t\trbuggyQSA.push( \":checked\" );\n\t\t}\n\n\t\t// Support: Windows 8 Native Apps\n\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\tinput = document.createElement( \"input\" );\n\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t// Support: IE 9 - 11+\n\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+\n\t\t// In some of the document kinds, these selectors wouldn't work natively.\n\t\t// This is probably OK but for backwards compatibility we want to maintain\n\t\t// handling them through jQuery traversal in jQuery 3.x.\n\t\tdocumentElement.appendChild( el ).disabled = true;\n\t\tif ( el.querySelectorAll( \":disabled\" ).length !== 2 ) {\n\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t}\n\n\t\t// Support: IE 11+, Edge 15 - 18+\n\t\t// IE 11/Edge don't find elements on a `[name='']` query in some cases.\n\t\t// Adding a temporary attribute to the document before the selection works\n\t\t// around the issue.\n\t\t// Interestingly, IE 10 & older don't seem to have the issue.\n\t\tinput = document.createElement( \"input\" );\n\t\tinput.setAttribute( \"name\", \"\" );\n\t\tel.appendChild( input );\n\t\tif ( !el.querySelectorAll( \"[name='']\" ).length ) {\n\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*name\" + whitespace + \"*=\" +\n\t\t\t\twhitespace + \"*(?:''|\\\"\\\")\" );\n\t\t}\n\t} );\n\n\tif ( !support.cssHas ) {\n\n\t\t// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+\n\t\t// Our regular `try-catch` mechanism fails to detect natively-unsupported\n\t\t// pseudo-classes inside `:has()` (such as `:has(:contains(\"Foo\"))`)\n\t\t// in browsers that parse the `:has()` argument as a forgiving selector list.\n\t\t// https://drafts.csswg.org/selectors/#relational now requires the argument\n\t\t// to be parsed unforgivingly, but browsers have not yet fully adjusted.\n\t\trbuggyQSA.push( \":has\" );\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( \"|\" ) );\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = function( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t// two documents; shallow comparisons work.\n\t\t// eslint-disable-next-line eqeqeq\n\t\tcompare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\tif ( a === document || a.ownerDocument == preferredDoc &&\n\t\t\t\tfind.contains( preferredDoc, a ) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\tif ( b === document || b.ownerDocument == preferredDoc &&\n\t\t\t\tfind.contains( preferredDoc, b ) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t};\n\n\treturn document;\n}\n\nfind.matches = function( expr, elements ) {\n\treturn find( expr, null, null, elements );\n};\n\nfind.matchesSelector = function( elem, expr ) {\n\tsetDocument( elem );\n\n\tif ( documentIsHTML &&\n\t\t!nonnativeSelectorCache[ expr + \" \" ] &&\n\t\t( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch ( e ) {\n\t\t\tnonnativeSelectorCache( expr, true );\n\t\t}\n\t}\n\n\treturn find( expr, document, null, [ elem ] ).length > 0;\n};\n\nfind.contains = function( context, elem ) {\n\n\t// Set document vars if needed\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( ( context.ownerDocument || context ) != document ) {\n\t\tsetDocument( context );\n\t}\n\treturn jQuery.contains( context, elem );\n};\n\n\nfind.attr = function( elem, name ) {\n\n\t// Set document vars if needed\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( ( elem.ownerDocument || elem ) != document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\n\t\t// Don't get fooled by Object.prototype properties (see trac-13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\tif ( val !== undefined ) {\n\t\treturn val;\n\t}\n\n\treturn elem.getAttribute( name );\n};\n\nfind.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\njQuery.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\t//\n\t// Support: Android <=4.0+\n\t// Testing for detecting duplicates is unpredictable so instead assume we can't\n\t// depend on duplicate detection in all browsers without a stable sort.\n\thasDuplicate = !support.sortStable;\n\tsortInput = !support.sortStable && slice.call( results, 0 );\n\tsort.call( results, sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( ( elem = results[ i++ ] ) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tsplice.call( results, duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\njQuery.fn.uniqueSort = function() {\n\treturn this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );\n};\n\nExpr = jQuery.expr = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\tATTR: function( match ) {\n\t\t\tmatch[ 1 ] = match[ 1 ].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || \"\" )\n\t\t\t\t.replace( runescape, funescape );\n\n\t\t\tif ( match[ 2 ] === \"~=\" ) {\n\t\t\t\tmatch[ 3 ] = \" \" + match[ 3 ] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\tCHILD: function( match ) {\n\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[ 1 ] = match[ 1 ].toLowerCase();\n\n\t\t\tif ( match[ 1 ].slice( 0, 3 ) === \"nth\" ) {\n\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[ 3 ] ) {\n\t\t\t\t\tfind.error( match[ 0 ] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[ 4 ] = +( match[ 4 ] ?\n\t\t\t\t\tmatch[ 5 ] + ( match[ 6 ] || 1 ) :\n\t\t\t\t\t2 * ( match[ 3 ] === \"even\" || match[ 3 ] === \"odd\" )\n\t\t\t\t);\n\t\t\t\tmatch[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[ 3 ] ) {\n\t\t\t\tfind.error( match[ 0 ] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\tPSEUDO: function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[ 6 ] && match[ 2 ];\n\n\t\t\tif ( matchExpr.CHILD.test( match[ 0 ] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[ 3 ] ) {\n\t\t\t\tmatch[ 2 ] = match[ 4 ] || match[ 5 ] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t( excess = tokenize( unquoted, true ) ) &&\n\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t( excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length ) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[ 0 ] = match[ 0 ].slice( 0, excess );\n\t\t\t\tmatch[ 2 ] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\tTAG: function( nodeNameSelector ) {\n\t\t\tvar expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() {\n\t\t\t\t\treturn true;\n\t\t\t\t} :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn nodeName( elem, expectedNodeName );\n\t\t\t\t};\n\t\t},\n\n\t\tCLASS: function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t( pattern = new RegExp( \"(^|\" + whitespace + \")\" + className +\n\t\t\t\t\t\"(\" + whitespace + \"|$)\" ) ) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test(\n\t\t\t\t\t\ttypeof elem.className === \"string\" && elem.className ||\n\t\t\t\t\t\t\ttypeof elem.getAttribute !== \"undefined\" &&\n\t\t\t\t\t\t\t\telem.getAttribute( \"class\" ) ||\n\t\t\t\t\t\t\t\"\"\n\t\t\t\t\t);\n\t\t\t\t} );\n\t\t},\n\n\t\tATTR: function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = find.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\tif ( operator === \"=\" ) {\n\t\t\t\t\treturn result === check;\n\t\t\t\t}\n\t\t\t\tif ( operator === \"!=\" ) {\n\t\t\t\t\treturn result !== check;\n\t\t\t\t}\n\t\t\t\tif ( operator === \"^=\" ) {\n\t\t\t\t\treturn check && result.indexOf( check ) === 0;\n\t\t\t\t}\n\t\t\t\tif ( operator === \"*=\" ) {\n\t\t\t\t\treturn check && result.indexOf( check ) > -1;\n\t\t\t\t}\n\t\t\t\tif ( operator === \"$=\" ) {\n\t\t\t\t\treturn check && result.slice( -check.length ) === check;\n\t\t\t\t}\n\t\t\t\tif ( operator === \"~=\" ) {\n\t\t\t\t\treturn ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" )\n\t\t\t\t\t\t.indexOf( check ) > -1;\n\t\t\t\t}\n\t\t\t\tif ( operator === \"|=\" ) {\n\t\t\t\t\treturn result === check || result.slice( 0, check.length + 1 ) === check + \"-\";\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t};\n\t\t},\n\n\t\tCHILD: function( type, what, _argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, _context, xml ) {\n\t\t\t\t\tvar cache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( ( node = node[ dir ] ) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnodeName( node, name ) :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\touterCache = parent[ expando ] || ( parent[ expando ] = {} );\n\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\touterCache = elem[ expando ] || ( elem[ expando ] = {} );\n\t\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnodeName( node, name ) :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t( node[ expando ] = {} );\n\t\t\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\tPSEUDO: function( pseudo, argument ) {\n\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// https://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tfind.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as jQuery does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction( function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf.call( seed, matched[ i ] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[ i ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t} ) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\n\t\t// Potentially complex pseudos\n\t\tnot: markFunction( function( selector ) {\n\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrimCSS, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction( function( seed, matches, _context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( ( elem = unmatched[ i ] ) ) {\n\t\t\t\t\t\t\tseed[ i ] = !( matches[ i ] = elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} ) :\n\t\t\t\tfunction( elem, _context, xml ) {\n\t\t\t\t\tinput[ 0 ] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\n\t\t\t\t\t// Don't keep the element\n\t\t\t\t\t// (see https://github.com/jquery/sizzle/issues/299)\n\t\t\t\t\tinput[ 0 ] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t} ),\n\n\t\thas: markFunction( function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn find( selector, elem ).length > 0;\n\t\t\t};\n\t\t} ),\n\n\t\tcontains: markFunction( function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t} ),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// https://www.w3.org/TR/selectors/#lang-pseudo\n\t\tlang: markFunction( function( lang ) {\n\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test( lang || \"\" ) ) {\n\t\t\t\tfind.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( ( elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute( \"xml:lang\" ) || elem.getAttribute( \"lang\" ) ) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t} ),\n\n\t\t// Miscellaneous\n\t\ttarget: function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\troot: function( elem ) {\n\t\t\treturn elem === documentElement;\n\t\t},\n\n\t\tfocus: function( elem ) {\n\t\t\treturn elem === safeActiveElement() &&\n\t\t\t\tdocument.hasFocus() &&\n\t\t\t\t!!( elem.type || elem.href || ~elem.tabIndex );\n\t\t},\n\n\t\t// Boolean properties\n\t\tenabled: createDisabledPseudo( false ),\n\t\tdisabled: createDisabledPseudo( true ),\n\n\t\tchecked: function( elem ) {\n\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\treturn ( nodeName( elem, \"input\" ) && !!elem.checked ) ||\n\t\t\t\t( nodeName( elem, \"option\" ) && !!elem.selected );\n\t\t},\n\n\t\tselected: function( elem ) {\n\n\t\t\t// Support: IE <=11+\n\t\t\t// Accessing the selectedIndex property\n\t\t\t// forces the browser to treat the default option as\n\t\t\t// selected when in an optgroup.\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\t// eslint-disable-next-line no-unused-expressions\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\tempty: function( elem ) {\n\n\t\t\t// https://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\tparent: function( elem ) {\n\t\t\treturn !Expr.pseudos.empty( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\theader: function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\tinput: function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\tbutton: function( elem ) {\n\t\t\treturn nodeName( elem, \"input\" ) && elem.type === \"button\" ||\n\t\t\t\tnodeName( elem, \"button\" );\n\t\t},\n\n\t\ttext: function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn nodeName( elem, \"input\" ) && elem.type === \"text\" &&\n\n\t\t\t\t// Support: IE <10 only\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear\n\t\t\t\t// with elem.type === \"text\"\n\t\t\t\t( ( attr = elem.getAttribute( \"type\" ) ) == null ||\n\t\t\t\t\tattr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\tfirst: createPositionalPseudo( function() {\n\t\t\treturn [ 0 ];\n\t\t} ),\n\n\t\tlast: createPositionalPseudo( function( _matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t} ),\n\n\t\teq: createPositionalPseudo( function( _matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t} ),\n\n\t\teven: createPositionalPseudo( function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} ),\n\n\t\todd: createPositionalPseudo( function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} ),\n\n\t\tlt: createPositionalPseudo( function( matchIndexes, length, argument ) {\n\t\t\tvar i;\n\n\t\t\tif ( argument < 0 ) {\n\t\t\t\ti = argument + length;\n\t\t\t} else if ( argument > length ) {\n\t\t\t\ti = length;\n\t\t\t} else {\n\t\t\t\ti = argument;\n\t\t\t}\n\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} ),\n\n\t\tgt: createPositionalPseudo( function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} )\n\t}\n};\n\nExpr.pseudos.nth = Expr.pseudos.eq;\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\nfunction tokenize( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || ( match = rcomma.exec( soFar ) ) ) {\n\t\t\tif ( match ) {\n\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[ 0 ].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( ( tokens = [] ) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( ( match = rleadingCombinator.exec( soFar ) ) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push( {\n\t\t\t\tvalue: matched,\n\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[ 0 ].replace( rtrimCSS, \" \" )\n\t\t\t} );\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||\n\t\t\t\t( match = preFilters[ type ]( match ) ) ) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push( {\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t} );\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\tif ( parseOnly ) {\n\t\treturn soFar.length;\n\t}\n\n\treturn soFar ?\n\t\tfind.error( selector ) :\n\n\t\t// Cache the tokens\n\t\ttokenCache( selector, groups ).slice( 0 );\n}\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[ i ].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || ( elem[ expando ] = {} );\n\n\t\t\t\t\t\tif ( skip && nodeName( elem, skip ) ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( ( oldCache = outerCache[ key ] ) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn ( newCache[ 2 ] = oldCache[ 2 ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\touterCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[ i ]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[ 0 ];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tfind( selector, contexts[ i ], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( ( elem = unmatched[ i ] ) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction( function( seed, results, context, xml ) {\n\t\tvar temp, i, elem, matcherOut,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed ||\n\t\t\t\tmultipleContexts( selector || \"*\",\n\t\t\t\t\tcontext.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems;\n\n\t\tif ( matcher ) {\n\n\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter\n\t\t\t// or preexisting results,\n\t\t\tmatcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t[] :\n\n\t\t\t\t// ...otherwise use results directly\n\t\t\t\tresults;\n\n\t\t\t// Find primary matches\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t} else {\n\t\t\tmatcherOut = matcherIn;\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( ( elem = temp[ i ] ) ) {\n\t\t\t\t\tmatcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) ) {\n\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( ( matcherIn[ i ] = elem ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, ( matcherOut = [] ), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) &&\n\t\t\t\t\t\t( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {\n\n\t\t\t\t\t\tseed[ temp ] = !( results[ temp ] = elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t} );\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[ 0 ].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[ \" \" ],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf.call( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\tvar ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (\n\t\t\t\t( checkContext = context ).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\n\t\t\t// Avoid hanging onto element\n\t\t\t// (see https://github.com/jquery/sizzle/issues/299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {\n\t\t\tmatchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[ j ].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 )\n\t\t\t\t\t\t\t.concat( { value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" } )\n\t\t\t\t\t).replace( rtrimCSS, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find.TAG( \"*\", outermost ),\n\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\n\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\toutermostContext = context == document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: iOS <=7 - 9 only\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching\n\t\t\t// elements by id. (see trac-14142)\n\t\t\tfor ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\n\t\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\t\tif ( !context && elem.ownerDocument != document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( ( matcher = elementMatchers[ j++ ] ) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml ) ) {\n\t\t\t\t\t\t\tpush.call( results, elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( ( elem = !matcher && elem ) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( ( matcher = setMatchers[ j++ ] ) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !( unmatched[ i ] || setMatched[ i ] ) ) {\n\t\t\t\t\t\t\t\tsetMatched[ i ] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tjQuery.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\nfunction compile( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[ i ] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector,\n\t\t\tmatcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n}\n\n/**\n * A low-level selection function that works with jQuery's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with jQuery selector compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nfunction select( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( ( selector = compiled.selector || selector ) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[ 0 ] = match[ 0 ].slice( 0 );\n\t\tif ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === \"ID\" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {\n\n\t\t\tcontext = ( Expr.find.ID(\n\t\t\t\ttoken.matches[ 0 ].replace( runescape, funescape ),\n\t\t\t\tcontext\n\t\t\t) || [] )[ 0 ];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[ i ];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ ( type = token.type ) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( ( find = Expr.find[ type ] ) ) {\n\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( ( seed = find(\n\t\t\t\t\ttoken.matches[ 0 ].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[ 0 ].type ) &&\n\t\t\t\t\t\ttestContext( context.parentNode ) || context\n\t\t\t\t) ) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n}\n\n// One-time assignments\n\n// Support: Android <=4.0 - 4.1+\n// Sort stability\nsupport.sortStable = expando.split( \"\" ).sort( sortOrder ).join( \"\" ) === expando;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Android <=4.0 - 4.1+\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert( function( el ) {\n\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement( \"fieldset\" ) ) & 1;\n} );\n\njQuery.find = find;\n\n// Deprecated\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.unique = jQuery.uniqueSort;\n\n// These have always been private, but they used to be documented as part of\n// Sizzle so let's maintain them for now for backwards compatibility purposes.\nfind.compile = compile;\nfind.select = select;\nfind.setDocument = setDocument;\nfind.tokenize = tokenize;\n\nfind.escape = jQuery.escapeSelector;\nfind.getText = jQuery.text;\nfind.isXML = jQuery.isXMLDoc;\nfind.selectors = jQuery.expr;\nfind.support = jQuery.support;\nfind.uniqueSort = jQuery.uniqueSort;\n\n\t/* eslint-enable */\n\n} )();\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== \"string\" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Filtered directly for both simple and complex selectors\n\treturn jQuery.filter( qualifier, elements, not );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)\n\t// Strict HTML recognition (trac-11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there's no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to jQuery#find\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, _i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, _i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, _i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\tif ( elem.contentDocument != null &&\n\n\t\t\t// Support: IE 11+\n\t\t\t// <object> elements with no `data` attribute has an object\n\t\t\t// `contentDocument` with a `null` prototype.\n\t\t\tgetProto( elem.contentDocument ) ) {\n\n\t\t\treturn elem.contentDocument;\n\t\t}\n\n\t\t// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n\t\t// Treat the template element as a regular one in browsers that\n\t\t// don't support it.\n\t\tif ( nodeName( elem, \"template\" ) ) {\n\t\t\telem = elem.content || elem;\n\t\t}\n\n\t\treturn jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && toType( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject, noValue ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.apply( undefined, [ value ] );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( _i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.error );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the error, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getErrorHook ) {\n\t\t\t\t\t\t\t\t\tprocess.error = jQuery.Deferred.getErrorHook();\n\n\t\t\t\t\t\t\t\t// The deprecated alias of the above. While the name suggests\n\t\t\t\t\t\t\t\t// returning the stack, not an error instance, jQuery just passes\n\t\t\t\t\t\t\t\t// it directly to `console.warn` so both will work; an instance\n\t\t\t\t\t\t\t\t// just better cooperates with source maps.\n\t\t\t\t\t\t\t\t} else if ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.error = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// rejected_handlers.disable\n\t\t\t\t\t// fulfilled_handlers.disable\n\t\t\t\t\ttuples[ 3 - i ][ 3 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock,\n\n\t\t\t\t\t// progress_handlers.lock\n\t\t\t\t\ttuples[ 0 ][ 3 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the primary Deferred\n\t\t\tprimary = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tprimary.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,\n\t\t\t\t!remaining );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( primary.state() === \"pending\" ||\n\t\t\t\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn primary.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );\n\t\t}\n\n\t\treturn primary.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\n// If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error\n// captured before the async barrier to get the original error cause\n// which may otherwise be hidden.\njQuery.Deferred.exceptionHook = function( error, asyncError ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message,\n\t\t\terror.stack, asyncError );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See trac-6781\n\treadyWait: 1,\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\twindow.removeEventListener( \"load\", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals \"interactive\" too soon\nif ( document.readyState === \"complete\" ||\n\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( \"load\", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( toType( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, _key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\t\tvalue :\n\t\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\n\n\n// Matches dashed string for camelizing\nvar rmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g;\n\n// Used by camelCase as callback to replace()\nfunction fcamelCase( _all, letter ) {\n\treturn letter.toUpperCase();\n}\n\n// Convert dashed to camelCase; used by the css and data modules\n// Support: IE <=9 - 11, Edge 12 - 15\n// Microsoft forgot to hump their vendor prefix (trac-9572)\nfunction camelCase( string ) {\n\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n}\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see trac-8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( Array.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( camelCase );\n\t\t\t} else {\n\t\t\t\tkey = camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === \"true\" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === \"false\" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === \"null\" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn't change the string\n\tif ( data === +data + \"\" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (trac-14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar documentElement = document.documentElement;\n\n\n\n\tvar isAttached = function( elem ) {\n\t\t\treturn jQuery.contains( elem.ownerDocument, elem );\n\t\t},\n\t\tcomposed = { composed: true };\n\n\t// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\n\t// Check attachment across shadow DOM boundaries when possible (gh-3504)\n\t// Support: iOS 10.0-10.2 only\n\t// Early iOS 10 versions support `attachShadow` but not `getRootNode`,\n\t// leading to errors. We need to check for `getRootNode`.\n\tif ( documentElement.getRootNode ) {\n\t\tisAttached = function( elem ) {\n\t\t\treturn jQuery.contains( elem.ownerDocument, elem ) ||\n\t\t\t\telem.getRootNode( composed ) === elem.ownerDocument;\n\t\t};\n\t}\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" ||\n\t\t\telem.style.display === \"\" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tisAttached( elem ) &&\n\n\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t};\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted, scale,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = elem.nodeType &&\n\t\t\t( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Support: Firefox <=54\n\t\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n\t\tinitial = initial / 2;\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\twhile ( maxIterations-- ) {\n\n\t\t\t// Evaluate and update our best guess (doubling guesses that zero out).\n\t\t\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\t\t\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\n\t\t\t\tmaxIterations = 0;\n\t\t\t}\n\t\t\tinitialInUnit = initialInUnit / scale;\n\n\t\t}\n\n\t\tinitialInUnit = initialInUnit * 2;\n\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, \"display\" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === \"none\" ) {\n\t\tdisplay = \"block\";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== \"none\" ) {\n\t\t\t\tvalues[ index ] = \"none\";\n\n\t\t\t\t// Remember what we're overwriting\n\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i );\n\nvar rscriptType = ( /^$|^module$|\\/(?:java|ecma)script/i );\n\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (trac-11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (trac-14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n\n\t// Support: IE <=9 only\n\t// IE <=9 replaces <option> tags with their contents when inserted outside of\n\t// the select element.\n\tdiv.innerHTML = \"<option></option>\";\n\tsupport.option = !!div.lastChild;\n} )();\n\n\n// We have to close these tags to support XHTML (trac-13200)\nvar wrapMap = {\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t_default: [ 0, \"\", \"\" ]\n};\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n// Support: IE <=9 only\nif ( !support.option ) {\n\twrapMap.optgroup = wrapMap.option = [ 1, \"<select multiple='multiple'>\", \"</select>\" ];\n}\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\tret = context.getElementsByTagName( tag || \"*\" );\n\n\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\tret = context.querySelectorAll( tag || \"*\" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t\"globalEval\",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, attached, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( toType( elem ) === \"object\" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (trac-12392)\n\t\t\t\ttmp.textContent = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = \"\";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tattached = isAttached( elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( attached ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\nvar rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Only attach events to objects that accept data\n\t\tif ( !acceptData( elem ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = Object.create( null );\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\n\t\t\t// Make a writable jQuery.Event from the native event object\n\t\t\tevent = jQuery.event.fix( nativeEvent ),\n\n\t\t\thandlers = (\n\t\t\t\tdataPriv.get( this, \"events\" ) || Object.create( null )\n\t\t\t)[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// If the event is namespaced, then each handler is only invoked if it is\n\t\t\t\t// specially universal or its namespaces are a superset of the event's.\n\t\t\t\tif ( !event.rnamespace || handleObj.namespace === false ||\n\t\t\t\t\tevent.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (trac-13208)\n\t\t\t\t// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (trac-13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tclick: {\n\n\t\t\t// Utilize native event to ensure correct state for checkable inputs\n\t\t\tsetup: function( data ) {\n\n\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n\t\t\t\tvar el = this || data;\n\n\t\t\t\t// Claim the first handler\n\t\t\t\tif ( rcheckableType.test( el.type ) &&\n\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n\n\t\t\t\t\t// dataPriv.set( el, \"click\", ... )\n\t\t\t\t\tleverageNative( el, \"click\", true );\n\t\t\t\t}\n\n\t\t\t\t// Return false to allow normal processing in the caller\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\ttrigger: function( data ) {\n\n\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n\t\t\t\tvar el = this || data;\n\n\t\t\t\t// Force setup before triggering a click\n\t\t\t\tif ( rcheckableType.test( el.type ) &&\n\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n\n\t\t\t\t\tleverageNative( el, \"click\" );\n\t\t\t\t}\n\n\t\t\t\t// Return non-false to allow normal event-path propagation\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, suppress native .click() on links\n\t\t\t// Also prevent it if we're currently inside a leveraged native-event stack\n\t\t\t_default: function( event ) {\n\t\t\t\tvar target = event.target;\n\t\t\t\treturn rcheckableType.test( target.type ) &&\n\t\t\t\t\ttarget.click && nodeName( target, \"input\" ) &&\n\t\t\t\t\tdataPriv.get( target, \"click\" ) ||\n\t\t\t\t\tnodeName( target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Ensure the presence of an event listener that handles manually-triggered\n// synthetic events by interrupting progress until reinvoked in response to\n// *native* events that it fires directly, ensuring that state changes have\n// already occurred before other listeners are invoked.\nfunction leverageNative( el, type, isSetup ) {\n\n\t// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add\n\tif ( !isSetup ) {\n\t\tif ( dataPriv.get( el, type ) === undefined ) {\n\t\t\tjQuery.event.add( el, type, returnTrue );\n\t\t}\n\t\treturn;\n\t}\n\n\t// Register the controller as a special universal handler for all event namespaces\n\tdataPriv.set( el, type, false );\n\tjQuery.event.add( el, type, {\n\t\tnamespace: false,\n\t\thandler: function( event ) {\n\t\t\tvar result,\n\t\t\t\tsaved = dataPriv.get( this, type );\n\n\t\t\tif ( ( event.isTrigger & 1 ) && this[ type ] ) {\n\n\t\t\t\t// Interrupt processing of the outer synthetic .trigger()ed event\n\t\t\t\tif ( !saved ) {\n\n\t\t\t\t\t// Store arguments for use when handling the inner native event\n\t\t\t\t\t// There will always be at least one argument (an event object), so this array\n\t\t\t\t\t// will not be confused with a leftover capture object.\n\t\t\t\t\tsaved = slice.call( arguments );\n\t\t\t\t\tdataPriv.set( this, type, saved );\n\n\t\t\t\t\t// Trigger the native event and capture its result\n\t\t\t\t\tthis[ type ]();\n\t\t\t\t\tresult = dataPriv.get( this, type );\n\t\t\t\t\tdataPriv.set( this, type, false );\n\n\t\t\t\t\tif ( saved !== result ) {\n\n\t\t\t\t\t\t// Cancel the outer synthetic event\n\t\t\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\n\t\t\t\t// If this is an inner synthetic event for an event with a bubbling surrogate\n\t\t\t\t// (focus or blur), assume that the surrogate already propagated from triggering\n\t\t\t\t// the native event and prevent that from happening again here.\n\t\t\t\t// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\n\t\t\t\t// bubbling surrogate propagates *after* the non-bubbling base), but that seems\n\t\t\t\t// less bad than duplication.\n\t\t\t\t} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t}\n\n\t\t\t// If this is a native event triggered above, everything is now in order\n\t\t\t// Fire an inner synthetic event with the original arguments\n\t\t\t} else if ( saved ) {\n\n\t\t\t\t// ...and capture the result\n\t\t\t\tdataPriv.set( this, type, jQuery.event.trigger(\n\t\t\t\t\tsaved[ 0 ],\n\t\t\t\t\tsaved.slice( 1 ),\n\t\t\t\t\tthis\n\t\t\t\t) );\n\n\t\t\t\t// Abort handling of the native event by all jQuery handlers while allowing\n\t\t\t\t// native handlers on the same element to run. On target, this is achieved\n\t\t\t\t// by stopping immediate propagation just on the jQuery event. However,\n\t\t\t\t// the native event is re-wrapped by a jQuery one on each level of the\n\t\t\t\t// propagation so the only way to stop it for jQuery is to stop it for\n\t\t\t\t// everyone via native `stopPropagation()`. This is not a problem for\n\t\t\t\t// focus/blur which don't bubble, but it does also stop click on checkboxes\n\t\t\t\t// and radios. We accept this limitation.\n\t\t\t\tevent.stopPropagation();\n\t\t\t\tevent.isImmediatePropagationStopped = returnTrue;\n\t\t\t}\n\t\t}\n\t} );\n}\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This \"if\" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (trac-504, trac-13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || Date.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t\"char\": true,\n\tcode: true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\twhich: true\n}, jQuery.event.addProp );\n\njQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( type, delegateType ) {\n\n\tfunction focusMappedHandler( nativeEvent ) {\n\t\tif ( document.documentMode ) {\n\n\t\t\t// Support: IE 11+\n\t\t\t// Attach a single focusin/focusout handler on the document while someone wants\n\t\t\t// focus/blur. This is because the former are synchronous in IE while the latter\n\t\t\t// are async. In other browsers, all those handlers are invoked synchronously.\n\n\t\t\t// `handle` from private data would already wrap the event, but we need\n\t\t\t// to change the `type` here.\n\t\t\tvar handle = dataPriv.get( this, \"handle\" ),\n\t\t\t\tevent = jQuery.event.fix( nativeEvent );\n\t\t\tevent.type = nativeEvent.type === \"focusin\" ? \"focus\" : \"blur\";\n\t\t\tevent.isSimulated = true;\n\n\t\t\t// First, handle focusin/focusout\n\t\t\thandle( nativeEvent );\n\n\t\t\t// ...then, handle focus/blur\n\t\t\t//\n\t\t\t// focus/blur don't bubble while focusin/focusout do; simulate the former by only\n\t\t\t// invoking the handler at the lower level.\n\t\t\tif ( event.target === event.currentTarget ) {\n\n\t\t\t\t// The setup part calls `leverageNative`, which, in turn, calls\n\t\t\t\t// `jQuery.event.add`, so event handle will already have been set\n\t\t\t\t// by this point.\n\t\t\t\thandle( event );\n\t\t\t}\n\t\t} else {\n\n\t\t\t// For non-IE browsers, attach a single capturing handler on the document\n\t\t\t// while someone wants focusin/focusout.\n\t\t\tjQuery.event.simulate( delegateType, nativeEvent.target,\n\t\t\t\tjQuery.event.fix( nativeEvent ) );\n\t\t}\n\t}\n\n\tjQuery.event.special[ type ] = {\n\n\t\t// Utilize native event if possible so blur/focus sequence is correct\n\t\tsetup: function() {\n\n\t\t\tvar attaches;\n\n\t\t\t// Claim the first handler\n\t\t\t// dataPriv.set( this, \"focus\", ... )\n\t\t\t// dataPriv.set( this, \"blur\", ... )\n\t\t\tleverageNative( this, type, true );\n\n\t\t\tif ( document.documentMode ) {\n\n\t\t\t\t// Support: IE 9 - 11+\n\t\t\t\t// We use the same native handler for focusin & focus (and focusout & blur)\n\t\t\t\t// so we need to coordinate setup & teardown parts between those events.\n\t\t\t\t// Use `delegateType` as the key as `type` is already used by `leverageNative`.\n\t\t\t\tattaches = dataPriv.get( this, delegateType );\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tthis.addEventListener( delegateType, focusMappedHandler );\n\t\t\t\t}\n\t\t\t\tdataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );\n\t\t\t} else {\n\n\t\t\t\t// Return false to allow normal processing in the caller\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\ttrigger: function() {\n\n\t\t\t// Force setup before trigger\n\t\t\tleverageNative( this, type );\n\n\t\t\t// Return non-false to allow normal event-path propagation\n\t\t\treturn true;\n\t\t},\n\n\t\tteardown: function() {\n\t\t\tvar attaches;\n\n\t\t\tif ( document.documentMode ) {\n\t\t\t\tattaches = dataPriv.get( this, delegateType ) - 1;\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tthis.removeEventListener( delegateType, focusMappedHandler );\n\t\t\t\t\tdataPriv.remove( this, delegateType );\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.set( this, delegateType, attaches );\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Return false to indicate standard teardown should be applied\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\t\t// Suppress native focus or blur if we're currently inside\n\t\t// a leveraged native-event stack\n\t\t_default: function( event ) {\n\t\t\treturn dataPriv.get( event.target, type );\n\t\t},\n\n\t\tdelegateType: delegateType\n\t};\n\n\t// Support: Firefox <=44\n\t// Firefox doesn't have focus(in | out) events\n\t// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n\t//\n\t// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n\t// focus(in | out) events fire after focus & blur events,\n\t// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n\t// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\n\t//\n\t// Support: IE 9 - 11+\n\t// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,\n\t// attach a single handler for both events in IE.\n\tjQuery.event.special[ delegateType ] = {\n\t\tsetup: function() {\n\n\t\t\t// Handle: regular nodes (via `this.ownerDocument`), window\n\t\t\t// (via `this.document`) & document (via `this`).\n\t\t\tvar doc = this.ownerDocument || this.document || this,\n\t\t\t\tdataHolder = document.documentMode ? this : doc,\n\t\t\t\tattaches = dataPriv.get( dataHolder, delegateType );\n\n\t\t\t// Support: IE 9 - 11+\n\t\t\t// We use the same native handler for focusin & focus (and focusout & blur)\n\t\t\t// so we need to coordinate setup & teardown parts between those events.\n\t\t\t// Use `delegateType` as the key as `type` is already used by `leverageNative`.\n\t\t\tif ( !attaches ) {\n\t\t\t\tif ( document.documentMode ) {\n\t\t\t\t\tthis.addEventListener( delegateType, focusMappedHandler );\n\t\t\t\t} else {\n\t\t\t\t\tdoc.addEventListener( type, focusMappedHandler, true );\n\t\t\t\t}\n\t\t\t}\n\t\t\tdataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );\n\t\t},\n\t\tteardown: function() {\n\t\t\tvar doc = this.ownerDocument || this.document || this,\n\t\t\t\tdataHolder = document.documentMode ? this : doc,\n\t\t\t\tattaches = dataPriv.get( dataHolder, delegateType ) - 1;\n\n\t\t\tif ( !attaches ) {\n\t\t\t\tif ( document.documentMode ) {\n\t\t\t\t\tthis.removeEventListener( delegateType, focusMappedHandler );\n\t\t\t\t} else {\n\t\t\t\t\tdoc.removeEventListener( type, focusMappedHandler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( dataHolder, delegateType );\n\t\t\t} else {\n\t\t\t\tdataPriv.set( dataHolder, delegateType, attaches );\n\t\t\t}\n\t\t}\n\t};\n} );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t// Support: IE <=10 - 11, Edge 12 - 13 only\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\n\trcleanScript = /^\\s*<!\\[CDATA\\[|\\]\\]>\\s*$/g;\n\n// Prefer a tbody over its parent table for containing new rows\nfunction manipulationTarget( elem, content ) {\n\tif ( nodeName( elem, \"table\" ) &&\n\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\n\t\treturn jQuery( elem ).children( \"tbody\" )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tif ( ( elem.type || \"\" ).slice( 0, 5 ) === \"true/\" ) {\n\t\telem.type = elem.type.slice( 5 );\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.get( src );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdataPriv.remove( dest, \"handle events\" );\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = flat( args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tvalueIsFunction = isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( valueIsFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (trac-8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Re-enable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src && ( node.type || \"\" ).toLowerCase()  !== \"module\" ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl && !node.noModule ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src, {\n\t\t\t\t\t\t\t\t\tnonce: node.nonce || node.getAttribute( \"nonce\" )\n\t\t\t\t\t\t\t\t}, doc );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Unwrap a CDATA section containing script contents. This shouldn't be\n\t\t\t\t\t\t\t// needed as in XML documents they're already not visible when\n\t\t\t\t\t\t\t// inspecting element contents and in HTML documents they have no\n\t\t\t\t\t\t\t// meaning but we're preserving that logic for backwards compatibility.\n\t\t\t\t\t\t\t// This will be removed completely in 4.0. See gh-4904.\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), node, doc );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && isAttached( node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html;\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = isAttached( elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew jQuery#find here for performance reasons:\n\t\t\t// https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar rcustomProp = /^--/;\n\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\nvar swap = function( elem, options, callback ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.call( elem );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\nvar rboxStyle = new RegExp( cssExpand.join( \"|\" ), \"i\" );\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer.style.cssText = \"position:absolute;left:-11111px;width:60px;\" +\n\t\t\t\"margin-top:1px;padding:0;border:0\";\n\t\tdiv.style.cssText =\n\t\t\t\"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"width:60%;top:1%\";\n\t\tdocumentElement.appendChild( container ).appendChild( div );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\n\n\t\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\tdiv.style.right = \"60%\";\n\t\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\n\n\t\t// Support: IE 9 - 11 only\n\t\t// Detect misreporting of content dimensions for box-sizing:border-box elements\n\t\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\n\n\t\t// Support: IE 9 only\n\t\t// Detect overflow:scroll screwiness (gh-3699)\n\t\t// Support: Chrome <=64\n\t\t// Don't get tricked when zoom affects offsetWidth (gh-4029)\n\t\tdiv.style.position = \"absolute\";\n\t\tscrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tfunction roundPixelMeasures( measure ) {\n\t\treturn Math.round( parseFloat( measure ) );\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\n\t\treliableTrDimensionsVal, reliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (trac-8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tjQuery.extend( support, {\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelBoxStyles: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelBoxStylesVal;\n\t\t},\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t},\n\t\tscrollboxSize: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn scrollboxSizeVal;\n\t\t},\n\n\t\t// Support: IE 9 - 11+, Edge 15 - 18+\n\t\t// IE/Edge misreport `getComputedStyle` of table rows with width/height\n\t\t// set in CSS while `offset*` properties report correct values.\n\t\t// Behavior in IE 9 is more subtle than in newer versions & it passes\n\t\t// some versions of this test; make sure not to make it pass there!\n\t\t//\n\t\t// Support: Firefox 70+\n\t\t// Only Firefox includes border widths\n\t\t// in computed dimensions. (gh-4529)\n\t\treliableTrDimensions: function() {\n\t\t\tvar table, tr, trChild, trStyle;\n\t\t\tif ( reliableTrDimensionsVal == null ) {\n\t\t\t\ttable = document.createElement( \"table\" );\n\t\t\t\ttr = document.createElement( \"tr\" );\n\t\t\t\ttrChild = document.createElement( \"div\" );\n\n\t\t\t\ttable.style.cssText = \"position:absolute;left:-11111px;border-collapse:separate\";\n\t\t\t\ttr.style.cssText = \"box-sizing:content-box;border:1px solid\";\n\n\t\t\t\t// Support: Chrome 86+\n\t\t\t\t// Height set through cssText does not get applied.\n\t\t\t\t// Computed height then comes back as 0.\n\t\t\t\ttr.style.height = \"1px\";\n\t\t\t\ttrChild.style.height = \"9px\";\n\n\t\t\t\t// Support: Android 8 Chrome 86+\n\t\t\t\t// In our bodyBackground.html iframe,\n\t\t\t\t// display for all div elements is set to \"inline\",\n\t\t\t\t// which causes a problem only in Android 8 Chrome 86.\n\t\t\t\t// Ensuring the div is `display: block`\n\t\t\t\t// gets around this issue.\n\t\t\t\ttrChild.style.display = \"block\";\n\n\t\t\t\tdocumentElement\n\t\t\t\t\t.appendChild( table )\n\t\t\t\t\t.appendChild( tr )\n\t\t\t\t\t.appendChild( trChild );\n\n\t\t\t\ttrStyle = window.getComputedStyle( tr );\n\t\t\t\treliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +\n\t\t\t\t\tparseInt( trStyle.borderTopWidth, 10 ) +\n\t\t\t\t\tparseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;\n\n\t\t\t\tdocumentElement.removeChild( table );\n\t\t\t}\n\t\t\treturn reliableTrDimensionsVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\t\tisCustomProp = rcustomProp.test( name ),\n\n\t\t// Support: Firefox 51+\n\t\t// Retrieving style before computed somehow\n\t\t// fixes an issue with getting wrong values\n\t\t// on detached elements\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// getPropertyValue is needed for:\n\t//   .css('filter') (IE 9 only, trac-12537)\n\t//   .css('--customProperty) (gh-3144)\n\tif ( computed ) {\n\n\t\t// Support: IE <=9 - 11+\n\t\t// IE only supports `\"float\"` in `getPropertyValue`; in computed styles\n\t\t// it's only available as `\"cssFloat\"`. We no longer modify properties\n\t\t// sent to `.css()` apart from camelCasing, so we need to check both.\n\t\t// Normally, this would create difference in behavior: if\n\t\t// `getPropertyValue` returns an empty string, the value returned\n\t\t// by `.css()` would be `undefined`. This is usually the case for\n\t\t// disconnected elements. However, in IE even disconnected elements\n\t\t// with no styles return `\"none\"` for `getPropertyValue( \"float\" )`\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( isCustomProp && ret ) {\n\n\t\t\t// Support: Firefox 105+, Chrome <=105+\n\t\t\t// Spec requires trimming whitespace for custom properties (gh-4926).\n\t\t\t// Firefox only trims leading whitespace. Chrome just collapses\n\t\t\t// both leading & trailing whitespace to a single space.\n\t\t\t//\n\t\t\t// Fall back to `undefined` if empty string returned.\n\t\t\t// This collapses a missing definition with property defined\n\t\t\t// and set to an empty string but there's no standard API\n\t\t\t// allowing us to differentiate them without a performance penalty\n\t\t\t// and returning `undefined` aligns with older jQuery.\n\t\t\t//\n\t\t\t// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED\n\t\t\t// as whitespace while CSS does not, but this is not a problem\n\t\t\t// because CSS preprocessing replaces them with U+000A LINE FEED\n\t\t\t// (which *is* CSS whitespace)\n\t\t\t// https://www.w3.org/TR/css-syntax-3/#input-preprocessing\n\t\t\tret = ret.replace( rtrimCSS, \"$1\" ) || undefined;\n\t\t}\n\n\t\tif ( ret === \"\" && !isAttached( elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar cssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style,\n\tvendorProps = {};\n\n// Return a vendor-prefixed property or undefined\nfunction vendorPropName( name ) {\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\n// Return a potentially-mapped jQuery.cssProps or vendor prefixed property\nfunction finalPropName( name ) {\n\tvar final = jQuery.cssProps[ name ] || vendorProps[ name ];\n\n\tif ( final ) {\n\t\treturn final;\n\t}\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\treturn vendorProps[ name ] = vendorPropName( name ) || name;\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t};\n\nfunction setPositiveNumber( _elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\n\tvar i = dimension === \"width\" ? 1 : 0,\n\t\textra = 0,\n\t\tdelta = 0,\n\t\tmarginDelta = 0;\n\n\t// Adjustment may not be necessary\n\tif ( box === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\treturn 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin\n\t\t// Count margin delta separately to only add it after scroll gutter adjustment.\n\t\t// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).\n\t\tif ( box === \"margin\" ) {\n\t\t\tmarginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\t// If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n\t\tif ( !isBorderBox ) {\n\n\t\t\t// Add padding\n\t\t\tdelta += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// For \"border\" or \"margin\", add border\n\t\t\tif ( box !== \"padding\" ) {\n\t\t\t\tdelta += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\n\t\t\t// But still keep track of it otherwise\n\t\t\t} else {\n\t\t\t\textra += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\n\t\t// If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n\t\t// \"padding\" or \"margin\"\n\t\t} else {\n\n\t\t\t// For \"content\", subtract padding\n\t\t\tif ( box === \"content\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// For \"content\" or \"padding\", subtract border\n\t\t\tif ( box !== \"margin\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Account for positive content-box scroll gutter when requested by providing computedVal\n\tif ( !isBorderBox && computedVal >= 0 ) {\n\n\t\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n\t\t// Assuming integer scroll gutter, subtract the rest and round down\n\t\tdelta += Math.max( 0, Math.ceil(\n\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\tcomputedVal -\n\t\t\tdelta -\n\t\t\textra -\n\t\t\t0.5\n\n\t\t// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter\n\t\t// Use an explicit zero to avoid NaN (gh-3964)\n\t\t) ) || 0;\n\t}\n\n\treturn delta + marginDelta;\n}\n\nfunction getWidthOrHeight( elem, dimension, extra ) {\n\n\t// Start with computed style\n\tvar styles = getStyles( elem ),\n\n\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\n\t\t// Fake content-box until we know it's needed to know the true value.\n\t\tboxSizingNeeded = !support.boxSizingReliable() || extra,\n\t\tisBorderBox = boxSizingNeeded &&\n\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\tvalueIsBorderBox = isBorderBox,\n\n\t\tval = curCSS( elem, dimension, styles ),\n\t\toffsetProp = \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );\n\n\t// Support: Firefox <=54\n\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\n\tif ( rnumnonpx.test( val ) ) {\n\t\tif ( !extra ) {\n\t\t\treturn val;\n\t\t}\n\t\tval = \"auto\";\n\t}\n\n\n\t// Support: IE 9 - 11 only\n\t// Use offsetWidth/offsetHeight for when box sizing is unreliable.\n\t// In those cases, the computed value can be trusted to be border-box.\n\tif ( ( !support.boxSizingReliable() && isBorderBox ||\n\n\t\t// Support: IE 10 - 11+, Edge 15 - 18+\n\t\t// IE/Edge misreport `getComputedStyle` of table rows with width/height\n\t\t// set in CSS while `offset*` properties report correct values.\n\t\t// Interestingly, in some cases IE 9 doesn't suffer from this issue.\n\t\t!support.reliableTrDimensions() && nodeName( elem, \"tr\" ) ||\n\n\t\t// Fall back to offsetWidth/offsetHeight when value is \"auto\"\n\t\t// This happens for inline elements with no explicit setting (gh-3571)\n\t\tval === \"auto\" ||\n\n\t\t// Support: Android <=4.1 - 4.3 only\n\t\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n\t\t!parseFloat( val ) && jQuery.css( elem, \"display\", false, styles ) === \"inline\" ) &&\n\n\t\t// Make sure the element is visible & connected\n\t\telem.getClientRects().length ) {\n\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t\t// Where available, offsetWidth/offsetHeight approximate border box dimensions.\n\t\t// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\n\t\t// retrieved value as a content box dimension.\n\t\tvalueIsBorderBox = offsetProp in elem;\n\t\tif ( valueIsBorderBox ) {\n\t\t\tval = elem[ offsetProp ];\n\t\t}\n\t}\n\n\t// Normalize \"\" and auto\n\tval = parseFloat( val ) || 0;\n\n\t// Adjust for the element's box model\n\treturn ( val +\n\t\tboxModelAdjustment(\n\t\t\telem,\n\t\t\tdimension,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles,\n\n\t\t\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\n\t\t\tval\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\tanimationIterationCount: true,\n\t\taspectRatio: true,\n\t\tborderImageSlice: true,\n\t\tcolumnCount: true,\n\t\tflexGrow: true,\n\t\tflexShrink: true,\n\t\tfontWeight: true,\n\t\tgridArea: true,\n\t\tgridColumn: true,\n\t\tgridColumnEnd: true,\n\t\tgridColumnStart: true,\n\t\tgridRow: true,\n\t\tgridRowEnd: true,\n\t\tgridRowStart: true,\n\t\tlineHeight: true,\n\t\topacity: true,\n\t\torder: true,\n\t\torphans: true,\n\t\tscale: true,\n\t\twidows: true,\n\t\tzIndex: true,\n\t\tzoom: true,\n\n\t\t// SVG-related\n\t\tfillOpacity: true,\n\t\tfloodOpacity: true,\n\t\tstopOpacity: true,\n\t\tstrokeMiterlimit: true,\n\t\tstrokeOpacity: true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name ),\n\t\t\tstyle = elem.style;\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to query the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (trac-7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug trac-9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (trac-7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\t// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\n\t\t\t// \"px\" to a few hardcoded values.\n\t\t\tif ( type === \"number\" && !isCustomProp ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tif ( isCustomProp ) {\n\t\t\t\t\tstyle.setProperty( name, value );\n\t\t\t\t} else {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name );\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to modify the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( _i, dimension ) {\n\tjQuery.cssHooks[ dimension ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\treturn getWidthOrHeight( elem, dimension, extra );\n\t\t\t\t\t} ) :\n\t\t\t\t\tgetWidthOrHeight( elem, dimension, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = getStyles( elem ),\n\n\t\t\t\t// Only read styles.position if the test has a chance to fail\n\t\t\t\t// to avoid forcing a reflow.\n\t\t\t\tscrollboxSizeBuggy = !support.scrollboxSize() &&\n\t\t\t\t\tstyles.position === \"absolute\",\n\n\t\t\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\n\t\t\t\tboxSizingNeeded = scrollboxSizeBuggy || extra,\n\t\t\t\tisBorderBox = boxSizingNeeded &&\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\tsubtract = extra ?\n\t\t\t\t\tboxModelAdjustment(\n\t\t\t\t\t\telem,\n\t\t\t\t\t\tdimension,\n\t\t\t\t\t\textra,\n\t\t\t\t\t\tisBorderBox,\n\t\t\t\t\t\tstyles\n\t\t\t\t\t) :\n\t\t\t\t\t0;\n\n\t\t\t// Account for unreliable border-box dimensions by comparing offset* to computed and\n\t\t\t// faking a content-box to get border and padding (gh-3699)\n\t\t\tif ( isBorderBox && scrollboxSizeBuggy ) {\n\t\t\t\tsubtract -= Math.ceil(\n\t\t\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\t\t\tparseFloat( styles[ dimension ] ) -\n\t\t\t\t\tboxModelAdjustment( elem, dimension, \"border\", false, styles ) -\n\t\t\t\t\t0.5\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\n\t\t\t\telem.style[ dimension ] = value;\n\t\t\t\tvalue = jQuery.css( elem, dimension );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( prefix !== \"margin\" ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 && (\n\t\t\t\tjQuery.cssHooks[ tween.prop ] ||\n\t\t\t\t\ttween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, inProgress,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction schedule() {\n\tif ( inProgress ) {\n\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n\t\t\twindow.requestAnimationFrame( schedule );\n\t\t} else {\n\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n\t\t}\n\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = Date.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = \"width\" in props || \"height\" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict \"overflow\" and \"display\" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 15\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY and Edge just mirrors\n\t\t// the overflowX value there.\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\tif ( display === \"none\" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( Array.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\t// If there's more to do, yield\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t}\n\n\t\t\t// If this was an empty animation, synthesize a final progress notification\n\t\t\tif ( !length ) {\n\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t}\n\n\t\t\t// Resolve the animation and report its conclusion\n\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\treturn false;\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tresult.stop.bind( result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\t// Attach callbacks from options\n\tanimation\n\t\t.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\treturn animation;\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tisFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off\n\tif ( jQuery.fx.off ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\n\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( _i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = Date.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Run the timer and safely remove it when done (allowing for external removal)\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tjQuery.fx.start();\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( inProgress ) {\n\t\treturn;\n\t}\n\n\tinProgress = true;\n\tschedule();\n};\n\njQuery.fx.stop = function() {\n\tinProgress = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tnodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( _i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// Use proper attribute retrieval (trac-12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule \"no-unused-expressions\" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( \" \" );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n}\n\nfunction classesToArray( value ) {\n\tif ( Array.isArray( value ) ) {\n\t\treturn value;\n\t}\n\tif ( typeof value === \"string\" ) {\n\t\treturn value.match( rnothtmlwhite ) || [];\n\t}\n\treturn [];\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classNames, cur, curValue, className, i, finalValue;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tclassNames = classesToArray( value );\n\n\t\tif ( classNames.length ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tcurValue = getClass( this );\n\t\t\t\tcur = this.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tfor ( i = 0; i < classNames.length; i++ ) {\n\t\t\t\t\t\tclassName = classNames[ i ];\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + className + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += className + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\tthis.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classNames, cur, curValue, className, i, finalValue;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tclassNames = classesToArray( value );\n\n\t\tif ( classNames.length ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tcurValue = getClass( this );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = this.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tfor ( i = 0; i < classNames.length; i++ ) {\n\t\t\t\t\t\tclassName = classNames[ i ];\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + className + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + className + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\tthis.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar classNames, className, i, self,\n\t\t\ttype = typeof value,\n\t\t\tisValidValue = type === \"string\" || Array.isArray( value );\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\tif ( typeof stateVal === \"boolean\" && isValidValue ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tclassNames = classesToArray( value );\n\n\t\treturn this.each( function() {\n\t\t\tif ( isValidValue ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\tself = jQuery( this );\n\n\t\t\t\tfor ( i = 0; i < classNames.length; i++ ) {\n\t\t\t\t\tclassName = classNames[ i ];\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, valueIsFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueIsFunction = isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( Array.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (trac-14686, trac-14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (trac-2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( Array.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\nvar location = window.location;\n\nvar nonce = { guid: Date.now() };\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml, parserErrorElem;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {}\n\n\tparserErrorElem = xml && xml.getElementsByTagName( \"parsererror\" )[ 0 ];\n\tif ( !xml || parserErrorElem ) {\n\t\tjQuery.error( \"Invalid XML: \" + (\n\t\t\tparserErrorElem ?\n\t\t\t\tjQuery.map( parserErrorElem.childNodes, function( el ) {\n\t\t\t\t\treturn el.textContent;\n\t\t\t\t} ).join( \"\\n\" ) :\n\t\t\t\tdata\n\t\t) );\n\t}\n\treturn xml;\n};\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\tstopPropagationCallback = function( e ) {\n\t\te.stopPropagation();\n\t};\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = lastElement = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (trac-9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tlastElement = cur;\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || Object.create( null ) )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (trac-6170)\n\t\t\t\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.addEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\telem[ type ]();\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.removeEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( Array.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && toType( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t};\n\n\tif ( a == null ) {\n\t\treturn \"\";\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} ).filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} ).map( function( _i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( Array.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// trac-7653, trac-8125, trac-8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\noriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes trac-9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() + \" \" ] =\n\t\t\t\t\t\t\t\t\t( responseHeaders[ match[ 1 ].toLowerCase() + \" \" ] || [] )\n\t\t\t\t\t\t\t\t\t\t.concat( match[ 2 ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() + \" \" ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match.join( \", \" );\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (trac-10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket trac-12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 15\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, \"\" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available and should be processed, append data to url\n\t\t\tif ( s.data && ( s.processData || typeof s.data === \"string\" ) ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\n\t\t\t\t// trac-9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce.guid++ ) +\n\t\t\t\t\tuncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Use a noop converter for missing script but not if jsonp\n\t\t\tif ( !isSuccess &&\n\t\t\t\tjQuery.inArray( \"script\", s.dataTypes ) > -1 &&\n\t\t\t\tjQuery.inArray( \"json\", s.dataTypes ) < 0 ) {\n\t\t\t\ts.converters[ \"text script\" ] = function() {};\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( _i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\njQuery.ajaxPrefilter( function( s ) {\n\tvar i;\n\tfor ( i in s.headers ) {\n\t\tif ( i.toLowerCase() === \"content-type\" ) {\n\t\t\ts.contentType = s.headers[ i ] || \"\";\n\t\t}\n\t}\n} );\n\n\njQuery._evalUrl = function( url, options, doc ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (trac-11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\n\t\t// Only evaluate the response if it is successful (gh-4126)\n\t\t// dataFilter is not invoked for failure responses, so using it instead\n\t\t// of the default converter is kludgy but it works.\n\t\tconverters: {\n\t\t\t\"text script\": function() {}\n\t\t},\n\t\tdataFilter: function( response ) {\n\t\t\tjQuery.globalEval( response, options, doc );\n\t\t}\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar htmlIsFunction = isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// trac-1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.ontimeout =\n\t\t\t\t\t\t\t\t\txhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see trac-8605, trac-14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = xhr.ontimeout = callback( \"error\" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( \"abort\" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// trac-14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain or forced-by-attrs requests\n\tif ( s.crossDomain || s.scriptAttrs ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" )\n\t\t\t\t\t.attr( s.scriptAttrs || {} )\n\t\t\t\t\t.prop( { charset: s.scriptCharset, src: s.url } )\n\t\t\t\t\t.on( \"load error\", callback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce.guid++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\tbody.innerHTML = \"<form></form><form></form>\";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument \"data\" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== \"string\" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document's URL (gh-2965)\n\t\t\tbase = context.createElement( \"base\" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\n\t// offset() relates an element's border box to the document origin\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar rect, win,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\t\trect = elem.getBoundingClientRect();\n\t\twin = elem.ownerDocument.defaultView;\n\t\treturn {\n\t\t\ttop: rect.top + win.pageYOffset,\n\t\t\tleft: rect.left + win.pageXOffset\n\t\t};\n\t},\n\n\t// position() relates an element's margin box to its offset parent's padding box\n\t// This corresponds to the behavior of CSS absolute positioning\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset, doc,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// position:fixed elements are offset from the viewport, which itself always has zero offset\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// Assume position:fixed implies availability of getBoundingClientRect\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\toffset = this.offset();\n\n\t\t\t// Account for the *real* offset parent, which can be the document or its root element\n\t\t\t// when a statically positioned element is identified\n\t\t\tdoc = elem.ownerDocument;\n\t\t\toffsetParent = elem.offsetParent || doc.documentElement;\n\t\t\twhile ( offsetParent &&\n\t\t\t\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\n\t\t\t\tjQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\n\t\t\t\toffsetParent = offsetParent.parentNode;\n\t\t\t}\n\t\t\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\n\n\t\t\t\t// Incorporate borders into its offset, since they are outside its content origin\n\t\t\t\tparentOffset = jQuery( offsetParent ).offset();\n\t\t\t\tparentOffset.top += jQuery.css( offsetParent, \"borderTopWidth\", true );\n\t\t\t\tparentOffset.left += jQuery.css( offsetParent, \"borderLeftWidth\", true );\n\t\t\t}\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\n\t\t\t// Coalesce documents and windows\n\t\t\tvar win;\n\t\t\tif ( isWindow( elem ) ) {\n\t\t\t\twin = elem;\n\t\t\t} else if ( elem.nodeType === 9 ) {\n\t\t\t\twin = elem.defaultView;\n\t\t\t}\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( _i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( {\n\t\tpadding: \"inner\" + name,\n\t\tcontent: type,\n\t\t\"\": \"outer\" + name\n\t}, function( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( _i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t},\n\n\thover: function( fnOver, fnOut ) {\n\t\treturn this\n\t\t\t.on( \"mouseenter\", fnOver )\n\t\t\t.on( \"mouseleave\", fnOut || fnOver );\n\t}\n} );\n\njQuery.each(\n\t( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\tfunction( _i, name ) {\n\n\t\t// Handle event binding\n\t\tjQuery.fn[ name ] = function( data, fn ) {\n\t\t\treturn arguments.length > 0 ?\n\t\t\t\tthis.on( name, null, data, fn ) :\n\t\t\t\tthis.trigger( name );\n\t\t};\n\t}\n);\n\n\n\n\n// Support: Android <=4.0 only\n// Make sure we trim BOM and NBSP\n// Require that the \"whitespace run\" starts from a non-whitespace\n// to avoid O(N^2) behavior when the engine would try matching \"\\s+$\" at each space position.\nvar rtrim = /^[\\s\\uFEFF\\xA0]+|([^\\s\\uFEFF\\xA0])[\\s\\uFEFF\\xA0]+$/g;\n\n// Bind a function to a context, optionally partially applying any\n// arguments.\n// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n// However, it is not slated for removal any time soon\njQuery.proxy = function( fn, context ) {\n\tvar tmp, args, proxy;\n\n\tif ( typeof context === \"string\" ) {\n\t\ttmp = fn[ context ];\n\t\tcontext = fn;\n\t\tfn = tmp;\n\t}\n\n\t// Quick check to determine if target is callable, in the spec\n\t// this throws a TypeError, but we will just return undefined.\n\tif ( !isFunction( fn ) ) {\n\t\treturn undefined;\n\t}\n\n\t// Simulated bind\n\targs = slice.call( arguments, 2 );\n\tproxy = function() {\n\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t};\n\n\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\treturn proxy;\n};\n\njQuery.holdReady = function( hold ) {\n\tif ( hold ) {\n\t\tjQuery.readyWait++;\n\t} else {\n\t\tjQuery.ready( true );\n\t}\n};\njQuery.isArray = Array.isArray;\njQuery.parseJSON = JSON.parse;\njQuery.nodeName = nodeName;\njQuery.isFunction = isFunction;\njQuery.isWindow = isWindow;\njQuery.camelCase = camelCase;\njQuery.type = toType;\n\njQuery.now = Date.now;\n\njQuery.isNumeric = function( obj ) {\n\n\t// As of jQuery 3.0, isNumeric is limited to\n\t// strings and numbers (primitives or objects)\n\t// that can be coerced to finite numbers (gh-2662)\n\tvar type = jQuery.type( obj );\n\treturn ( type === \"number\" || type === \"string\" ) &&\n\n\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t!isNaN( obj - parseFloat( obj ) );\n};\n\njQuery.trim = function( text ) {\n\treturn text == null ?\n\t\t\"\" :\n\t\t( text + \"\" ).replace( rtrim, \"$1\" );\n};\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\treturn jQuery;\n\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (trac-13566)\nif ( typeof noGlobal === \"undefined\" ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n} );\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/jquery/dist/jquery.js?");

/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint-env browser */\n\n/*\n  eslint-disable\n  no-console,\n  func-names\n*/\nvar normalizeUrl = __webpack_require__(/*! ./normalize-url */ \"./node_modules/mini-css-extract-plugin/dist/hmr/normalize-url.js\");\n\nvar srcByModuleId = Object.create(null);\nvar noDocument = typeof document === 'undefined';\nvar forEach = Array.prototype.forEach;\n\nfunction debounce(fn, time) {\n  var timeout = 0;\n  return function () {\n    var self = this; // eslint-disable-next-line prefer-rest-params\n\n    var args = arguments;\n\n    var functionCall = function functionCall() {\n      return fn.apply(self, args);\n    };\n\n    clearTimeout(timeout);\n    timeout = setTimeout(functionCall, time);\n  };\n}\n\nfunction noop() {}\n\nfunction getCurrentScriptUrl(moduleId) {\n  var src = srcByModuleId[moduleId];\n\n  if (!src) {\n    if (document.currentScript) {\n      src = document.currentScript.src;\n    } else {\n      var scripts = document.getElementsByTagName('script');\n      var lastScriptTag = scripts[scripts.length - 1];\n\n      if (lastScriptTag) {\n        src = lastScriptTag.src;\n      }\n    }\n\n    srcByModuleId[moduleId] = src;\n  }\n\n  return function (fileMap) {\n    if (!src) {\n      return null;\n    }\n\n    var splitResult = src.split(/([^\\\\/]+)\\.js$/);\n    var filename = splitResult && splitResult[1];\n\n    if (!filename) {\n      return [src.replace('.js', '.css')];\n    }\n\n    if (!fileMap) {\n      return [src.replace('.js', '.css')];\n    }\n\n    return fileMap.split(',').map(function (mapRule) {\n      var reg = new RegExp(\"\".concat(filename, \"\\\\.js$\"), 'g');\n      return normalizeUrl(src.replace(reg, \"\".concat(mapRule.replace(/{fileName}/g, filename), \".css\")));\n    });\n  };\n}\n\nfunction updateCss(el, url) {\n  if (!url) {\n    if (!el.href) {\n      return;\n    } // eslint-disable-next-line\n\n\n    url = el.href.split('?')[0];\n  }\n\n  if (!isUrlRequest(url)) {\n    return;\n  }\n\n  if (el.isLoaded === false) {\n    // We seem to be about to replace a css link that hasn't loaded yet.\n    // We're probably changing the same file more than once.\n    return;\n  }\n\n  if (!url || !(url.indexOf('.css') > -1)) {\n    return;\n  } // eslint-disable-next-line no-param-reassign\n\n\n  el.visited = true;\n  var newEl = el.cloneNode();\n  newEl.isLoaded = false;\n  newEl.addEventListener('load', function () {\n    if (newEl.isLoaded) {\n      return;\n    }\n\n    newEl.isLoaded = true;\n    el.parentNode.removeChild(el);\n  });\n  newEl.addEventListener('error', function () {\n    if (newEl.isLoaded) {\n      return;\n    }\n\n    newEl.isLoaded = true;\n    el.parentNode.removeChild(el);\n  });\n  newEl.href = \"\".concat(url, \"?\").concat(Date.now());\n\n  if (el.nextSibling) {\n    el.parentNode.insertBefore(newEl, el.nextSibling);\n  } else {\n    el.parentNode.appendChild(newEl);\n  }\n}\n\nfunction getReloadUrl(href, src) {\n  var ret; // eslint-disable-next-line no-param-reassign\n\n  href = normalizeUrl(href, {\n    stripWWW: false\n  }); // eslint-disable-next-line array-callback-return\n\n  src.some(function (url) {\n    if (href.indexOf(src) > -1) {\n      ret = url;\n    }\n  });\n  return ret;\n}\n\nfunction reloadStyle(src) {\n  if (!src) {\n    return false;\n  }\n\n  var elements = document.querySelectorAll('link');\n  var loaded = false;\n  forEach.call(elements, function (el) {\n    if (!el.href) {\n      return;\n    }\n\n    var url = getReloadUrl(el.href, src);\n\n    if (!isUrlRequest(url)) {\n      return;\n    }\n\n    if (el.visited === true) {\n      return;\n    }\n\n    if (url) {\n      updateCss(el, url);\n      loaded = true;\n    }\n  });\n  return loaded;\n}\n\nfunction reloadAll() {\n  var elements = document.querySelectorAll('link');\n  forEach.call(elements, function (el) {\n    if (el.visited === true) {\n      return;\n    }\n\n    updateCss(el);\n  });\n}\n\nfunction isUrlRequest(url) {\n  // An URL is not an request if\n  // It is not http or https\n  if (!/^https?:/i.test(url)) {\n    return false;\n  }\n\n  return true;\n}\n\nmodule.exports = function (moduleId, options) {\n  if (noDocument) {\n    console.log('no window.document found, will not HMR CSS');\n    return noop;\n  }\n\n  var getScriptSrc = getCurrentScriptUrl(moduleId);\n\n  function update() {\n    var src = getScriptSrc(options.filename);\n    var reloaded = reloadStyle(src);\n\n    if (options.locals) {\n      console.log('[HMR] Detected local css modules. Reload all css');\n      reloadAll();\n      return;\n    }\n\n    if (reloaded) {\n      console.log('[HMR] css reload %s', src.join(' '));\n    } else {\n      console.log('[HMR] Reload all css');\n      reloadAll();\n    }\n  }\n\n  return debounce(update, 50);\n};\n\n//# sourceURL=webpack://pointlinejs/./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js?");

/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/hmr/normalize-url.js":
/*!************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/hmr/normalize-url.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* eslint-disable */\nfunction normalizeUrl(pathComponents) {\n  return pathComponents.reduce(function (accumulator, item) {\n    switch (item) {\n      case '..':\n        accumulator.pop();\n        break;\n\n      case '.':\n        break;\n\n      default:\n        accumulator.push(item);\n    }\n\n    return accumulator;\n  }, []).join('/');\n}\n\nmodule.exports = function (urlString) {\n  urlString = urlString.trim();\n\n  if (/^data:/i.test(urlString)) {\n    return urlString;\n  }\n\n  var protocol = urlString.indexOf('//') !== -1 ? urlString.split('//')[0] + '//' : '';\n  var components = urlString.replace(new RegExp(protocol, 'i'), '').split('/');\n  var host = components[0].toLowerCase().replace(/\\.$/, '');\n  components[0] = '';\n  var path = normalizeUrl(components);\n  return protocol + host + path;\n};\n\n//# sourceURL=webpack://pointlinejs/./node_modules/mini-css-extract-plugin/dist/hmr/normalize-url.js?");

/***/ }),

/***/ "./node_modules/perfect-scrollbar/css/perfect-scrollbar.css":
/*!******************************************************************!*\
  !*** ./node_modules/perfect-scrollbar/css/perfect-scrollbar.css ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n    if(true) {\n      // 1712088918458\n      var cssReload = __webpack_require__(/*! ./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js */ \"./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js\")(module.id, {\"locals\":false});\n      module.hot.dispose(cssReload);\n      module.hot.accept(undefined, cssReload);\n    }\n  \n\n//# sourceURL=webpack://pointlinejs/./node_modules/perfect-scrollbar/css/perfect-scrollbar.css?");

/***/ }),

/***/ "./src/examples/timeline/styles/timeline.css":
/*!***************************************************!*\
  !*** ./src/examples/timeline/styles/timeline.css ***!
  \***************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n    if(true) {\n      // 1712088918439\n      var cssReload = __webpack_require__(/*! ./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js */ \"./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js\")(module.id, {\"locals\":false});\n      module.hot.dispose(cssReload);\n      module.hot.accept(undefined, cssReload);\n    }\n  \n\n//# sourceURL=webpack://pointlinejs/./src/examples/timeline/styles/timeline.css?");

/***/ }),

/***/ "./src/pointlinejs/vendor/treant/styles/Treant.css":
/*!*********************************************************!*\
  !*** ./src/pointlinejs/vendor/treant/styles/Treant.css ***!
  \*********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n    if(true) {\n      // 1712088918455\n      var cssReload = __webpack_require__(/*! ./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js */ \"./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js\")(module.id, {\"locals\":false});\n      module.hot.dispose(cssReload);\n      module.hot.accept(undefined, cssReload);\n    }\n  \n\n//# sourceURL=webpack://pointlinejs/./src/pointlinejs/vendor/treant/styles/Treant.css?");

/***/ }),

/***/ "./node_modules/perfect-scrollbar/dist/perfect-scrollbar.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/perfect-scrollbar/dist/perfect-scrollbar.esm.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\n * perfect-scrollbar v1.5.3\n * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors\n * Licensed under MIT\n */\n\nfunction get(element) {\n  return getComputedStyle(element);\n}\n\nfunction set(element, obj) {\n  for (var key in obj) {\n    var val = obj[key];\n    if (typeof val === 'number') {\n      val = val + \"px\";\n    }\n    element.style[key] = val;\n  }\n  return element;\n}\n\nfunction div(className) {\n  var div = document.createElement('div');\n  div.className = className;\n  return div;\n}\n\nvar elMatches =\n  typeof Element !== 'undefined' &&\n  (Element.prototype.matches ||\n    Element.prototype.webkitMatchesSelector ||\n    Element.prototype.mozMatchesSelector ||\n    Element.prototype.msMatchesSelector);\n\nfunction matches(element, query) {\n  if (!elMatches) {\n    throw new Error('No element matching method supported');\n  }\n\n  return elMatches.call(element, query);\n}\n\nfunction remove(element) {\n  if (element.remove) {\n    element.remove();\n  } else {\n    if (element.parentNode) {\n      element.parentNode.removeChild(element);\n    }\n  }\n}\n\nfunction queryChildren(element, selector) {\n  return Array.prototype.filter.call(element.children, function (child) { return matches(child, selector); }\n  );\n}\n\nvar cls = {\n  main: 'ps',\n  rtl: 'ps__rtl',\n  element: {\n    thumb: function (x) { return (\"ps__thumb-\" + x); },\n    rail: function (x) { return (\"ps__rail-\" + x); },\n    consuming: 'ps__child--consume',\n  },\n  state: {\n    focus: 'ps--focus',\n    clicking: 'ps--clicking',\n    active: function (x) { return (\"ps--active-\" + x); },\n    scrolling: function (x) { return (\"ps--scrolling-\" + x); },\n  },\n};\n\n/*\n * Helper methods\n */\nvar scrollingClassTimeout = { x: null, y: null };\n\nfunction addScrollingClass(i, x) {\n  var classList = i.element.classList;\n  var className = cls.state.scrolling(x);\n\n  if (classList.contains(className)) {\n    clearTimeout(scrollingClassTimeout[x]);\n  } else {\n    classList.add(className);\n  }\n}\n\nfunction removeScrollingClass(i, x) {\n  scrollingClassTimeout[x] = setTimeout(\n    function () { return i.isAlive && i.element.classList.remove(cls.state.scrolling(x)); },\n    i.settings.scrollingThreshold\n  );\n}\n\nfunction setScrollingClassInstantly(i, x) {\n  addScrollingClass(i, x);\n  removeScrollingClass(i, x);\n}\n\nvar EventElement = function EventElement(element) {\n  this.element = element;\n  this.handlers = {};\n};\n\nvar prototypeAccessors = { isEmpty: { configurable: true } };\n\nEventElement.prototype.bind = function bind (eventName, handler) {\n  if (typeof this.handlers[eventName] === 'undefined') {\n    this.handlers[eventName] = [];\n  }\n  this.handlers[eventName].push(handler);\n  this.element.addEventListener(eventName, handler, false);\n};\n\nEventElement.prototype.unbind = function unbind (eventName, target) {\n    var this$1 = this;\n\n  this.handlers[eventName] = this.handlers[eventName].filter(function (handler) {\n    if (target && handler !== target) {\n      return true;\n    }\n    this$1.element.removeEventListener(eventName, handler, false);\n    return false;\n  });\n};\n\nEventElement.prototype.unbindAll = function unbindAll () {\n  for (var name in this.handlers) {\n    this.unbind(name);\n  }\n};\n\nprototypeAccessors.isEmpty.get = function () {\n    var this$1 = this;\n\n  return Object.keys(this.handlers).every(\n    function (key) { return this$1.handlers[key].length === 0; }\n  );\n};\n\nObject.defineProperties( EventElement.prototype, prototypeAccessors );\n\nvar EventManager = function EventManager() {\n  this.eventElements = [];\n};\n\nEventManager.prototype.eventElement = function eventElement (element) {\n  var ee = this.eventElements.filter(function (ee) { return ee.element === element; })[0];\n  if (!ee) {\n    ee = new EventElement(element);\n    this.eventElements.push(ee);\n  }\n  return ee;\n};\n\nEventManager.prototype.bind = function bind (element, eventName, handler) {\n  this.eventElement(element).bind(eventName, handler);\n};\n\nEventManager.prototype.unbind = function unbind (element, eventName, handler) {\n  var ee = this.eventElement(element);\n  ee.unbind(eventName, handler);\n\n  if (ee.isEmpty) {\n    // remove\n    this.eventElements.splice(this.eventElements.indexOf(ee), 1);\n  }\n};\n\nEventManager.prototype.unbindAll = function unbindAll () {\n  this.eventElements.forEach(function (e) { return e.unbindAll(); });\n  this.eventElements = [];\n};\n\nEventManager.prototype.once = function once (element, eventName, handler) {\n  var ee = this.eventElement(element);\n  var onceHandler = function (evt) {\n    ee.unbind(eventName, onceHandler);\n    handler(evt);\n  };\n  ee.bind(eventName, onceHandler);\n};\n\nfunction createEvent(name) {\n  if (typeof window.CustomEvent === 'function') {\n    return new CustomEvent(name);\n  } else {\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(name, false, false, undefined);\n    return evt;\n  }\n}\n\nfunction processScrollDiff(\n  i,\n  axis,\n  diff,\n  useScrollingClass,\n  forceFireReachEvent\n) {\n  if ( useScrollingClass === void 0 ) useScrollingClass = true;\n  if ( forceFireReachEvent === void 0 ) forceFireReachEvent = false;\n\n  var fields;\n  if (axis === 'top') {\n    fields = [\n      'contentHeight',\n      'containerHeight',\n      'scrollTop',\n      'y',\n      'up',\n      'down' ];\n  } else if (axis === 'left') {\n    fields = [\n      'contentWidth',\n      'containerWidth',\n      'scrollLeft',\n      'x',\n      'left',\n      'right' ];\n  } else {\n    throw new Error('A proper axis should be provided');\n  }\n\n  processScrollDiff$1(i, diff, fields, useScrollingClass, forceFireReachEvent);\n}\n\nfunction processScrollDiff$1(\n  i,\n  diff,\n  ref,\n  useScrollingClass,\n  forceFireReachEvent\n) {\n  var contentHeight = ref[0];\n  var containerHeight = ref[1];\n  var scrollTop = ref[2];\n  var y = ref[3];\n  var up = ref[4];\n  var down = ref[5];\n  if ( useScrollingClass === void 0 ) useScrollingClass = true;\n  if ( forceFireReachEvent === void 0 ) forceFireReachEvent = false;\n\n  var element = i.element;\n\n  // reset reach\n  i.reach[y] = null;\n\n  // 1 for subpixel rounding\n  if (element[scrollTop] < 1) {\n    i.reach[y] = 'start';\n  }\n\n  // 1 for subpixel rounding\n  if (element[scrollTop] > i[contentHeight] - i[containerHeight] - 1) {\n    i.reach[y] = 'end';\n  }\n\n  if (diff) {\n    element.dispatchEvent(createEvent((\"ps-scroll-\" + y)));\n\n    if (diff < 0) {\n      element.dispatchEvent(createEvent((\"ps-scroll-\" + up)));\n    } else if (diff > 0) {\n      element.dispatchEvent(createEvent((\"ps-scroll-\" + down)));\n    }\n\n    if (useScrollingClass) {\n      setScrollingClassInstantly(i, y);\n    }\n  }\n\n  if (i.reach[y] && (diff || forceFireReachEvent)) {\n    element.dispatchEvent(createEvent((\"ps-\" + y + \"-reach-\" + (i.reach[y]))));\n  }\n}\n\nfunction toInt(x) {\n  return parseInt(x, 10) || 0;\n}\n\nfunction isEditable(el) {\n  return (\n    matches(el, 'input,[contenteditable]') ||\n    matches(el, 'select,[contenteditable]') ||\n    matches(el, 'textarea,[contenteditable]') ||\n    matches(el, 'button,[contenteditable]')\n  );\n}\n\nfunction outerWidth(element) {\n  var styles = get(element);\n  return (\n    toInt(styles.width) +\n    toInt(styles.paddingLeft) +\n    toInt(styles.paddingRight) +\n    toInt(styles.borderLeftWidth) +\n    toInt(styles.borderRightWidth)\n  );\n}\n\nvar env = {\n  isWebKit:\n    typeof document !== 'undefined' &&\n    'WebkitAppearance' in document.documentElement.style,\n  supportsTouch:\n    typeof window !== 'undefined' &&\n    ('ontouchstart' in window ||\n      ('maxTouchPoints' in window.navigator &&\n        window.navigator.maxTouchPoints > 0) ||\n      (window.DocumentTouch && document instanceof window.DocumentTouch)),\n  supportsIePointer:\n    typeof navigator !== 'undefined' && navigator.msMaxTouchPoints,\n  isChrome:\n    typeof navigator !== 'undefined' &&\n    /Chrome/i.test(navigator && navigator.userAgent),\n};\n\nfunction updateGeometry(i) {\n  var element = i.element;\n  var roundedScrollTop = Math.floor(element.scrollTop);\n  var rect = element.getBoundingClientRect();\n\n  i.containerWidth = Math.round(rect.width);\n  i.containerHeight = Math.round(rect.height);\n\n  i.contentWidth = element.scrollWidth;\n  i.contentHeight = element.scrollHeight;\n\n  if (!element.contains(i.scrollbarXRail)) {\n    // clean up and append\n    queryChildren(element, cls.element.rail('x')).forEach(function (el) { return remove(el); }\n    );\n    element.appendChild(i.scrollbarXRail);\n  }\n  if (!element.contains(i.scrollbarYRail)) {\n    // clean up and append\n    queryChildren(element, cls.element.rail('y')).forEach(function (el) { return remove(el); }\n    );\n    element.appendChild(i.scrollbarYRail);\n  }\n\n  if (\n    !i.settings.suppressScrollX &&\n    i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth\n  ) {\n    i.scrollbarXActive = true;\n    i.railXWidth = i.containerWidth - i.railXMarginWidth;\n    i.railXRatio = i.containerWidth / i.railXWidth;\n    i.scrollbarXWidth = getThumbSize(\n      i,\n      toInt((i.railXWidth * i.containerWidth) / i.contentWidth)\n    );\n    i.scrollbarXLeft = toInt(\n      ((i.negativeScrollAdjustment + element.scrollLeft) *\n        (i.railXWidth - i.scrollbarXWidth)) /\n        (i.contentWidth - i.containerWidth)\n    );\n  } else {\n    i.scrollbarXActive = false;\n  }\n\n  if (\n    !i.settings.suppressScrollY &&\n    i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight\n  ) {\n    i.scrollbarYActive = true;\n    i.railYHeight = i.containerHeight - i.railYMarginHeight;\n    i.railYRatio = i.containerHeight / i.railYHeight;\n    i.scrollbarYHeight = getThumbSize(\n      i,\n      toInt((i.railYHeight * i.containerHeight) / i.contentHeight)\n    );\n    i.scrollbarYTop = toInt(\n      (roundedScrollTop * (i.railYHeight - i.scrollbarYHeight)) /\n        (i.contentHeight - i.containerHeight)\n    );\n  } else {\n    i.scrollbarYActive = false;\n  }\n\n  if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {\n    i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;\n  }\n  if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {\n    i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;\n  }\n\n  updateCss(element, i);\n\n  if (i.scrollbarXActive) {\n    element.classList.add(cls.state.active('x'));\n  } else {\n    element.classList.remove(cls.state.active('x'));\n    i.scrollbarXWidth = 0;\n    i.scrollbarXLeft = 0;\n    element.scrollLeft = i.isRtl === true ? i.contentWidth : 0;\n  }\n  if (i.scrollbarYActive) {\n    element.classList.add(cls.state.active('y'));\n  } else {\n    element.classList.remove(cls.state.active('y'));\n    i.scrollbarYHeight = 0;\n    i.scrollbarYTop = 0;\n    element.scrollTop = 0;\n  }\n}\n\nfunction getThumbSize(i, thumbSize) {\n  if (i.settings.minScrollbarLength) {\n    thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);\n  }\n  if (i.settings.maxScrollbarLength) {\n    thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);\n  }\n  return thumbSize;\n}\n\nfunction updateCss(element, i) {\n  var xRailOffset = { width: i.railXWidth };\n  var roundedScrollTop = Math.floor(element.scrollTop);\n\n  if (i.isRtl) {\n    xRailOffset.left =\n      i.negativeScrollAdjustment +\n      element.scrollLeft +\n      i.containerWidth -\n      i.contentWidth;\n  } else {\n    xRailOffset.left = element.scrollLeft;\n  }\n  if (i.isScrollbarXUsingBottom) {\n    xRailOffset.bottom = i.scrollbarXBottom - roundedScrollTop;\n  } else {\n    xRailOffset.top = i.scrollbarXTop + roundedScrollTop;\n  }\n  set(i.scrollbarXRail, xRailOffset);\n\n  var yRailOffset = { top: roundedScrollTop, height: i.railYHeight };\n  if (i.isScrollbarYUsingRight) {\n    if (i.isRtl) {\n      yRailOffset.right =\n        i.contentWidth -\n        (i.negativeScrollAdjustment + element.scrollLeft) -\n        i.scrollbarYRight -\n        i.scrollbarYOuterWidth -\n        9;\n    } else {\n      yRailOffset.right = i.scrollbarYRight - element.scrollLeft;\n    }\n  } else {\n    if (i.isRtl) {\n      yRailOffset.left =\n        i.negativeScrollAdjustment +\n        element.scrollLeft +\n        i.containerWidth * 2 -\n        i.contentWidth -\n        i.scrollbarYLeft -\n        i.scrollbarYOuterWidth;\n    } else {\n      yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;\n    }\n  }\n  set(i.scrollbarYRail, yRailOffset);\n\n  set(i.scrollbarX, {\n    left: i.scrollbarXLeft,\n    width: i.scrollbarXWidth - i.railBorderXWidth,\n  });\n  set(i.scrollbarY, {\n    top: i.scrollbarYTop,\n    height: i.scrollbarYHeight - i.railBorderYWidth,\n  });\n}\n\nfunction clickRail(i) {\n  var element = i.element;\n\n  i.event.bind(i.scrollbarY, 'mousedown', function (e) { return e.stopPropagation(); });\n  i.event.bind(i.scrollbarYRail, 'mousedown', function (e) {\n    var positionTop =\n      e.pageY -\n      window.pageYOffset -\n      i.scrollbarYRail.getBoundingClientRect().top;\n    var direction = positionTop > i.scrollbarYTop ? 1 : -1;\n\n    i.element.scrollTop += direction * i.containerHeight;\n    updateGeometry(i);\n\n    e.stopPropagation();\n  });\n\n  i.event.bind(i.scrollbarX, 'mousedown', function (e) { return e.stopPropagation(); });\n  i.event.bind(i.scrollbarXRail, 'mousedown', function (e) {\n    var positionLeft =\n      e.pageX -\n      window.pageXOffset -\n      i.scrollbarXRail.getBoundingClientRect().left;\n    var direction = positionLeft > i.scrollbarXLeft ? 1 : -1;\n\n    i.element.scrollLeft += direction * i.containerWidth;\n    updateGeometry(i);\n\n    e.stopPropagation();\n  });\n}\n\nfunction dragThumb(i) {\n  bindMouseScrollHandler(i, [\n    'containerWidth',\n    'contentWidth',\n    'pageX',\n    'railXWidth',\n    'scrollbarX',\n    'scrollbarXWidth',\n    'scrollLeft',\n    'x',\n    'scrollbarXRail' ]);\n  bindMouseScrollHandler(i, [\n    'containerHeight',\n    'contentHeight',\n    'pageY',\n    'railYHeight',\n    'scrollbarY',\n    'scrollbarYHeight',\n    'scrollTop',\n    'y',\n    'scrollbarYRail' ]);\n}\n\nfunction bindMouseScrollHandler(\n  i,\n  ref\n) {\n  var containerHeight = ref[0];\n  var contentHeight = ref[1];\n  var pageY = ref[2];\n  var railYHeight = ref[3];\n  var scrollbarY = ref[4];\n  var scrollbarYHeight = ref[5];\n  var scrollTop = ref[6];\n  var y = ref[7];\n  var scrollbarYRail = ref[8];\n\n  var element = i.element;\n\n  var startingScrollTop = null;\n  var startingMousePageY = null;\n  var scrollBy = null;\n\n  function mouseMoveHandler(e) {\n    if (e.touches && e.touches[0]) {\n      e[pageY] = e.touches[0].pageY;\n    }\n    element[scrollTop] =\n      startingScrollTop + scrollBy * (e[pageY] - startingMousePageY);\n    addScrollingClass(i, y);\n    updateGeometry(i);\n\n    e.stopPropagation();\n    if (e.type.startsWith('touch') && e.changedTouches.length > 1) {\n      e.preventDefault();\n    }\n  }\n\n  function mouseUpHandler() {\n    removeScrollingClass(i, y);\n    i[scrollbarYRail].classList.remove(cls.state.clicking);\n    i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);\n  }\n\n  function bindMoves(e, touchMode) {\n    startingScrollTop = element[scrollTop];\n    if (touchMode && e.touches) {\n      e[pageY] = e.touches[0].pageY;\n    }\n    startingMousePageY = e[pageY];\n    scrollBy =\n      (i[contentHeight] - i[containerHeight]) /\n      (i[railYHeight] - i[scrollbarYHeight]);\n    if (!touchMode) {\n      i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);\n      i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);\n      e.preventDefault();\n    } else {\n      i.event.bind(i.ownerDocument, 'touchmove', mouseMoveHandler);\n    }\n\n    i[scrollbarYRail].classList.add(cls.state.clicking);\n\n    e.stopPropagation();\n  }\n\n  i.event.bind(i[scrollbarY], 'mousedown', function (e) {\n    bindMoves(e);\n  });\n  i.event.bind(i[scrollbarY], 'touchstart', function (e) {\n    bindMoves(e, true);\n  });\n}\n\nfunction keyboard(i) {\n  var element = i.element;\n\n  var elementHovered = function () { return matches(element, ':hover'); };\n  var scrollbarFocused = function () { return matches(i.scrollbarX, ':focus') || matches(i.scrollbarY, ':focus'); };\n\n  function shouldPreventDefault(deltaX, deltaY) {\n    var scrollTop = Math.floor(element.scrollTop);\n    if (deltaX === 0) {\n      if (!i.scrollbarYActive) {\n        return false;\n      }\n      if (\n        (scrollTop === 0 && deltaY > 0) ||\n        (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)\n      ) {\n        return !i.settings.wheelPropagation;\n      }\n    }\n\n    var scrollLeft = element.scrollLeft;\n    if (deltaY === 0) {\n      if (!i.scrollbarXActive) {\n        return false;\n      }\n      if (\n        (scrollLeft === 0 && deltaX < 0) ||\n        (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)\n      ) {\n        return !i.settings.wheelPropagation;\n      }\n    }\n    return true;\n  }\n\n  i.event.bind(i.ownerDocument, 'keydown', function (e) {\n    if (\n      (e.isDefaultPrevented && e.isDefaultPrevented()) ||\n      e.defaultPrevented\n    ) {\n      return;\n    }\n\n    if (!elementHovered() && !scrollbarFocused()) {\n      return;\n    }\n\n    var activeElement = document.activeElement\n      ? document.activeElement\n      : i.ownerDocument.activeElement;\n    if (activeElement) {\n      if (activeElement.tagName === 'IFRAME') {\n        activeElement = activeElement.contentDocument.activeElement;\n      } else {\n        // go deeper if element is a webcomponent\n        while (activeElement.shadowRoot) {\n          activeElement = activeElement.shadowRoot.activeElement;\n        }\n      }\n      if (isEditable(activeElement)) {\n        return;\n      }\n    }\n\n    var deltaX = 0;\n    var deltaY = 0;\n\n    switch (e.which) {\n      case 37: // left\n        if (e.metaKey) {\n          deltaX = -i.contentWidth;\n        } else if (e.altKey) {\n          deltaX = -i.containerWidth;\n        } else {\n          deltaX = -30;\n        }\n        break;\n      case 38: // up\n        if (e.metaKey) {\n          deltaY = i.contentHeight;\n        } else if (e.altKey) {\n          deltaY = i.containerHeight;\n        } else {\n          deltaY = 30;\n        }\n        break;\n      case 39: // right\n        if (e.metaKey) {\n          deltaX = i.contentWidth;\n        } else if (e.altKey) {\n          deltaX = i.containerWidth;\n        } else {\n          deltaX = 30;\n        }\n        break;\n      case 40: // down\n        if (e.metaKey) {\n          deltaY = -i.contentHeight;\n        } else if (e.altKey) {\n          deltaY = -i.containerHeight;\n        } else {\n          deltaY = -30;\n        }\n        break;\n      case 32: // space bar\n        if (e.shiftKey) {\n          deltaY = i.containerHeight;\n        } else {\n          deltaY = -i.containerHeight;\n        }\n        break;\n      case 33: // page up\n        deltaY = i.containerHeight;\n        break;\n      case 34: // page down\n        deltaY = -i.containerHeight;\n        break;\n      case 36: // home\n        deltaY = i.contentHeight;\n        break;\n      case 35: // end\n        deltaY = -i.contentHeight;\n        break;\n      default:\n        return;\n    }\n\n    if (i.settings.suppressScrollX && deltaX !== 0) {\n      return;\n    }\n    if (i.settings.suppressScrollY && deltaY !== 0) {\n      return;\n    }\n\n    element.scrollTop -= deltaY;\n    element.scrollLeft += deltaX;\n    updateGeometry(i);\n\n    if (shouldPreventDefault(deltaX, deltaY)) {\n      e.preventDefault();\n    }\n  });\n}\n\nfunction wheel(i) {\n  var element = i.element;\n\n  function shouldPreventDefault(deltaX, deltaY) {\n    var roundedScrollTop = Math.floor(element.scrollTop);\n    var isTop = element.scrollTop === 0;\n    var isBottom =\n      roundedScrollTop + element.offsetHeight === element.scrollHeight;\n    var isLeft = element.scrollLeft === 0;\n    var isRight =\n      element.scrollLeft + element.offsetWidth === element.scrollWidth;\n\n    var hitsBound;\n\n    // pick axis with primary direction\n    if (Math.abs(deltaY) > Math.abs(deltaX)) {\n      hitsBound = isTop || isBottom;\n    } else {\n      hitsBound = isLeft || isRight;\n    }\n\n    return hitsBound ? !i.settings.wheelPropagation : true;\n  }\n\n  function getDeltaFromEvent(e) {\n    var deltaX = e.deltaX;\n    var deltaY = -1 * e.deltaY;\n\n    if (typeof deltaX === 'undefined' || typeof deltaY === 'undefined') {\n      // OS X Safari\n      deltaX = (-1 * e.wheelDeltaX) / 6;\n      deltaY = e.wheelDeltaY / 6;\n    }\n\n    if (e.deltaMode && e.deltaMode === 1) {\n      // Firefox in deltaMode 1: Line scrolling\n      deltaX *= 10;\n      deltaY *= 10;\n    }\n\n    if (deltaX !== deltaX && deltaY !== deltaY /* NaN checks */) {\n      // IE in some mouse drivers\n      deltaX = 0;\n      deltaY = e.wheelDelta;\n    }\n\n    if (e.shiftKey) {\n      // reverse axis with shift key\n      return [-deltaY, -deltaX];\n    }\n    return [deltaX, deltaY];\n  }\n\n  function shouldBeConsumedByChild(target, deltaX, deltaY) {\n    // FIXME: this is a workaround for <select> issue in FF and IE #571\n    if (!env.isWebKit && element.querySelector('select:focus')) {\n      return true;\n    }\n\n    if (!element.contains(target)) {\n      return false;\n    }\n\n    var cursor = target;\n\n    while (cursor && cursor !== element) {\n      if (cursor.classList.contains(cls.element.consuming)) {\n        return true;\n      }\n\n      var style = get(cursor);\n\n      // if deltaY && vertical scrollable\n      if (deltaY && style.overflowY.match(/(scroll|auto)/)) {\n        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;\n        if (maxScrollTop > 0) {\n          if (\n            (cursor.scrollTop > 0 && deltaY < 0) ||\n            (cursor.scrollTop < maxScrollTop && deltaY > 0)\n          ) {\n            return true;\n          }\n        }\n      }\n      // if deltaX && horizontal scrollable\n      if (deltaX && style.overflowX.match(/(scroll|auto)/)) {\n        var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;\n        if (maxScrollLeft > 0) {\n          if (\n            (cursor.scrollLeft > 0 && deltaX < 0) ||\n            (cursor.scrollLeft < maxScrollLeft && deltaX > 0)\n          ) {\n            return true;\n          }\n        }\n      }\n\n      cursor = cursor.parentNode;\n    }\n\n    return false;\n  }\n\n  function mousewheelHandler(e) {\n    var ref = getDeltaFromEvent(e);\n    var deltaX = ref[0];\n    var deltaY = ref[1];\n\n    if (shouldBeConsumedByChild(e.target, deltaX, deltaY)) {\n      return;\n    }\n\n    var shouldPrevent = false;\n    if (!i.settings.useBothWheelAxes) {\n      // deltaX will only be used for horizontal scrolling and deltaY will\n      // only be used for vertical scrolling - this is the default\n      element.scrollTop -= deltaY * i.settings.wheelSpeed;\n      element.scrollLeft += deltaX * i.settings.wheelSpeed;\n    } else if (i.scrollbarYActive && !i.scrollbarXActive) {\n      // only vertical scrollbar is active and useBothWheelAxes option is\n      // active, so let's scroll vertical bar using both mouse wheel axes\n      if (deltaY) {\n        element.scrollTop -= deltaY * i.settings.wheelSpeed;\n      } else {\n        element.scrollTop += deltaX * i.settings.wheelSpeed;\n      }\n      shouldPrevent = true;\n    } else if (i.scrollbarXActive && !i.scrollbarYActive) {\n      // useBothWheelAxes and only horizontal bar is active, so use both\n      // wheel axes for horizontal bar\n      if (deltaX) {\n        element.scrollLeft += deltaX * i.settings.wheelSpeed;\n      } else {\n        element.scrollLeft -= deltaY * i.settings.wheelSpeed;\n      }\n      shouldPrevent = true;\n    }\n\n    updateGeometry(i);\n\n    shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);\n    if (shouldPrevent && !e.ctrlKey) {\n      e.stopPropagation();\n      e.preventDefault();\n    }\n  }\n\n  if (typeof window.onwheel !== 'undefined') {\n    i.event.bind(element, 'wheel', mousewheelHandler);\n  } else if (typeof window.onmousewheel !== 'undefined') {\n    i.event.bind(element, 'mousewheel', mousewheelHandler);\n  }\n}\n\nfunction touch(i) {\n  if (!env.supportsTouch && !env.supportsIePointer) {\n    return;\n  }\n\n  var element = i.element;\n\n  function shouldPrevent(deltaX, deltaY) {\n    var scrollTop = Math.floor(element.scrollTop);\n    var scrollLeft = element.scrollLeft;\n    var magnitudeX = Math.abs(deltaX);\n    var magnitudeY = Math.abs(deltaY);\n\n    if (magnitudeY > magnitudeX) {\n      // user is perhaps trying to swipe up/down the page\n\n      if (\n        (deltaY < 0 && scrollTop === i.contentHeight - i.containerHeight) ||\n        (deltaY > 0 && scrollTop === 0)\n      ) {\n        // set prevent for mobile Chrome refresh\n        return window.scrollY === 0 && deltaY > 0 && env.isChrome;\n      }\n    } else if (magnitudeX > magnitudeY) {\n      // user is perhaps trying to swipe left/right across the page\n\n      if (\n        (deltaX < 0 && scrollLeft === i.contentWidth - i.containerWidth) ||\n        (deltaX > 0 && scrollLeft === 0)\n      ) {\n        return true;\n      }\n    }\n\n    return true;\n  }\n\n  function applyTouchMove(differenceX, differenceY) {\n    element.scrollTop -= differenceY;\n    element.scrollLeft -= differenceX;\n\n    updateGeometry(i);\n  }\n\n  var startOffset = {};\n  var startTime = 0;\n  var speed = {};\n  var easingLoop = null;\n\n  function getTouch(e) {\n    if (e.targetTouches) {\n      return e.targetTouches[0];\n    } else {\n      // Maybe IE pointer\n      return e;\n    }\n  }\n\n  function shouldHandle(e) {\n    if (e.pointerType && e.pointerType === 'pen' && e.buttons === 0) {\n      return false;\n    }\n    if (e.targetTouches && e.targetTouches.length === 1) {\n      return true;\n    }\n    if (\n      e.pointerType &&\n      e.pointerType !== 'mouse' &&\n      e.pointerType !== e.MSPOINTER_TYPE_MOUSE\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  function touchStart(e) {\n    if (!shouldHandle(e)) {\n      return;\n    }\n\n    var touch = getTouch(e);\n\n    startOffset.pageX = touch.pageX;\n    startOffset.pageY = touch.pageY;\n\n    startTime = new Date().getTime();\n\n    if (easingLoop !== null) {\n      clearInterval(easingLoop);\n    }\n  }\n\n  function shouldBeConsumedByChild(target, deltaX, deltaY) {\n    if (!element.contains(target)) {\n      return false;\n    }\n\n    var cursor = target;\n\n    while (cursor && cursor !== element) {\n      if (cursor.classList.contains(cls.element.consuming)) {\n        return true;\n      }\n\n      var style = get(cursor);\n\n      // if deltaY && vertical scrollable\n      if (deltaY && style.overflowY.match(/(scroll|auto)/)) {\n        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;\n        if (maxScrollTop > 0) {\n          if (\n            (cursor.scrollTop > 0 && deltaY < 0) ||\n            (cursor.scrollTop < maxScrollTop && deltaY > 0)\n          ) {\n            return true;\n          }\n        }\n      }\n      // if deltaX && horizontal scrollable\n      if (deltaX && style.overflowX.match(/(scroll|auto)/)) {\n        var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;\n        if (maxScrollLeft > 0) {\n          if (\n            (cursor.scrollLeft > 0 && deltaX < 0) ||\n            (cursor.scrollLeft < maxScrollLeft && deltaX > 0)\n          ) {\n            return true;\n          }\n        }\n      }\n\n      cursor = cursor.parentNode;\n    }\n\n    return false;\n  }\n\n  function touchMove(e) {\n    if (shouldHandle(e)) {\n      var touch = getTouch(e);\n\n      var currentOffset = { pageX: touch.pageX, pageY: touch.pageY };\n\n      var differenceX = currentOffset.pageX - startOffset.pageX;\n      var differenceY = currentOffset.pageY - startOffset.pageY;\n\n      if (shouldBeConsumedByChild(e.target, differenceX, differenceY)) {\n        return;\n      }\n\n      applyTouchMove(differenceX, differenceY);\n      startOffset = currentOffset;\n\n      var currentTime = new Date().getTime();\n\n      var timeGap = currentTime - startTime;\n      if (timeGap > 0) {\n        speed.x = differenceX / timeGap;\n        speed.y = differenceY / timeGap;\n        startTime = currentTime;\n      }\n\n      if (shouldPrevent(differenceX, differenceY)) {\n        e.preventDefault();\n      }\n    }\n  }\n  function touchEnd() {\n    if (i.settings.swipeEasing) {\n      clearInterval(easingLoop);\n      easingLoop = setInterval(function() {\n        if (i.isInitialized) {\n          clearInterval(easingLoop);\n          return;\n        }\n\n        if (!speed.x && !speed.y) {\n          clearInterval(easingLoop);\n          return;\n        }\n\n        if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {\n          clearInterval(easingLoop);\n          return;\n        }\n\n        if (!i.element) {\n          clearInterval(easingLoop);\n          return;\n        }\n\n        applyTouchMove(speed.x * 30, speed.y * 30);\n\n        speed.x *= 0.8;\n        speed.y *= 0.8;\n      }, 10);\n    }\n  }\n\n  if (env.supportsTouch) {\n    i.event.bind(element, 'touchstart', touchStart);\n    i.event.bind(element, 'touchmove', touchMove);\n    i.event.bind(element, 'touchend', touchEnd);\n  } else if (env.supportsIePointer) {\n    if (window.PointerEvent) {\n      i.event.bind(element, 'pointerdown', touchStart);\n      i.event.bind(element, 'pointermove', touchMove);\n      i.event.bind(element, 'pointerup', touchEnd);\n    } else if (window.MSPointerEvent) {\n      i.event.bind(element, 'MSPointerDown', touchStart);\n      i.event.bind(element, 'MSPointerMove', touchMove);\n      i.event.bind(element, 'MSPointerUp', touchEnd);\n    }\n  }\n}\n\nvar defaultSettings = function () { return ({\n  handlers: ['click-rail', 'drag-thumb', 'keyboard', 'wheel', 'touch'],\n  maxScrollbarLength: null,\n  minScrollbarLength: null,\n  scrollingThreshold: 1000,\n  scrollXMarginOffset: 0,\n  scrollYMarginOffset: 0,\n  suppressScrollX: false,\n  suppressScrollY: false,\n  swipeEasing: true,\n  useBothWheelAxes: false,\n  wheelPropagation: true,\n  wheelSpeed: 1,\n}); };\n\nvar handlers = {\n  'click-rail': clickRail,\n  'drag-thumb': dragThumb,\n  keyboard: keyboard,\n  wheel: wheel,\n  touch: touch,\n};\n\nvar PerfectScrollbar = function PerfectScrollbar(element, userSettings) {\n  var this$1 = this;\n  if ( userSettings === void 0 ) userSettings = {};\n\n  if (typeof element === 'string') {\n    element = document.querySelector(element);\n  }\n\n  if (!element || !element.nodeName) {\n    throw new Error('no element is specified to initialize PerfectScrollbar');\n  }\n\n  this.element = element;\n\n  element.classList.add(cls.main);\n\n  this.settings = defaultSettings();\n  for (var key in userSettings) {\n    this.settings[key] = userSettings[key];\n  }\n\n  this.containerWidth = null;\n  this.containerHeight = null;\n  this.contentWidth = null;\n  this.contentHeight = null;\n\n  var focus = function () { return element.classList.add(cls.state.focus); };\n  var blur = function () { return element.classList.remove(cls.state.focus); };\n\n  this.isRtl = get(element).direction === 'rtl';\n  if (this.isRtl === true) {\n    element.classList.add(cls.rtl);\n  }\n  this.isNegativeScroll = (function () {\n    var originalScrollLeft = element.scrollLeft;\n    var result = null;\n    element.scrollLeft = -1;\n    result = element.scrollLeft < 0;\n    element.scrollLeft = originalScrollLeft;\n    return result;\n  })();\n  this.negativeScrollAdjustment = this.isNegativeScroll\n    ? element.scrollWidth - element.clientWidth\n    : 0;\n  this.event = new EventManager();\n  this.ownerDocument = element.ownerDocument || document;\n\n  this.scrollbarXRail = div(cls.element.rail('x'));\n  element.appendChild(this.scrollbarXRail);\n  this.scrollbarX = div(cls.element.thumb('x'));\n  this.scrollbarXRail.appendChild(this.scrollbarX);\n  this.scrollbarX.setAttribute('tabindex', 0);\n  this.event.bind(this.scrollbarX, 'focus', focus);\n  this.event.bind(this.scrollbarX, 'blur', blur);\n  this.scrollbarXActive = null;\n  this.scrollbarXWidth = null;\n  this.scrollbarXLeft = null;\n  var railXStyle = get(this.scrollbarXRail);\n  this.scrollbarXBottom = parseInt(railXStyle.bottom, 10);\n  if (isNaN(this.scrollbarXBottom)) {\n    this.isScrollbarXUsingBottom = false;\n    this.scrollbarXTop = toInt(railXStyle.top);\n  } else {\n    this.isScrollbarXUsingBottom = true;\n  }\n  this.railBorderXWidth =\n    toInt(railXStyle.borderLeftWidth) + toInt(railXStyle.borderRightWidth);\n  // Set rail to display:block to calculate margins\n  set(this.scrollbarXRail, { display: 'block' });\n  this.railXMarginWidth =\n    toInt(railXStyle.marginLeft) + toInt(railXStyle.marginRight);\n  set(this.scrollbarXRail, { display: '' });\n  this.railXWidth = null;\n  this.railXRatio = null;\n\n  this.scrollbarYRail = div(cls.element.rail('y'));\n  element.appendChild(this.scrollbarYRail);\n  this.scrollbarY = div(cls.element.thumb('y'));\n  this.scrollbarYRail.appendChild(this.scrollbarY);\n  this.scrollbarY.setAttribute('tabindex', 0);\n  this.event.bind(this.scrollbarY, 'focus', focus);\n  this.event.bind(this.scrollbarY, 'blur', blur);\n  this.scrollbarYActive = null;\n  this.scrollbarYHeight = null;\n  this.scrollbarYTop = null;\n  var railYStyle = get(this.scrollbarYRail);\n  this.scrollbarYRight = parseInt(railYStyle.right, 10);\n  if (isNaN(this.scrollbarYRight)) {\n    this.isScrollbarYUsingRight = false;\n    this.scrollbarYLeft = toInt(railYStyle.left);\n  } else {\n    this.isScrollbarYUsingRight = true;\n  }\n  this.scrollbarYOuterWidth = this.isRtl ? outerWidth(this.scrollbarY) : null;\n  this.railBorderYWidth =\n    toInt(railYStyle.borderTopWidth) + toInt(railYStyle.borderBottomWidth);\n  set(this.scrollbarYRail, { display: 'block' });\n  this.railYMarginHeight =\n    toInt(railYStyle.marginTop) + toInt(railYStyle.marginBottom);\n  set(this.scrollbarYRail, { display: '' });\n  this.railYHeight = null;\n  this.railYRatio = null;\n\n  this.reach = {\n    x:\n      element.scrollLeft <= 0\n        ? 'start'\n        : element.scrollLeft >= this.contentWidth - this.containerWidth\n        ? 'end'\n        : null,\n    y:\n      element.scrollTop <= 0\n        ? 'start'\n        : element.scrollTop >= this.contentHeight - this.containerHeight\n        ? 'end'\n        : null,\n  };\n\n  this.isAlive = true;\n\n  this.settings.handlers.forEach(function (handlerName) { return handlers[handlerName](this$1); });\n\n  this.lastScrollTop = Math.floor(element.scrollTop); // for onScroll only\n  this.lastScrollLeft = element.scrollLeft; // for onScroll only\n  this.event.bind(this.element, 'scroll', function (e) { return this$1.onScroll(e); });\n  updateGeometry(this);\n};\n\nPerfectScrollbar.prototype.update = function update () {\n  if (!this.isAlive) {\n    return;\n  }\n\n  // Recalcuate negative scrollLeft adjustment\n  this.negativeScrollAdjustment = this.isNegativeScroll\n    ? this.element.scrollWidth - this.element.clientWidth\n    : 0;\n\n  // Recalculate rail margins\n  set(this.scrollbarXRail, { display: 'block' });\n  set(this.scrollbarYRail, { display: 'block' });\n  this.railXMarginWidth =\n    toInt(get(this.scrollbarXRail).marginLeft) +\n    toInt(get(this.scrollbarXRail).marginRight);\n  this.railYMarginHeight =\n    toInt(get(this.scrollbarYRail).marginTop) +\n    toInt(get(this.scrollbarYRail).marginBottom);\n\n  // Hide scrollbars not to affect scrollWidth and scrollHeight\n  set(this.scrollbarXRail, { display: 'none' });\n  set(this.scrollbarYRail, { display: 'none' });\n\n  updateGeometry(this);\n\n  processScrollDiff(this, 'top', 0, false, true);\n  processScrollDiff(this, 'left', 0, false, true);\n\n  set(this.scrollbarXRail, { display: '' });\n  set(this.scrollbarYRail, { display: '' });\n};\n\nPerfectScrollbar.prototype.onScroll = function onScroll (e) {\n  if (!this.isAlive) {\n    return;\n  }\n\n  updateGeometry(this);\n  processScrollDiff(this, 'top', this.element.scrollTop - this.lastScrollTop);\n  processScrollDiff(\n    this,\n    'left',\n    this.element.scrollLeft - this.lastScrollLeft\n  );\n\n  this.lastScrollTop = Math.floor(this.element.scrollTop);\n  this.lastScrollLeft = this.element.scrollLeft;\n};\n\nPerfectScrollbar.prototype.destroy = function destroy () {\n  if (!this.isAlive) {\n    return;\n  }\n\n  this.event.unbindAll();\n  remove(this.scrollbarX);\n  remove(this.scrollbarY);\n  remove(this.scrollbarXRail);\n  remove(this.scrollbarYRail);\n  this.removePsClasses();\n\n  // unset elements\n  this.element = null;\n  this.scrollbarX = null;\n  this.scrollbarY = null;\n  this.scrollbarXRail = null;\n  this.scrollbarYRail = null;\n\n  this.isAlive = false;\n};\n\nPerfectScrollbar.prototype.removePsClasses = function removePsClasses () {\n  this.element.className = this.element.className\n    .split(' ')\n    .filter(function (name) { return !name.match(/^ps([-_].+|)$/); })\n    .join(' ');\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PerfectScrollbar);\n//# sourceMappingURL=perfect-scrollbar.esm.js.map\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/perfect-scrollbar/dist/perfect-scrollbar.esm.js?");

/***/ }),

/***/ "./node_modules/reflect-metadata/Reflect.js":
/*!**************************************************!*\
  !*** ./node_modules/reflect-metadata/Reflect.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/*! *****************************************************************************\nCopyright (C) Microsoft. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar Reflect;\n(function (Reflect) {\n    // Metadata Proposal\n    // https://rbuckton.github.io/reflect-metadata/\n    (function (factory) {\n        var root = typeof __webpack_require__.g === \"object\" ? __webpack_require__.g :\n            typeof self === \"object\" ? self :\n                typeof this === \"object\" ? this :\n                    Function(\"return this;\")();\n        var exporter = makeExporter(Reflect);\n        if (typeof root.Reflect === \"undefined\") {\n            root.Reflect = Reflect;\n        }\n        else {\n            exporter = makeExporter(root.Reflect, exporter);\n        }\n        factory(exporter);\n        function makeExporter(target, previous) {\n            return function (key, value) {\n                if (typeof target[key] !== \"function\") {\n                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });\n                }\n                if (previous)\n                    previous(key, value);\n            };\n        }\n    })(function (exporter) {\n        var hasOwn = Object.prototype.hasOwnProperty;\n        // feature test for Symbol support\n        var supportsSymbol = typeof Symbol === \"function\";\n        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== \"undefined\" ? Symbol.toPrimitive : \"@@toPrimitive\";\n        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== \"undefined\" ? Symbol.iterator : \"@@iterator\";\n        var supportsCreate = typeof Object.create === \"function\"; // feature test for Object.create support\n        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support\n        var downLevel = !supportsCreate && !supportsProto;\n        var HashMap = {\n            // create an object in dictionary mode (a.k.a. \"slow\" mode in v8)\n            create: supportsCreate\n                ? function () { return MakeDictionary(Object.create(null)); }\n                : supportsProto\n                    ? function () { return MakeDictionary({ __proto__: null }); }\n                    : function () { return MakeDictionary({}); },\n            has: downLevel\n                ? function (map, key) { return hasOwn.call(map, key); }\n                : function (map, key) { return key in map; },\n            get: downLevel\n                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }\n                : function (map, key) { return map[key]; },\n        };\n        // Load global or shim versions of Map, Set, and WeakMap\n        var functionPrototype = Object.getPrototypeOf(Function);\n        var usePolyfill = typeof process === \"object\" && process[\"env\" + \"\"] && process[\"env\" + \"\"][\"REFLECT_METADATA_USE_MAP_POLYFILL\"] === \"true\";\n        var _Map = !usePolyfill && typeof Map === \"function\" && typeof Map.prototype.entries === \"function\" ? Map : CreateMapPolyfill();\n        var _Set = !usePolyfill && typeof Set === \"function\" && typeof Set.prototype.entries === \"function\" ? Set : CreateSetPolyfill();\n        var _WeakMap = !usePolyfill && typeof WeakMap === \"function\" ? WeakMap : CreateWeakMapPolyfill();\n        // [[Metadata]] internal slot\n        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots\n        var Metadata = new _WeakMap();\n        /**\n         * Applies a set of decorators to a property of a target object.\n         * @param decorators An array of decorators.\n         * @param target The target object.\n         * @param propertyKey (Optional) The property key to decorate.\n         * @param attributes (Optional) The property descriptor for the target key.\n         * @remarks Decorators are applied in reverse order.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     Example = Reflect.decorate(decoratorsArray, Example);\n         *\n         *     // property (on constructor)\n         *     Reflect.decorate(decoratorsArray, Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     Reflect.decorate(decoratorsArray, Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     Object.defineProperty(Example, \"staticMethod\",\n         *         Reflect.decorate(decoratorsArray, Example, \"staticMethod\",\n         *             Object.getOwnPropertyDescriptor(Example, \"staticMethod\")));\n         *\n         *     // method (on prototype)\n         *     Object.defineProperty(Example.prototype, \"method\",\n         *         Reflect.decorate(decoratorsArray, Example.prototype, \"method\",\n         *             Object.getOwnPropertyDescriptor(Example.prototype, \"method\")));\n         *\n         */\n        function decorate(decorators, target, propertyKey, attributes) {\n            if (!IsUndefined(propertyKey)) {\n                if (!IsArray(decorators))\n                    throw new TypeError();\n                if (!IsObject(target))\n                    throw new TypeError();\n                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))\n                    throw new TypeError();\n                if (IsNull(attributes))\n                    attributes = undefined;\n                propertyKey = ToPropertyKey(propertyKey);\n                return DecorateProperty(decorators, target, propertyKey, attributes);\n            }\n            else {\n                if (!IsArray(decorators))\n                    throw new TypeError();\n                if (!IsConstructor(target))\n                    throw new TypeError();\n                return DecorateConstructor(decorators, target);\n            }\n        }\n        exporter(\"decorate\", decorate);\n        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)\n        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata\n        /**\n         * A default metadata decorator factory that can be used on a class, class member, or parameter.\n         * @param metadataKey The key for the metadata entry.\n         * @param metadataValue The value for the metadata entry.\n         * @returns A decorator function.\n         * @remarks\n         * If `metadataKey` is already defined for the target and target key, the\n         * metadataValue for that key will be overwritten.\n         * @example\n         *\n         *     // constructor\n         *     @Reflect.metadata(key, value)\n         *     class Example {\n         *     }\n         *\n         *     // property (on constructor, TypeScript only)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         static staticProperty;\n         *     }\n         *\n         *     // property (on prototype, TypeScript only)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         property;\n         *     }\n         *\n         *     // method (on constructor)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         static staticMethod() { }\n         *     }\n         *\n         *     // method (on prototype)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         method() { }\n         *     }\n         *\n         */\n        function metadata(metadataKey, metadataValue) {\n            function decorator(target, propertyKey) {\n                if (!IsObject(target))\n                    throw new TypeError();\n                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))\n                    throw new TypeError();\n                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);\n            }\n            return decorator;\n        }\n        exporter(\"metadata\", metadata);\n        /**\n         * Define a unique metadata entry on the target.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param metadataValue A value that contains attached metadata.\n         * @param target The target object on which to define metadata.\n         * @param propertyKey (Optional) The property key for the target.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example);\n         *\n         *     // property (on constructor)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"method\");\n         *\n         *     // decorator factory as metadata-producing annotation.\n         *     function MyAnnotation(options): Decorator {\n         *         return (target, key?) => Reflect.defineMetadata(\"custom:annotation\", options, target, key);\n         *     }\n         *\n         */\n        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);\n        }\n        exporter(\"defineMetadata\", defineMetadata);\n        /**\n         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */\n        function hasMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryHasMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"hasMetadata\", hasMetadata);\n        /**\n         * Gets a value indicating whether the target object has the provided metadata key defined.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */\n        function hasOwnMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"hasOwnMetadata\", hasOwnMetadata);\n        /**\n         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */\n        function getMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryGetMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"getMetadata\", getMetadata);\n        /**\n         * Gets the metadata value for the provided metadata key on the target object.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */\n        function getOwnMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"getOwnMetadata\", getOwnMetadata);\n        /**\n         * Gets the metadata keys defined on the target object or its prototype chain.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns An array of unique metadata keys.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getMetadataKeys(Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getMetadataKeys(Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getMetadataKeys(Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getMetadataKeys(Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getMetadataKeys(Example.prototype, \"method\");\n         *\n         */\n        function getMetadataKeys(target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryMetadataKeys(target, propertyKey);\n        }\n        exporter(\"getMetadataKeys\", getMetadataKeys);\n        /**\n         * Gets the unique metadata keys defined on the target object.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns An array of unique metadata keys.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getOwnMetadataKeys(Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getOwnMetadataKeys(Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getOwnMetadataKeys(Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"method\");\n         *\n         */\n        function getOwnMetadataKeys(target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryOwnMetadataKeys(target, propertyKey);\n        }\n        exporter(\"getOwnMetadataKeys\", getOwnMetadataKeys);\n        /**\n         * Deletes the metadata entry from the target object with the provided key.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns `true` if the metadata entry was found and deleted; otherwise, false.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */\n        function deleteMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);\n            if (IsUndefined(metadataMap))\n                return false;\n            if (!metadataMap.delete(metadataKey))\n                return false;\n            if (metadataMap.size > 0)\n                return true;\n            var targetMetadata = Metadata.get(target);\n            targetMetadata.delete(propertyKey);\n            if (targetMetadata.size > 0)\n                return true;\n            Metadata.delete(target);\n            return true;\n        }\n        exporter(\"deleteMetadata\", deleteMetadata);\n        function DecorateConstructor(decorators, target) {\n            for (var i = decorators.length - 1; i >= 0; --i) {\n                var decorator = decorators[i];\n                var decorated = decorator(target);\n                if (!IsUndefined(decorated) && !IsNull(decorated)) {\n                    if (!IsConstructor(decorated))\n                        throw new TypeError();\n                    target = decorated;\n                }\n            }\n            return target;\n        }\n        function DecorateProperty(decorators, target, propertyKey, descriptor) {\n            for (var i = decorators.length - 1; i >= 0; --i) {\n                var decorator = decorators[i];\n                var decorated = decorator(target, propertyKey, descriptor);\n                if (!IsUndefined(decorated) && !IsNull(decorated)) {\n                    if (!IsObject(decorated))\n                        throw new TypeError();\n                    descriptor = decorated;\n                }\n            }\n            return descriptor;\n        }\n        function GetOrCreateMetadataMap(O, P, Create) {\n            var targetMetadata = Metadata.get(O);\n            if (IsUndefined(targetMetadata)) {\n                if (!Create)\n                    return undefined;\n                targetMetadata = new _Map();\n                Metadata.set(O, targetMetadata);\n            }\n            var metadataMap = targetMetadata.get(P);\n            if (IsUndefined(metadataMap)) {\n                if (!Create)\n                    return undefined;\n                metadataMap = new _Map();\n                targetMetadata.set(P, metadataMap);\n            }\n            return metadataMap;\n        }\n        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata\n        function OrdinaryHasMetadata(MetadataKey, O, P) {\n            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\n            if (hasOwn)\n                return true;\n            var parent = OrdinaryGetPrototypeOf(O);\n            if (!IsNull(parent))\n                return OrdinaryHasMetadata(MetadataKey, parent, P);\n            return false;\n        }\n        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata\n        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {\n            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\n            if (IsUndefined(metadataMap))\n                return false;\n            return ToBoolean(metadataMap.has(MetadataKey));\n        }\n        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata\n        function OrdinaryGetMetadata(MetadataKey, O, P) {\n            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\n            if (hasOwn)\n                return OrdinaryGetOwnMetadata(MetadataKey, O, P);\n            var parent = OrdinaryGetPrototypeOf(O);\n            if (!IsNull(parent))\n                return OrdinaryGetMetadata(MetadataKey, parent, P);\n            return undefined;\n        }\n        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata\n        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {\n            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\n            if (IsUndefined(metadataMap))\n                return undefined;\n            return metadataMap.get(MetadataKey);\n        }\n        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata\n        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {\n            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);\n            metadataMap.set(MetadataKey, MetadataValue);\n        }\n        // 3.1.6.1 OrdinaryMetadataKeys(O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys\n        function OrdinaryMetadataKeys(O, P) {\n            var ownKeys = OrdinaryOwnMetadataKeys(O, P);\n            var parent = OrdinaryGetPrototypeOf(O);\n            if (parent === null)\n                return ownKeys;\n            var parentKeys = OrdinaryMetadataKeys(parent, P);\n            if (parentKeys.length <= 0)\n                return ownKeys;\n            if (ownKeys.length <= 0)\n                return parentKeys;\n            var set = new _Set();\n            var keys = [];\n            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {\n                var key = ownKeys_1[_i];\n                var hasKey = set.has(key);\n                if (!hasKey) {\n                    set.add(key);\n                    keys.push(key);\n                }\n            }\n            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {\n                var key = parentKeys_1[_a];\n                var hasKey = set.has(key);\n                if (!hasKey) {\n                    set.add(key);\n                    keys.push(key);\n                }\n            }\n            return keys;\n        }\n        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys\n        function OrdinaryOwnMetadataKeys(O, P) {\n            var keys = [];\n            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\n            if (IsUndefined(metadataMap))\n                return keys;\n            var keysObj = metadataMap.keys();\n            var iterator = GetIterator(keysObj);\n            var k = 0;\n            while (true) {\n                var next = IteratorStep(iterator);\n                if (!next) {\n                    keys.length = k;\n                    return keys;\n                }\n                var nextValue = IteratorValue(next);\n                try {\n                    keys[k] = nextValue;\n                }\n                catch (e) {\n                    try {\n                        IteratorClose(iterator);\n                    }\n                    finally {\n                        throw e;\n                    }\n                }\n                k++;\n            }\n        }\n        // 6 ECMAScript Data Typ0es and Values\n        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values\n        function Type(x) {\n            if (x === null)\n                return 1 /* Null */;\n            switch (typeof x) {\n                case \"undefined\": return 0 /* Undefined */;\n                case \"boolean\": return 2 /* Boolean */;\n                case \"string\": return 3 /* String */;\n                case \"symbol\": return 4 /* Symbol */;\n                case \"number\": return 5 /* Number */;\n                case \"object\": return x === null ? 1 /* Null */ : 6 /* Object */;\n                default: return 6 /* Object */;\n            }\n        }\n        // 6.1.1 The Undefined Type\n        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type\n        function IsUndefined(x) {\n            return x === undefined;\n        }\n        // 6.1.2 The Null Type\n        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type\n        function IsNull(x) {\n            return x === null;\n        }\n        // 6.1.5 The Symbol Type\n        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type\n        function IsSymbol(x) {\n            return typeof x === \"symbol\";\n        }\n        // 6.1.7 The Object Type\n        // https://tc39.github.io/ecma262/#sec-object-type\n        function IsObject(x) {\n            return typeof x === \"object\" ? x !== null : typeof x === \"function\";\n        }\n        // 7.1 Type Conversion\n        // https://tc39.github.io/ecma262/#sec-type-conversion\n        // 7.1.1 ToPrimitive(input [, PreferredType])\n        // https://tc39.github.io/ecma262/#sec-toprimitive\n        function ToPrimitive(input, PreferredType) {\n            switch (Type(input)) {\n                case 0 /* Undefined */: return input;\n                case 1 /* Null */: return input;\n                case 2 /* Boolean */: return input;\n                case 3 /* String */: return input;\n                case 4 /* Symbol */: return input;\n                case 5 /* Number */: return input;\n            }\n            var hint = PreferredType === 3 /* String */ ? \"string\" : PreferredType === 5 /* Number */ ? \"number\" : \"default\";\n            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);\n            if (exoticToPrim !== undefined) {\n                var result = exoticToPrim.call(input, hint);\n                if (IsObject(result))\n                    throw new TypeError();\n                return result;\n            }\n            return OrdinaryToPrimitive(input, hint === \"default\" ? \"number\" : hint);\n        }\n        // 7.1.1.1 OrdinaryToPrimitive(O, hint)\n        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive\n        function OrdinaryToPrimitive(O, hint) {\n            if (hint === \"string\") {\n                var toString_1 = O.toString;\n                if (IsCallable(toString_1)) {\n                    var result = toString_1.call(O);\n                    if (!IsObject(result))\n                        return result;\n                }\n                var valueOf = O.valueOf;\n                if (IsCallable(valueOf)) {\n                    var result = valueOf.call(O);\n                    if (!IsObject(result))\n                        return result;\n                }\n            }\n            else {\n                var valueOf = O.valueOf;\n                if (IsCallable(valueOf)) {\n                    var result = valueOf.call(O);\n                    if (!IsObject(result))\n                        return result;\n                }\n                var toString_2 = O.toString;\n                if (IsCallable(toString_2)) {\n                    var result = toString_2.call(O);\n                    if (!IsObject(result))\n                        return result;\n                }\n            }\n            throw new TypeError();\n        }\n        // 7.1.2 ToBoolean(argument)\n        // https://tc39.github.io/ecma262/2016/#sec-toboolean\n        function ToBoolean(argument) {\n            return !!argument;\n        }\n        // 7.1.12 ToString(argument)\n        // https://tc39.github.io/ecma262/#sec-tostring\n        function ToString(argument) {\n            return \"\" + argument;\n        }\n        // 7.1.14 ToPropertyKey(argument)\n        // https://tc39.github.io/ecma262/#sec-topropertykey\n        function ToPropertyKey(argument) {\n            var key = ToPrimitive(argument, 3 /* String */);\n            if (IsSymbol(key))\n                return key;\n            return ToString(key);\n        }\n        // 7.2 Testing and Comparison Operations\n        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations\n        // 7.2.2 IsArray(argument)\n        // https://tc39.github.io/ecma262/#sec-isarray\n        function IsArray(argument) {\n            return Array.isArray\n                ? Array.isArray(argument)\n                : argument instanceof Object\n                    ? argument instanceof Array\n                    : Object.prototype.toString.call(argument) === \"[object Array]\";\n        }\n        // 7.2.3 IsCallable(argument)\n        // https://tc39.github.io/ecma262/#sec-iscallable\n        function IsCallable(argument) {\n            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.\n            return typeof argument === \"function\";\n        }\n        // 7.2.4 IsConstructor(argument)\n        // https://tc39.github.io/ecma262/#sec-isconstructor\n        function IsConstructor(argument) {\n            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.\n            return typeof argument === \"function\";\n        }\n        // 7.2.7 IsPropertyKey(argument)\n        // https://tc39.github.io/ecma262/#sec-ispropertykey\n        function IsPropertyKey(argument) {\n            switch (Type(argument)) {\n                case 3 /* String */: return true;\n                case 4 /* Symbol */: return true;\n                default: return false;\n            }\n        }\n        // 7.3 Operations on Objects\n        // https://tc39.github.io/ecma262/#sec-operations-on-objects\n        // 7.3.9 GetMethod(V, P)\n        // https://tc39.github.io/ecma262/#sec-getmethod\n        function GetMethod(V, P) {\n            var func = V[P];\n            if (func === undefined || func === null)\n                return undefined;\n            if (!IsCallable(func))\n                throw new TypeError();\n            return func;\n        }\n        // 7.4 Operations on Iterator Objects\n        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects\n        function GetIterator(obj) {\n            var method = GetMethod(obj, iteratorSymbol);\n            if (!IsCallable(method))\n                throw new TypeError(); // from Call\n            var iterator = method.call(obj);\n            if (!IsObject(iterator))\n                throw new TypeError();\n            return iterator;\n        }\n        // 7.4.4 IteratorValue(iterResult)\n        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue\n        function IteratorValue(iterResult) {\n            return iterResult.value;\n        }\n        // 7.4.5 IteratorStep(iterator)\n        // https://tc39.github.io/ecma262/#sec-iteratorstep\n        function IteratorStep(iterator) {\n            var result = iterator.next();\n            return result.done ? false : result;\n        }\n        // 7.4.6 IteratorClose(iterator, completion)\n        // https://tc39.github.io/ecma262/#sec-iteratorclose\n        function IteratorClose(iterator) {\n            var f = iterator[\"return\"];\n            if (f)\n                f.call(iterator);\n        }\n        // 9.1 Ordinary Object Internal Methods and Internal Slots\n        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots\n        // 9.1.1.1 OrdinaryGetPrototypeOf(O)\n        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof\n        function OrdinaryGetPrototypeOf(O) {\n            var proto = Object.getPrototypeOf(O);\n            if (typeof O !== \"function\" || O === functionPrototype)\n                return proto;\n            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.\n            // Try to determine the superclass constructor. Compatible implementations\n            // must either set __proto__ on a subclass constructor to the superclass constructor,\n            // or ensure each class has a valid `constructor` property on its prototype that\n            // points back to the constructor.\n            // If this is not the same as Function.[[Prototype]], then this is definately inherited.\n            // This is the case when in ES6 or when using __proto__ in a compatible browser.\n            if (proto !== functionPrototype)\n                return proto;\n            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.\n            var prototype = O.prototype;\n            var prototypeProto = prototype && Object.getPrototypeOf(prototype);\n            if (prototypeProto == null || prototypeProto === Object.prototype)\n                return proto;\n            // If the constructor was not a function, then we cannot determine the heritage.\n            var constructor = prototypeProto.constructor;\n            if (typeof constructor !== \"function\")\n                return proto;\n            // If we have some kind of self-reference, then we cannot determine the heritage.\n            if (constructor === O)\n                return proto;\n            // we have a pretty good guess at the heritage.\n            return constructor;\n        }\n        // naive Map shim\n        function CreateMapPolyfill() {\n            var cacheSentinel = {};\n            var arraySentinel = [];\n            var MapIterator = /** @class */ (function () {\n                function MapIterator(keys, values, selector) {\n                    this._index = 0;\n                    this._keys = keys;\n                    this._values = values;\n                    this._selector = selector;\n                }\n                MapIterator.prototype[\"@@iterator\"] = function () { return this; };\n                MapIterator.prototype[iteratorSymbol] = function () { return this; };\n                MapIterator.prototype.next = function () {\n                    var index = this._index;\n                    if (index >= 0 && index < this._keys.length) {\n                        var result = this._selector(this._keys[index], this._values[index]);\n                        if (index + 1 >= this._keys.length) {\n                            this._index = -1;\n                            this._keys = arraySentinel;\n                            this._values = arraySentinel;\n                        }\n                        else {\n                            this._index++;\n                        }\n                        return { value: result, done: false };\n                    }\n                    return { value: undefined, done: true };\n                };\n                MapIterator.prototype.throw = function (error) {\n                    if (this._index >= 0) {\n                        this._index = -1;\n                        this._keys = arraySentinel;\n                        this._values = arraySentinel;\n                    }\n                    throw error;\n                };\n                MapIterator.prototype.return = function (value) {\n                    if (this._index >= 0) {\n                        this._index = -1;\n                        this._keys = arraySentinel;\n                        this._values = arraySentinel;\n                    }\n                    return { value: value, done: true };\n                };\n                return MapIterator;\n            }());\n            return /** @class */ (function () {\n                function Map() {\n                    this._keys = [];\n                    this._values = [];\n                    this._cacheKey = cacheSentinel;\n                    this._cacheIndex = -2;\n                }\n                Object.defineProperty(Map.prototype, \"size\", {\n                    get: function () { return this._keys.length; },\n                    enumerable: true,\n                    configurable: true\n                });\n                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };\n                Map.prototype.get = function (key) {\n                    var index = this._find(key, /*insert*/ false);\n                    return index >= 0 ? this._values[index] : undefined;\n                };\n                Map.prototype.set = function (key, value) {\n                    var index = this._find(key, /*insert*/ true);\n                    this._values[index] = value;\n                    return this;\n                };\n                Map.prototype.delete = function (key) {\n                    var index = this._find(key, /*insert*/ false);\n                    if (index >= 0) {\n                        var size = this._keys.length;\n                        for (var i = index + 1; i < size; i++) {\n                            this._keys[i - 1] = this._keys[i];\n                            this._values[i - 1] = this._values[i];\n                        }\n                        this._keys.length--;\n                        this._values.length--;\n                        if (key === this._cacheKey) {\n                            this._cacheKey = cacheSentinel;\n                            this._cacheIndex = -2;\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                Map.prototype.clear = function () {\n                    this._keys.length = 0;\n                    this._values.length = 0;\n                    this._cacheKey = cacheSentinel;\n                    this._cacheIndex = -2;\n                };\n                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };\n                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };\n                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };\n                Map.prototype[\"@@iterator\"] = function () { return this.entries(); };\n                Map.prototype[iteratorSymbol] = function () { return this.entries(); };\n                Map.prototype._find = function (key, insert) {\n                    if (this._cacheKey !== key) {\n                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);\n                    }\n                    if (this._cacheIndex < 0 && insert) {\n                        this._cacheIndex = this._keys.length;\n                        this._keys.push(key);\n                        this._values.push(undefined);\n                    }\n                    return this._cacheIndex;\n                };\n                return Map;\n            }());\n            function getKey(key, _) {\n                return key;\n            }\n            function getValue(_, value) {\n                return value;\n            }\n            function getEntry(key, value) {\n                return [key, value];\n            }\n        }\n        // naive Set shim\n        function CreateSetPolyfill() {\n            return /** @class */ (function () {\n                function Set() {\n                    this._map = new _Map();\n                }\n                Object.defineProperty(Set.prototype, \"size\", {\n                    get: function () { return this._map.size; },\n                    enumerable: true,\n                    configurable: true\n                });\n                Set.prototype.has = function (value) { return this._map.has(value); };\n                Set.prototype.add = function (value) { return this._map.set(value, value), this; };\n                Set.prototype.delete = function (value) { return this._map.delete(value); };\n                Set.prototype.clear = function () { this._map.clear(); };\n                Set.prototype.keys = function () { return this._map.keys(); };\n                Set.prototype.values = function () { return this._map.values(); };\n                Set.prototype.entries = function () { return this._map.entries(); };\n                Set.prototype[\"@@iterator\"] = function () { return this.keys(); };\n                Set.prototype[iteratorSymbol] = function () { return this.keys(); };\n                return Set;\n            }());\n        }\n        // naive WeakMap shim\n        function CreateWeakMapPolyfill() {\n            var UUID_SIZE = 16;\n            var keys = HashMap.create();\n            var rootKey = CreateUniqueKey();\n            return /** @class */ (function () {\n                function WeakMap() {\n                    this._key = CreateUniqueKey();\n                }\n                WeakMap.prototype.has = function (target) {\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);\n                    return table !== undefined ? HashMap.has(table, this._key) : false;\n                };\n                WeakMap.prototype.get = function (target) {\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);\n                    return table !== undefined ? HashMap.get(table, this._key) : undefined;\n                };\n                WeakMap.prototype.set = function (target, value) {\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);\n                    table[this._key] = value;\n                    return this;\n                };\n                WeakMap.prototype.delete = function (target) {\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);\n                    return table !== undefined ? delete table[this._key] : false;\n                };\n                WeakMap.prototype.clear = function () {\n                    // NOTE: not a real clear, just makes the previous data unreachable\n                    this._key = CreateUniqueKey();\n                };\n                return WeakMap;\n            }());\n            function CreateUniqueKey() {\n                var key;\n                do\n                    key = \"@@WeakMap@@\" + CreateUUID();\n                while (HashMap.has(keys, key));\n                keys[key] = true;\n                return key;\n            }\n            function GetOrCreateWeakMapTable(target, create) {\n                if (!hasOwn.call(target, rootKey)) {\n                    if (!create)\n                        return undefined;\n                    Object.defineProperty(target, rootKey, { value: HashMap.create() });\n                }\n                return target[rootKey];\n            }\n            function FillRandomBytes(buffer, size) {\n                for (var i = 0; i < size; ++i)\n                    buffer[i] = Math.random() * 0xff | 0;\n                return buffer;\n            }\n            function GenRandomBytes(size) {\n                if (typeof Uint8Array === \"function\") {\n                    if (typeof crypto !== \"undefined\")\n                        return crypto.getRandomValues(new Uint8Array(size));\n                    if (typeof msCrypto !== \"undefined\")\n                        return msCrypto.getRandomValues(new Uint8Array(size));\n                    return FillRandomBytes(new Uint8Array(size), size);\n                }\n                return FillRandomBytes(new Array(size), size);\n            }\n            function CreateUUID() {\n                var data = GenRandomBytes(UUID_SIZE);\n                // mark as random - RFC 4122 § 4.4\n                data[6] = data[6] & 0x4f | 0x40;\n                data[8] = data[8] & 0xbf | 0x80;\n                var result = \"\";\n                for (var offset = 0; offset < UUID_SIZE; ++offset) {\n                    var byte = data[offset];\n                    if (offset === 4 || offset === 6 || offset === 8)\n                        result += \"-\";\n                    if (byte < 16)\n                        result += \"0\";\n                    result += byte.toString(16).toLowerCase();\n                }\n                return result;\n            }\n        }\n        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.\n        function MakeDictionary(obj) {\n            obj.__ = undefined;\n            delete obj.__;\n            return obj;\n        }\n    });\n})(Reflect || (Reflect = {}));\n\n\n//# sourceURL=webpack://pointlinejs/./node_modules/reflect-metadata/Reflect.js?");

/***/ }),

/***/ "./src/examples/timeline/timeline.ts":
/*!*******************************************!*\
  !*** ./src/examples/timeline/timeline.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst pointlinejs_1 = __webpack_require__(/*! @pointlinejs/pointlinejs */ \"./src/pointlinejs/pointlinejs.ts\");\n__webpack_require__(/*! ./styles/timeline.css */ \"./src/examples/timeline/styles/timeline.css\");\nvar simple_chart_config = {\n    chart: {\n        container: '#OrganiseChart-simple',\n        hideRootNode: true,\n        connectors: {\n            type: 'step',\n            style: {\n                'arrow-end': 'classic-wide-long',\n                'stroke-width': 2,\n                stroke: '#665B57',\n            },\n        },\n        node: {\n            collapsable: true,\n        },\n        animation: {\n            nodeAnimation: 'easeOutBounce',\n            nodeSpeed: 700,\n            connectorsAnimation: 'bounce',\n            connectorsSpeed: 700,\n        },\n    },\n    nodeStructure: {\n        text: { name: 'Parent node' },\n        children: [\n            {\n                HTMLclass: 'timeline main-date',\n                text: { desc: '', name: '01.01.2014' },\n                children: [\n                    {\n                        text: { name: 'Event 1' },\n                    },\n                    {\n                        text: { name: 'Event 2' },\n                    },\n                ],\n            },\n            {\n                HTMLclass: 'main-date',\n                text: { name: '12.02.2014' },\n                collapsed: true,\n                children: [\n                    {\n                        text: { name: 'Event 1' },\n                    },\n                    {\n                        text: { name: 'Event 2' },\n                    },\n                ],\n            },\n            {\n                HTMLclass: 'main-date',\n                text: { name: '23.02.2014' },\n                children: [\n                    {\n                        text: { name: 'Event 1' },\n                    },\n                    {\n                        text: { name: 'Event 2' },\n                    },\n                ],\n            },\n            {\n                HTMLclass: 'main-date',\n                text: { name: '03.06.2014' },\n            },\n        ],\n    },\n};\nconst graphjs = new pointlinejs_1.PointlineJS(simple_chart_config);\ngraphjs.draw();\n\n\n//# sourceURL=webpack://pointlinejs/./src/examples/timeline/timeline.ts?");

/***/ }),

/***/ "./src/pointlinejs/InjectableList.ts":
/*!*******************************************!*\
  !*** ./src/pointlinejs/InjectableList.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DI_LIST = void 0;\nexports.DI_LIST = {\n    treeNode: Symbol.for('TreeNode'),\n    treeStore: Symbol.for('TreeStore'),\n    treant: Symbol.for('Treant'),\n    nodeDB: Symbol.for('NodeDB'),\n    tree: Symbol.for('Tree'),\n    util: Symbol.for('Util'),\n    imageLoader: Symbol.for('ImageLoader'),\n    nodeDBState: Symbol.for('NodeDBState'),\n    jsonConfig: Symbol.for('JSONconfig'),\n    pointlineChart: Symbol.for('pointlineChart'),\n};\n\n\n//# sourceURL=webpack://pointlinejs/./src/pointlinejs/InjectableList.ts?");

/***/ }),

/***/ "./src/pointlinejs/pointlinejs.ts":
/*!****************************************!*\
  !*** ./src/pointlinejs/pointlinejs.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PointlineJS = void 0;\nconst ImageLoader_1 = __webpack_require__(/*! ./vendor/treant/ImageLoader */ \"./src/pointlinejs/vendor/treant/ImageLoader.ts\");\nconst InjectableList_1 = __webpack_require__(/*! ./InjectableList */ \"./src/pointlinejs/InjectableList.ts\");\nconst JSONConfig_1 = __webpack_require__(/*! ./vendor/treant/JSONConfig */ \"./src/pointlinejs/vendor/treant/JSONConfig.ts\");\nconst NodeDB_1 = __webpack_require__(/*! ./vendor/treant/NodeDB */ \"./src/pointlinejs/vendor/treant/NodeDB.ts\");\nconst Treant_1 = __webpack_require__(/*! ./vendor/treant/Treant */ \"./src/pointlinejs/vendor/treant/Treant.ts\");\nconst Tree_1 = __webpack_require__(/*! ./vendor/treant/Tree */ \"./src/pointlinejs/vendor/treant/Tree.ts\");\nconst TreeNode_1 = __webpack_require__(/*! ./vendor/treant/TreeNode */ \"./src/pointlinejs/vendor/treant/TreeNode.ts\");\nconst TreeStore_1 = __webpack_require__(/*! ./vendor/treant/TreeStore */ \"./src/pointlinejs/vendor/treant/TreeStore.ts\");\nconst Util_1 = __webpack_require__(/*! ./vendor/treant/Util */ \"./src/pointlinejs/vendor/treant/Util.ts\");\nconst inversify_1 = __webpack_require__(/*! inversify */ \"./node_modules/inversify/es/inversify.js\");\n__webpack_require__(/*! reflect-metadata */ \"./node_modules/reflect-metadata/Reflect.js\");\nwindow.jQuery = window.$ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n__webpack_require__(/*! jquery.easing */ \"./node_modules/jquery.easing/jquery.easing.js\");\nclass PointlineJS {\n    constructor(chartConfig) {\n        const container = new inversify_1.Container();\n        container.bind(InjectableList_1.DI_LIST.treeStore).to(TreeStore_1.TreeStore).inSingletonScope();\n        container.bind(InjectableList_1.DI_LIST.util).to(Util_1.UTIL).inSingletonScope();\n        container.bind(InjectableList_1.DI_LIST.imageLoader).to(ImageLoader_1.ImageLoader).inSingletonScope();\n        container.bind(InjectableList_1.DI_LIST.nodeDB).to(NodeDB_1.NodeDB).inSingletonScope();\n        container.bind(InjectableList_1.DI_LIST.nodeDBState).to(NodeDB_1.NodeDBState).inSingletonScope();\n        container.bind(InjectableList_1.DI_LIST.jsonConfig).to(JSONConfig_1.JSONconfig).inSingletonScope();\n        container.bind(InjectableList_1.DI_LIST.treeNode).to(TreeNode_1.TreeNode);\n        container.bind(InjectableList_1.DI_LIST.tree).to(Tree_1.Tree);\n        container.bind(InjectableList_1.DI_LIST.treant).to(Treant_1.Treant);\n        this.treant = container.get(InjectableList_1.DI_LIST.treant);\n        this.chartConfig = chartConfig;\n    }\n    draw() {\n        this.tree = this.treant.init(this.chartConfig);\n    }\n    getTree() {\n        return this.tree;\n    }\n}\nexports.PointlineJS = PointlineJS;\n\n\n//# sourceURL=webpack://pointlinejs/./src/pointlinejs/pointlinejs.ts?");

/***/ }),

/***/ "./src/pointlinejs/vendor/treant/ImageLoader.ts":
/*!******************************************************!*\
  !*** ./src/pointlinejs/vendor/treant/ImageLoader.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImageLoader = void 0;\nconst inversify_1 = __webpack_require__(/*! inversify */ \"./node_modules/inversify/es/inversify.js\");\nconst InjectableList_1 = __webpack_require__(/*! ../../InjectableList */ \"./src/pointlinejs/InjectableList.ts\");\n__webpack_require__(/*! reflect-metadata */ \"./node_modules/reflect-metadata/Reflect.js\");\nlet ImageLoader = exports.ImageLoader = class ImageLoader {\n    constructor(util) {\n        this.util = util;\n        this.loading = [];\n        return this.reset();\n    }\n    reset() {\n        this.loading = [];\n        return this;\n    }\n    processNode(node) {\n        var aImages = node.nodeDOM.getElementsByTagName('img');\n        var i = aImages.length;\n        while (i--) {\n            this.create(node, aImages[i]);\n        }\n        return this;\n    }\n    removeAll(img_src) {\n        var i = this.loading.length;\n        while (i--) {\n            if (this.loading[i] === img_src) {\n                this.loading.splice(i, 1);\n            }\n        }\n        return this;\n    }\n    create(node, image) {\n        var self = this, source = image.src;\n        function imgTrigger() {\n            self.removeAll(source);\n            node.width = node.nodeDOM.offsetWidth;\n            node.height = node.nodeDOM.offsetHeight;\n        }\n        if (image.src.indexOf('data:') !== 0) {\n            this.loading.push(source);\n            if (image.complete) {\n                return imgTrigger();\n            }\n            this.util.addEvent(image, 'load', imgTrigger);\n            this.util.addEvent(image, 'error', imgTrigger);\n            image.src +=\n                (image.src.indexOf('?') > 0 ? '&' : '?') + new Date().getTime();\n        }\n        else {\n            imgTrigger();\n        }\n    }\n    isNotLoading() {\n        return this.loading.length === 0;\n    }\n};\nexports.ImageLoader = ImageLoader = __decorate([\n    (0, inversify_1.injectable)(),\n    __param(0, (0, inversify_1.inject)(InjectableList_1.DI_LIST.util))\n], ImageLoader);\n\n\n//# sourceURL=webpack://pointlinejs/./src/pointlinejs/vendor/treant/ImageLoader.ts?");

/***/ }),

/***/ "./src/pointlinejs/vendor/treant/JSONConfig.ts":
/*!*****************************************************!*\
  !*** ./src/pointlinejs/vendor/treant/JSONConfig.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JSONconfig = void 0;\nconst inversify_1 = __webpack_require__(/*! inversify */ \"./node_modules/inversify/es/inversify.js\");\nlet JSONconfig = exports.JSONconfig = class JSONconfig {\n    constructor() {\n        this.json_id = 1;\n    }\n    make(configArray) {\n        var i = configArray.length, node;\n        this.jsonStructure = {\n            chart: null,\n            nodeStructure: null,\n        };\n        while (i--) {\n            node = configArray[i];\n            if (node.hasOwnProperty('container')) {\n                this.jsonStructure.chart = node;\n                continue;\n            }\n            if (!node.hasOwnProperty('parent') && !node.hasOwnProperty('container')) {\n                this.jsonStructure.nodeStructure = node;\n                node._json_id = 0;\n            }\n        }\n        this.findChildren(configArray);\n        return this.jsonStructure;\n    }\n    findChildren(nodes) {\n        var parents = [0];\n        while (parents.length) {\n            const parentId = parents.pop();\n            const parent = this.findNode(this.jsonStructure.nodeStructure, parentId);\n            var i = 0, len = nodes.length, children = [];\n            for (; i < len; i++) {\n                var node = nodes[i];\n                if (node['parent']) {\n                    const nodeValue = node;\n                    if (nodeValue.parent && nodeValue.parent._json_id === parentId) {\n                        nodeValue._json_id = this.getID();\n                        delete nodeValue.parent;\n                        children.push(node);\n                        parents.push(nodeValue._json_id);\n                    }\n                }\n            }\n            if (children.length) {\n                parent.children = children;\n            }\n        }\n    }\n    findNode(node, nodeId) {\n        var childrenLen, found;\n        if (node._json_id === nodeId) {\n            return node;\n        }\n        else if (node.children) {\n            childrenLen = node.children.length;\n            while (childrenLen--) {\n                found = this.findNode(node.children[childrenLen], nodeId);\n                if (found) {\n                    return found;\n                }\n            }\n        }\n        return null;\n    }\n    getID() {\n        return this.json_id++;\n    }\n};\nexports.JSONconfig = JSONconfig = __decorate([\n    (0, inversify_1.injectable)()\n], JSONconfig);\n\n\n//# sourceURL=webpack://pointlinejs/./src/pointlinejs/vendor/treant/JSONConfig.ts?");

/***/ }),

/***/ "./src/pointlinejs/vendor/treant/NodeDB.ts":
/*!*************************************************!*\
  !*** ./src/pointlinejs/vendor/treant/NodeDB.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NodeDB = exports.NodeDBState = void 0;\nconst inversify_1 = __webpack_require__(/*! inversify */ \"./node_modules/inversify/es/inversify.js\");\nconst TreeNode_1 = __webpack_require__(/*! ./TreeNode */ \"./src/pointlinejs/vendor/treant/TreeNode.ts\");\nconst Util_1 = __webpack_require__(/*! ./Util */ \"./src/pointlinejs/vendor/treant/Util.ts\");\nconst InjectableList_1 = __webpack_require__(/*! ../../InjectableList */ \"./src/pointlinejs/InjectableList.ts\");\nlet NodeDBState = exports.NodeDBState = class NodeDBState {\n    constructor() {\n        this.nodesWithHeightAndWidth = new Set();\n        this.dbReady = new Promise((resolve, reject) => {\n            this.dbReadyResolve = resolve;\n            this.dbReadyReject = reject;\n        });\n    }\n};\nexports.NodeDBState = NodeDBState = __decorate([\n    (0, inversify_1.injectable)()\n], NodeDBState);\nlet NodeDB = exports.NodeDB = class NodeDB {\n    constructor(nodeDBState) {\n        this.nodeDBState = nodeDBState;\n        this.util = new Util_1.UTIL();\n        this.db = [];\n    }\n    get size() {\n        return this.db.length;\n    }\n    init(nodeStructure, tree) {\n        return this.reset(nodeStructure, tree);\n    }\n    iterateChildren(node, parentId, tree) {\n        var newNode = this.createNode(node, parentId, tree, null);\n        if (node.children) {\n            if (node.childrenDropLevel && node.childrenDropLevel > 0) {\n                while (node.childrenDropLevel--) {\n                    var connStyle = this.util.cloneObj(newNode.connStyle);\n                    newNode = this.createNode('pseudo', newNode.id, tree, null);\n                    newNode.connStyle = connStyle;\n                    newNode.children = [];\n                }\n            }\n            var stack = node.stackChildren && !this.hasGrandChildren(node) ? newNode.id : null;\n            if (stack !== null) {\n                newNode.stackChildren = [];\n            }\n            for (var i = 0, len = node.children.length; i < len; i++) {\n                if (stack !== null) {\n                    newNode = this.createNode(node.children[i], newNode.id, tree, stack);\n                    if (i + 1 < len) {\n                        newNode.children = [];\n                    }\n                }\n                else {\n                    this.iterateChildren(node.children[i], newNode.id, tree);\n                }\n            }\n        }\n    }\n    reset(nodeStructure, tree) {\n        this.db = [];\n        if (tree.CONFIG.animateOnInit) {\n            nodeStructure.collapsed = true;\n        }\n        this.iterateChildren(nodeStructure, -1, tree);\n        this.createGeometries(tree);\n        return this;\n    }\n    createGeometries(tree) {\n        var i = this.db.length;\n        this.nodeDBState.totalNodes = this.db.length;\n        const logTimeout = (nodeDb, nodeDBState) => {\n            nodeDBState.nodesWithHeightAndWidth.add(nodeDb.id);\n            if (nodeDBState.totalNodes === nodeDBState.nodesWithHeightAndWidth.size) {\n                this.nodeDBState.dbReadyResolve(true);\n            }\n        };\n        while (i--) {\n            this.get(i).createGeometry(tree);\n            setTimeout(logTimeout, 100, this.get(i), this.nodeDBState);\n        }\n        return this;\n    }\n    get(nodeId) {\n        return this.db[nodeId];\n    }\n    walk(callback) {\n        var i = this.db.length;\n        while (i--) {\n            callback.apply(this, [this.get(i)]);\n        }\n        return this;\n    }\n    createNode(nodeStructure, parentId, tree, stackParentId) {\n        const node = new TreeNode_1.TreeNode(tree).init(nodeStructure, this.db.length, parentId, tree, stackParentId);\n        this.db.push(node);\n        if (parentId >= 0) {\n            var parent = this.get(parentId);\n            if (typeof node.pseudo !== 'undefined' && node.pseudo === false) {\n                const nodeStructureValue = nodeStructure;\n                if (nodeStructureValue.position) {\n                    if (nodeStructureValue.position === 'left') {\n                        parent.children.push(node.id);\n                    }\n                    else if (nodeStructureValue.position === 'right') {\n                        parent.children.splice(0, 0, node.id);\n                    }\n                    else if (nodeStructureValue.position === 'center') {\n                        parent.children.splice(Math.floor(parent.children.length / 2), 0, node.id);\n                    }\n                    else {\n                        const position = parseInt(nodeStructureValue.position, 10);\n                        if (parent.children.length === 1 && position > 0) {\n                            parent.children.splice(0, 0, node.id);\n                        }\n                        else {\n                            parent.children.splice(Math.max(position, parent.children.length - 1), 0, node.id);\n                        }\n                    }\n                }\n            }\n            else {\n                parent.children.push(node.id);\n            }\n        }\n        if (stackParentId) {\n            this.get(stackParentId).stackParent = true;\n            this.get(stackParentId).stackChildren.push(node.id);\n        }\n        return node;\n    }\n    getMinMaxCoord(dim, parent, MinMax) {\n        parent = parent || this.get(0);\n        MinMax = MinMax || {\n            min: parent[dim],\n            max: parent[dim] + (dim === 'X' ? parent.width : parent.height),\n        };\n        var i = parent.childrenCount();\n        while (i--) {\n            var node = parent.childAt(i), maxTest = node[dim] + (dim === 'X' ? node.width : node.height), minTest = node[dim];\n            if (maxTest > MinMax.max) {\n                MinMax.max = maxTest;\n            }\n            if (minTest < MinMax.min) {\n                MinMax.min = minTest;\n            }\n            this.getMinMaxCoord(dim, node, MinMax);\n        }\n        return MinMax;\n    }\n    hasGrandChildren(nodeStructure) {\n        var i = nodeStructure.children.length;\n        while (i--) {\n            if (nodeStructure.children[i].children &&\n                nodeStructure.children[i].children.length > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\nexports.NodeDB = NodeDB = __decorate([\n    (0, inversify_1.injectable)(),\n    __param(0, (0, inversify_1.inject)(InjectableList_1.DI_LIST.nodeDBState))\n], NodeDB);\n\n\n//# sourceURL=webpack://pointlinejs/./src/pointlinejs/vendor/treant/NodeDB.ts?");

/***/ }),

/***/ "./src/pointlinejs/vendor/treant/Treant.ts":
/*!*************************************************!*\
  !*** ./src/pointlinejs/vendor/treant/Treant.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Treant = void 0;\n__webpack_require__(/*! ./styles/Treant.css */ \"./src/pointlinejs/vendor/treant/styles/Treant.css\");\n__webpack_require__(/*! perfect-scrollbar/css/perfect-scrollbar.css */ \"./node_modules/perfect-scrollbar/css/perfect-scrollbar.css\");\nconst inversify_1 = __webpack_require__(/*! inversify */ \"./node_modules/inversify/es/inversify.js\");\nconst InjectableList_1 = __webpack_require__(/*! ../../InjectableList */ \"./src/pointlinejs/InjectableList.ts\");\n__webpack_require__(/*! reflect-metadata */ \"./node_modules/reflect-metadata/Reflect.js\");\nlet Treant = exports.Treant = class Treant {\n    constructor(jsonConfigService, treeStore, nodeDB) {\n        this.jsonConfigService = jsonConfigService;\n        this.treeStore = treeStore;\n        this.nodeDB = nodeDB;\n        this.tree = null;\n    }\n    destroy() {\n        this.tree.then((tree) => this.treeStore.destroy(tree.id));\n    }\n    init(jsonConfig, callback, jQuery) {\n        if (Array.isArray(jsonConfig)) {\n            this.jsonConfig = this.jsonConfigService.make(jsonConfig);\n        }\n        else {\n            this.jsonConfig = jsonConfig;\n        }\n        if (jQuery) {\n            $ = jQuery;\n        }\n        this.tree = new Promise((resolve, reject) => setTimeout(() => resolve(this.treeStore.createTree(this.jsonConfig)), 200));\n        return Promise.all([this.tree, this.nodeDB.nodeDBState.dbReady]).then(([tree, dbReady]) => {\n            if (dbReady) {\n                return tree.positionTree(callback);\n            }\n            return null;\n        });\n    }\n};\nexports.Treant = Treant = __decorate([\n    (0, inversify_1.injectable)(),\n    __param(0, (0, inversify_1.inject)(InjectableList_1.DI_LIST.jsonConfig)),\n    __param(1, (0, inversify_1.inject)(InjectableList_1.DI_LIST.treeStore)),\n    __param(2, (0, inversify_1.inject)(InjectableList_1.DI_LIST.nodeDB))\n], Treant);\n\n\n//# sourceURL=webpack://pointlinejs/./src/pointlinejs/vendor/treant/Treant.ts?");

/***/ }),

/***/ "./src/pointlinejs/vendor/treant/Tree.ts":
/*!***********************************************!*\
  !*** ./src/pointlinejs/vendor/treant/Tree.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Tree = void 0;\nconst Util_1 = __webpack_require__(/*! ./Util */ \"./src/pointlinejs/vendor/treant/Util.ts\");\nconst raphael_no_deps_js_1 = __importDefault(__webpack_require__(/*! ../raphael/raphael.no-deps.js */ \"./src/pointlinejs/vendor/raphael/raphael.no-deps.js\"));\nconst InjectableList_1 = __webpack_require__(/*! ../../InjectableList */ \"./src/pointlinejs/InjectableList.ts\");\nconst inversify_1 = __webpack_require__(/*! inversify */ \"./node_modules/inversify/es/inversify.js\");\nconst jquery_1 = __importDefault(__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"));\nconst perfect_scrollbar_1 = __importDefault(__webpack_require__(/*! perfect-scrollbar */ \"./node_modules/perfect-scrollbar/dist/perfect-scrollbar.esm.js\"));\nlet Tree = exports.Tree = class Tree {\n    constructor(imageLoader, nodeDBClass) {\n        this.imageLoader = imageLoader;\n        this.nodeDBClass = nodeDBClass;\n        this.util = new Util_1.UTIL();\n        this.initTreeId = 0;\n        this.id = 0;\n        this.loaded = false;\n        this.CONFIG = {\n            maxDepth: 100,\n            rootOrientation: 'NORTH',\n            nodeAlign: 'CENTER',\n            levelSeparation: 30,\n            siblingSeparation: 30,\n            subTeeSeparation: 30,\n            hideRootNode: false,\n            animateOnInit: false,\n            animateOnInitDelay: 500,\n            padding: 15,\n            scrollbar: 'native',\n            connectors: {\n                type: 'curve',\n                style: {\n                    stroke: 'black',\n                },\n                stackIndent: 15,\n            },\n            node: {\n                link: {\n                    target: '_self',\n                },\n            },\n            animation: {\n                nodeSpeed: 450,\n                nodeAnimation: 'linear',\n                connectorsSpeed: 450,\n                connectorsAnimation: 'linear',\n            },\n            callback: {\n                onCreateNode: function (treeNode, treeNodeDom) { },\n                onCreateNodeCollapseSwitch: function (treeNode, treeNodeDom, switchDom) { },\n                onAfterAddNode: function (newTreeNode, parentTreeNode, nodeStructure) { },\n                onBeforeAddNode: function (parentTreeNode, nodeStructure) { },\n                onAfterPositionNode: function (treeNode, nodeDbIndex, containerCenter, treeCenter) { },\n                onBeforePositionNode: function (treeNode, nodeDbIndex, containerCenter, treeCenter) { },\n                onToggleCollapseFinished: function (treeNode, bIsCollapsed) { },\n                onAfterClickCollapseSwitch: function (nodeSwitch, event) { },\n                onBeforeClickCollapseSwitch: function (nodeSwitch, event) { },\n                onTreeLoaded: function (rootTreeNode) { },\n            },\n        };\n        this.nodeDB = {};\n    }\n    init(jsonConfig, treeId) {\n        return this.reset(jsonConfig, treeId);\n    }\n    reset(jsonConfig, treeId) {\n        this.initJsonConfig = { ...this.initJsonConfig, ...jsonConfig };\n        this.initTreeId = treeId;\n        this.id = treeId;\n        this.CONFIG = this.util.extend(this.CONFIG, jsonConfig.chart);\n        this.drawArea = this.util.findEl(this.CONFIG.container, true);\n        if (!this.drawArea) {\n            throw new Error('Failed to find element by selector \"' + this.CONFIG.container + '\"');\n        }\n        this.util.addClass(this.drawArea, 'Treant');\n        this.drawArea.innerHTML = '';\n        this.nodeDB = this.nodeDBClass.init(jsonConfig.nodeStructure, this);\n        this.connectionStore = {};\n        this.loaded = false;\n        this._R = (0, raphael_no_deps_js_1.default)(this.drawArea, 100, 100);\n        return this;\n    }\n    reload() {\n        this.reset(this.initJsonConfig, this.initTreeId).redraw();\n        return this;\n    }\n    getNodeDb() {\n        return this.nodeDB;\n    }\n    redraw() {\n        this.positionTree();\n        return this;\n    }\n    positionTree(callback) {\n        var self = this;\n        if (this.imageLoader.isNotLoading() === true) {\n            const root = this.root();\n            this.resetLevelData();\n            this.firstWalk(root, 0);\n            this.secondWalk(root, 0, 0, 0);\n            this.positionNodes();\n            if (this.CONFIG.animateOnInit) {\n                setTimeout(function () {\n                    root.toggleCollapse();\n                }, this.CONFIG.animateOnInitDelay);\n            }\n            if (!this.loaded) {\n                this.util.addClass(this.drawArea, 'Treant-loaded');\n                if (Object.prototype.toString.call(callback) === '[object Function]') {\n                    callback(self);\n                }\n                self.CONFIG.callback.onTreeLoaded.apply(self, [root]);\n                this.loaded = true;\n            }\n        }\n        else {\n            setTimeout(function () {\n                self.positionTree(callback);\n            }, 10);\n        }\n        return this;\n    }\n    firstWalk(node, level) {\n        node.prelim = null;\n        node.modifier = null;\n        node = this.setNeighbors(node, level);\n        this.calcLevelDim(node, level);\n        var leftSibling = node.leftSibling();\n        if (node.childrenCount() === 0 || level === this.CONFIG.maxDepth) {\n            if (leftSibling) {\n                node.prelim =\n                    leftSibling.prelim +\n                        leftSibling.size() +\n                        this.CONFIG.siblingSeparation;\n            }\n            else {\n                node.prelim = 0;\n            }\n        }\n        else {\n            for (var i = 0, n = node.childrenCount(); i < n; i++) {\n                this.firstWalk(node.childAt(i), level + 1);\n            }\n            var midPoint = node.childrenCenter() - node.size() / 2;\n            if (leftSibling) {\n                node.prelim =\n                    leftSibling.prelim +\n                        leftSibling.size() +\n                        this.CONFIG.siblingSeparation;\n                node.modifier = node.prelim - midPoint;\n                this.apportion(node, level);\n            }\n            else {\n                node.prelim = midPoint;\n            }\n            if (node.stackParent) {\n                node.modifier +=\n                    this.nodeDB.get(node.stackChildren[0]).size() / 2 +\n                        node.connStyle.stackIndent;\n            }\n            else if (node.stackParentId) {\n                node.prelim = 0;\n            }\n        }\n        return this;\n    }\n    apportion(node, level) {\n        let firstChild = node.firstChild();\n        var firstChildLeftNeighbor = firstChild.leftNeighbor(), compareDepth = 1, depthToStop = this.CONFIG.maxDepth - level;\n        while (firstChild &&\n            firstChildLeftNeighbor &&\n            compareDepth <= depthToStop) {\n            var modifierSumRight = 0, modifierSumLeft = 0, leftAncestor = firstChildLeftNeighbor, rightAncestor = firstChild;\n            for (var i = 0; i < compareDepth; i++) {\n                leftAncestor = leftAncestor.parent();\n                rightAncestor = rightAncestor.parent();\n                modifierSumLeft += leftAncestor.modifier;\n                modifierSumRight += rightAncestor.modifier;\n                if (rightAncestor.stackParent !== undefined) {\n                    modifierSumRight += rightAncestor.size() / 2;\n                }\n            }\n            var totalGap = firstChildLeftNeighbor.prelim +\n                modifierSumLeft +\n                firstChildLeftNeighbor.size() +\n                this.CONFIG.subTeeSeparation -\n                (firstChild.prelim + modifierSumRight);\n            if (totalGap > 0) {\n                var subtreeAux = node, numSubtrees = 0;\n                while (subtreeAux && subtreeAux.id !== leftAncestor.id) {\n                    subtreeAux = subtreeAux.leftSibling();\n                    numSubtrees++;\n                }\n                if (subtreeAux) {\n                    var subtreeMoveAux = node, singleGap = totalGap / numSubtrees;\n                    while (subtreeMoveAux.id !== leftAncestor.id) {\n                        subtreeMoveAux.prelim += totalGap;\n                        subtreeMoveAux.modifier += totalGap;\n                        totalGap -= singleGap;\n                        subtreeMoveAux = subtreeMoveAux.leftSibling();\n                    }\n                }\n            }\n            compareDepth++;\n            firstChild =\n                firstChild.childrenCount() === 0\n                    ? node.leftMost(0, compareDepth)\n                    : (firstChild = firstChild.firstChild());\n            if (firstChild) {\n                firstChildLeftNeighbor = firstChild.leftNeighbor();\n            }\n        }\n    }\n    secondWalk(node, level, X, Y) {\n        if (level > this.CONFIG.maxDepth) {\n            return;\n        }\n        var xTmp = node.prelim + X, yTmp = Y, align = this.CONFIG.nodeAlign, orient = this.CONFIG.rootOrientation, levelHeight, nodesizeTmp;\n        if (orient === 'NORTH' || orient === 'SOUTH') {\n            levelHeight = this.levelMaxDim[level].height;\n            nodesizeTmp = node.height;\n            if (node.pseudo) {\n                node.height = levelHeight;\n            }\n        }\n        else if (orient === 'WEST' || orient === 'EAST') {\n            levelHeight = this.levelMaxDim[level].width;\n            nodesizeTmp = node.width;\n            if (node.pseudo) {\n                node.width = levelHeight;\n            }\n        }\n        node.X = xTmp;\n        if (node.pseudo) {\n            if (orient === 'NORTH' || orient === 'WEST') {\n                node.Y = yTmp;\n            }\n            else if (orient === 'SOUTH' || orient === 'EAST') {\n                node.Y = yTmp + (levelHeight - nodesizeTmp);\n            }\n        }\n        else {\n            node.Y =\n                align === 'CENTER'\n                    ? yTmp + (levelHeight - nodesizeTmp) / 2\n                    : align === 'TOP'\n                        ? yTmp + (levelHeight - nodesizeTmp)\n                        : yTmp;\n        }\n        if (orient === 'WEST' || orient === 'EAST') {\n            var swapTmp = node.X;\n            node.X = node.Y;\n            node.Y = swapTmp;\n        }\n        if (orient === 'SOUTH') {\n            node.Y = -node.Y - nodesizeTmp;\n        }\n        else if (orient === 'EAST') {\n            node.X = -node.X - nodesizeTmp;\n        }\n        if (node.childrenCount() !== 0) {\n            if (node.id === 0 && this.CONFIG.hideRootNode) {\n                this.secondWalk(node.firstChild(), level + 1, X + node.modifier, Y);\n            }\n            else {\n                this.secondWalk(node.firstChild(), level + 1, X + node.modifier, Y + levelHeight + this.CONFIG.levelSeparation);\n            }\n        }\n        if (node.rightSibling()) {\n            this.secondWalk(node.rightSibling(), level, X, Y);\n        }\n    }\n    positionNodes() {\n        var self = this, treeSize = {\n            x: self.nodeDB.getMinMaxCoord('X', null, null),\n            y: self.nodeDB.getMinMaxCoord('Y', null, null),\n        }, treeWidth = treeSize.x.max - treeSize.x.min, treeHeight = treeSize.y.max - treeSize.y.min, treeCenter = {\n            x: treeSize.x.max - treeWidth / 2,\n            y: treeSize.y.max - treeHeight / 2,\n        };\n        this.handleOverflow(treeWidth, treeHeight);\n        var containerCenter = {\n            x: self.drawArea.clientWidth / 2,\n            y: self.drawArea.clientHeight / 2,\n        }, deltaX = containerCenter.x - treeCenter.x, deltaY = containerCenter.y - treeCenter.y, negOffsetX = treeSize.x.min + deltaX <= 0 ? Math.abs(treeSize.x.min) : 0, negOffsetY = treeSize.y.min + deltaY <= 0 ? Math.abs(treeSize.y.min) : 0, i, len, node;\n        for (i = 0, len = this.nodeDB.size; i < len; i++) {\n            node = this.nodeDB.get(i);\n            self.CONFIG.callback.onBeforePositionNode.apply(self, [\n                node,\n                i,\n                containerCenter,\n                treeCenter,\n            ]);\n            if (node.id === 0 && this.CONFIG.hideRootNode) {\n                self.CONFIG.callback.onAfterPositionNode.apply(self, [\n                    node,\n                    i,\n                    containerCenter,\n                    treeCenter,\n                ]);\n                continue;\n            }\n            node.X +=\n                negOffsetX +\n                    (treeWidth < this.drawArea.clientWidth ? deltaX : this.CONFIG.padding);\n            node.Y +=\n                negOffsetY +\n                    (treeHeight < this.drawArea.clientHeight\n                        ? deltaY\n                        : this.CONFIG.padding);\n            var collapsedParent = node.collapsedParent(), hidePoint = null;\n            if (collapsedParent) {\n                hidePoint = collapsedParent.connectorPoint(true);\n                node.hide(hidePoint);\n            }\n            else if (node.positioned) {\n                node.show();\n            }\n            else {\n                node.nodeDOM.style.left = node.X + 'px';\n                node.nodeDOM.style.top = node.Y + 'px';\n                node.positioned = true;\n            }\n            if (node.id !== 0 &&\n                !(node.parent().id === 0 && this.CONFIG.hideRootNode)) {\n                this.setConnectionToParent(node, hidePoint);\n            }\n            else if (!this.CONFIG.hideRootNode && node.drawLineThrough) {\n                node.drawLineThroughMe();\n            }\n            self.CONFIG.callback.onAfterPositionNode.apply(self, [\n                node,\n                i,\n                containerCenter,\n                treeCenter,\n            ]);\n        }\n        return this;\n    }\n    handleOverflow(treeWidth, treeHeight) {\n        var viewWidth = treeWidth < this.drawArea.clientWidth\n            ? this.drawArea.clientWidth\n            : treeWidth + this.CONFIG.padding * 2, viewHeight = treeHeight < this.drawArea.clientHeight\n            ? this.drawArea.clientHeight\n            : treeHeight + this.CONFIG.padding * 2;\n        this._R.setSize(viewWidth, viewHeight);\n        if (this.CONFIG.scrollbar === 'resize') {\n            this.util.setDimensions(this.drawArea, viewWidth, viewHeight);\n        }\n        else if (!this.util.isjQueryAvailable() ||\n            this.CONFIG.scrollbar === 'native') {\n            if (this.drawArea.clientWidth < treeWidth) {\n                this.drawArea.style.overflowX = 'auto';\n            }\n            if (this.drawArea.clientHeight < treeHeight) {\n                this.drawArea.style.overflowY = 'auto';\n            }\n        }\n        else if (this.CONFIG.scrollbar === 'fancy') {\n            var jq_drawArea = (0, jquery_1.default)(this.drawArea);\n            if (jq_drawArea.hasClass('ps-container')) {\n                jq_drawArea.find('.Treant').css({\n                    width: viewWidth,\n                    height: viewHeight,\n                });\n                const perfectScrollbar = new perfect_scrollbar_1.default(jq_drawArea[0]);\n                perfectScrollbar.update();\n            }\n            else {\n                var mainContainer = jq_drawArea.wrapInner('<div class=\"Treant\"/>'), child = mainContainer.find('.Treant');\n                child.css({\n                    width: viewWidth,\n                    height: viewHeight,\n                });\n                const perfectScrollbar = new perfect_scrollbar_1.default(mainContainer[0]);\n                perfectScrollbar.update();\n            }\n        }\n        return this;\n    }\n    setConnectionToParent(treeNode, hidePoint) {\n        var stacked = treeNode.stackParentId ? true : false, connLine, parent = stacked\n            ? this.nodeDB.get(treeNode.stackParentId)\n            : treeNode.parent(), pathString = hidePoint\n            ? this.getPointPathString(hidePoint)\n            : this.getPathString(parent, treeNode, stacked);\n        if (this.connectionStore[treeNode.id]) {\n            connLine = this.connectionStore[treeNode.id];\n            this.animatePath(connLine, pathString);\n        }\n        else {\n            connLine = this._R.path(pathString);\n            this.connectionStore[treeNode.id] = connLine;\n            if (treeNode.pseudo) {\n                delete parent.connStyle.style['arrow-end'];\n            }\n            if (parent.pseudo) {\n                delete parent.connStyle.style['arrow-start'];\n            }\n            connLine.attr(parent.connStyle.style);\n            if (treeNode.drawLineThrough || treeNode.pseudo) {\n                treeNode.drawLineThroughMe(hidePoint);\n            }\n        }\n        treeNode.connector = connLine;\n        return this;\n    }\n    getPointPathString(hidePoint) {\n        return [\n            '_M',\n            hidePoint.x,\n            ',',\n            hidePoint.y,\n            'L',\n            hidePoint.x,\n            ',',\n            hidePoint.y,\n            hidePoint.x,\n            ',',\n            hidePoint.y,\n        ].join(' ');\n    }\n    animatePath(path, pathString) {\n        if (path.hidden && pathString.charAt(0) !== '_') {\n            path.show();\n            path.hidden = false;\n        }\n        path.animate({\n            path: pathString.charAt(0) === '_' ? pathString.substring(1) : pathString,\n        }, this.CONFIG.animation.connectorsSpeed, this.CONFIG.animation.connectorsAnimation, function () {\n            if (pathString.charAt(0) === '_') {\n                path.hide();\n                path.hidden = true;\n            }\n        });\n        return this;\n    }\n    getPathString(from_node, to_node, stacked) {\n        var startPoint = from_node.connectorPoint(true), endPoint = to_node.connectorPoint(false), orientation = this.CONFIG.rootOrientation, connType = from_node.connStyle.type, P1 = { x: 0, y: 0 }, P2 = { x: 0, y: 0 };\n        if (orientation === 'NORTH' || orientation === 'SOUTH') {\n            P1.y = P2.y = (startPoint.y + endPoint.y) / 2;\n            P1.x = startPoint.x;\n            P2.x = endPoint.x;\n        }\n        else if (orientation === 'EAST' || orientation === 'WEST') {\n            P1.x = P2.x = (startPoint.x + endPoint.x) / 2;\n            P1.y = startPoint.y;\n            P2.y = endPoint.y;\n        }\n        var sp = startPoint.x + ',' + startPoint.y, p1 = P1.x + ',' + P1.y, p2 = P2.x + ',' + P2.y, ep = endPoint.x + ',' + endPoint.y, pm = (P1.x + P2.x) / 2 + ',' + (P1.y + P2.y) / 2, pathString, stackPoint;\n        if (stacked) {\n            stackPoint =\n                orientation === 'EAST' || orientation === 'WEST'\n                    ? endPoint.x + ',' + startPoint.y\n                    : startPoint.x + ',' + endPoint.y;\n            if (connType === 'step' || connType === 'straight') {\n                pathString = ['M', sp, 'L', stackPoint, 'L', ep];\n            }\n            else if (connType === 'curve' || connType === 'bCurve') {\n                var helpPoint, indent = from_node.connStyle.stackIndent;\n                if (orientation === 'NORTH') {\n                    helpPoint = endPoint.x - indent + ',' + (endPoint.y - indent);\n                }\n                else if (orientation === 'SOUTH') {\n                    helpPoint = endPoint.x - indent + ',' + (endPoint.y + indent);\n                }\n                else if (orientation === 'EAST') {\n                    helpPoint = endPoint.x + indent + ',' + startPoint.y;\n                }\n                else if (orientation === 'WEST') {\n                    helpPoint = endPoint.x - indent + ',' + startPoint.y;\n                }\n                pathString = ['M', sp, 'L', helpPoint, 'S', stackPoint, ep];\n            }\n        }\n        else {\n            if (connType === 'step') {\n                pathString = ['M', sp, 'L', p1, 'L', p2, 'L', ep];\n            }\n            else if (connType === 'curve') {\n                pathString = ['M', sp, 'C', p1, p2, ep];\n            }\n            else if (connType === 'bCurve') {\n                pathString = ['M', sp, 'Q', p1, pm, 'T', ep];\n            }\n            else if (connType === 'straight') {\n                pathString = ['M', sp, 'L', sp, ep];\n            }\n        }\n        return pathString.join(' ');\n    }\n    setNeighbors(node, level) {\n        node.leftNeighborId = this.lastNodeOnLevel[level];\n        if (node.leftNeighborId) {\n            node.leftNeighbor().rightNeighborId = node.id;\n        }\n        this.lastNodeOnLevel[level] = node.id;\n        return node;\n    }\n    calcLevelDim(node, level) {\n        this.levelMaxDim[level] = {\n            width: Math.max(this.levelMaxDim[level] ? this.levelMaxDim[level].width : 0, node.width),\n            height: Math.max(this.levelMaxDim[level] ? this.levelMaxDim[level].height : 0, node.height),\n        };\n    }\n    resetLevelData() {\n        this.lastNodeOnLevel = [];\n        this.levelMaxDim = [];\n        return this;\n    }\n    root() {\n        return this.nodeDB.get(0);\n    }\n};\nexports.Tree = Tree = __decorate([\n    (0, inversify_1.injectable)(),\n    __param(0, (0, inversify_1.inject)(InjectableList_1.DI_LIST.imageLoader)),\n    __param(1, (0, inversify_1.inject)(InjectableList_1.DI_LIST.nodeDB))\n], Tree);\n\n\n//# sourceURL=webpack://pointlinejs/./src/pointlinejs/vendor/treant/Tree.ts?");

/***/ }),

/***/ "./src/pointlinejs/vendor/treant/TreeNode.ts":
/*!***************************************************!*\
  !*** ./src/pointlinejs/vendor/treant/TreeNode.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TreeNode = void 0;\nconst inversify_1 = __webpack_require__(/*! inversify */ \"./node_modules/inversify/es/inversify.js\");\nconst Util_1 = __webpack_require__(/*! ./Util */ \"./src/pointlinejs/vendor/treant/Util.ts\");\nconst jquery_1 = __importDefault(__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"));\nlet TreeNode = exports.TreeNode = class TreeNode {\n    constructor(tree) {\n        this.tree = tree;\n        this.util = new Util_1.UTIL();\n        this.CONFIG = {\n            nodeHTMLclass: 'node',\n        };\n        this.stackParent = undefined;\n    }\n    init(nodeStructure, id, parentId, tree, stackParentId) {\n        return this.reset(nodeStructure, id, parentId, tree, stackParentId);\n    }\n    reset(nodeStructure, id, parentId, tree, stackParentId) {\n        this.id = id;\n        this.parentId = parentId;\n        this.treeId = tree.id;\n        this.prelim = 0;\n        this.modifier = 0;\n        this.leftNeighborId = null;\n        this.stackParentId = stackParentId;\n        this.pseudo = nodeStructure === 'pseudo' || nodeStructure['pseudo'];\n        if (typeof this.pseudo === 'undefined' || this.pseudo !== false) {\n            const nodeStructureValue = nodeStructure;\n            this.meta = nodeStructureValue.meta || {};\n            this.image = nodeStructureValue.image || null;\n            this.connStyle = this.util.createMerge(tree.CONFIG.connectors, nodeStructureValue.connectors);\n            this.drawLineThrough =\n                nodeStructureValue.drawLineThrough === false\n                    ? false\n                    : nodeStructureValue.drawLineThrough ||\n                        tree.CONFIG.node.drawLineThrough;\n            this.collapsable =\n                nodeStructureValue.collapsable === false\n                    ? false\n                    : nodeStructureValue.collapsable || tree.CONFIG.node.collapsable;\n            this.collapsed = nodeStructureValue.collapsed;\n            this.text = nodeStructureValue.text;\n            this.nodeInnerHTML = nodeStructureValue.innerHTML;\n            this.nodeHTMLclass =\n                (tree.CONFIG.node.HTMLclass ? tree.CONFIG.node.HTMLclass : '') +\n                    (nodeStructureValue.HTMLclass\n                        ? ' ' + nodeStructureValue.HTMLclass\n                        : '');\n            this.nodeHTMLid = parseInt(nodeStructureValue.HTMLid, 10);\n        }\n        this.link = this.util.createMerge(tree.CONFIG.node.link, nodeStructure.link);\n        this.connector = null;\n        this.children = [];\n        return this;\n    }\n    getTreeConfig() {\n        return this.getTree().CONFIG;\n    }\n    getTreeNodeDb() {\n        return this.getTree().getNodeDb();\n    }\n    lookupNode(nodeId) {\n        return this.getTreeNodeDb().get(nodeId);\n    }\n    getTree() {\n        return this.tree;\n    }\n    dbGet(nodeId) {\n        return this.getTreeNodeDb().get(nodeId);\n    }\n    size() {\n        const orientation = this.getTreeConfig().rootOrientation;\n        if (this.pseudo) {\n            return -1 * this.getTreeConfig().subTeeSeparation;\n        }\n        if (orientation === 'NORTH' || orientation === 'SOUTH') {\n            return this.width;\n        }\n        else if (orientation === 'WEST' || orientation === 'EAST') {\n            return this.height;\n        }\n        return 0;\n    }\n    childrenCount() {\n        return this.collapsed || !this.children ? 0 : this.children.length;\n    }\n    childAt(index) {\n        return this.dbGet(this.children[index]);\n    }\n    firstChild() {\n        return this.childAt(0);\n    }\n    lastChild() {\n        return this.childAt(this.children.length - 1);\n    }\n    parent() {\n        return this.lookupNode(this.parentId);\n    }\n    leftNeighbor() {\n        if (this.leftNeighborId) {\n            return this.lookupNode(this.leftNeighborId);\n        }\n        return null;\n    }\n    rightNeighbor() {\n        if (this.rightNeighborId) {\n            return this.lookupNode(this.rightNeighborId);\n        }\n        return null;\n    }\n    leftSibling() {\n        const leftNeighbor = this.leftNeighbor();\n        if (leftNeighbor && leftNeighbor.parentId === this.parentId) {\n            return leftNeighbor;\n        }\n        return null;\n    }\n    rightSibling() {\n        var rightNeighbor = this.rightNeighbor();\n        if (rightNeighbor && rightNeighbor.parentId === this.parentId) {\n            return rightNeighbor;\n        }\n        return null;\n    }\n    childrenCenter() {\n        var first = this.firstChild(), last = this.lastChild();\n        return first.prelim + (last.prelim - first.prelim + last.size()) / 2;\n    }\n    collapsedParent() {\n        var parent = this.parent();\n        if (!parent) {\n            return false;\n        }\n        if (parent.collapsed) {\n            return parent;\n        }\n        return parent.collapsedParent();\n    }\n    leftMost(level, depth) {\n        if (level >= depth) {\n            return this;\n        }\n        if (this.childrenCount() === 0) {\n            return null;\n        }\n        for (var i = 0, n = this.childrenCount(); i < n; i++) {\n            var leftmostDescendant = this.childAt(i).leftMost(level + 1, depth);\n            if (leftmostDescendant) {\n                return leftmostDescendant;\n            }\n        }\n        return null;\n    }\n    connectorPoint(startPoint) {\n        let orient = this.getTree().CONFIG.rootOrientation;\n        const point = { x: 0, y: 0 };\n        if (this.stackParentId) {\n            if (orient === 'NORTH' || orient === 'SOUTH') {\n                orient = 'WEST';\n            }\n            else if (orient === 'EAST' || orient === 'WEST') {\n                orient = 'NORTH';\n            }\n        }\n        if (orient === 'NORTH') {\n            point.x = this.pseudo\n                ? this.X - this.getTree().CONFIG.subTeeSeparation / 2\n                : this.X + this.width / 2;\n            point.y = startPoint ? this.Y + this.height : this.Y;\n        }\n        else if (orient === 'SOUTH') {\n            point.x = this.pseudo\n                ? this.X - this.getTree().CONFIG.subTeeSeparation / 2\n                : this.X + this.width / 2;\n            point.y = startPoint ? this.Y : this.Y + this.height;\n        }\n        else if (orient === 'EAST') {\n            point.x = startPoint ? this.X : this.X + this.width;\n            point.y = this.pseudo\n                ? this.Y - this.getTree().CONFIG.subTeeSeparation / 2\n                : this.Y + this.height / 2;\n        }\n        else if (orient === 'WEST') {\n            point.x = startPoint ? this.X + this.width : this.X;\n            point.y = this.pseudo\n                ? this.Y - this.getTree().CONFIG.subTeeSeparation / 2\n                : this.Y + this.height / 2;\n        }\n        return point;\n    }\n    pathStringThrough() {\n        var startPoint = this.connectorPoint(true), endPoint = this.connectorPoint(false);\n        return [\n            'M',\n            startPoint.x + ',' + startPoint.y,\n            'L',\n            endPoint.x + ',' + endPoint.y,\n        ].join(' ');\n    }\n    drawLineThroughMe(hidePoint) {\n        var pathString = hidePoint\n            ? this.getTree().getPointPathString(hidePoint)\n            : this.pathStringThrough();\n        this.lineThroughMe =\n            this.lineThroughMe || this.getTree()._R.path(pathString);\n        const line_style = this.util.cloneObj(this.connStyle.style);\n        delete line_style['arrow-start'];\n        delete line_style['arrow-end'];\n        this.lineThroughMe.attr(line_style);\n        if (hidePoint) {\n            this.lineThroughMe.hide();\n            this.lineThroughMe.hidden = true;\n        }\n    }\n    addSwitchEvent(nodeSwitch) {\n        var self = this;\n        this.util.addEvent(nodeSwitch, 'click', (e) => {\n            e.preventDefault();\n            if (self\n                .getTreeConfig()\n                .callback.onBeforeClickCollapseSwitch.apply(self, [\n                nodeSwitch,\n                e,\n            ]) === false) {\n                return false;\n            }\n            self.toggleCollapse();\n            self\n                .getTreeConfig()\n                .callback.onAfterClickCollapseSwitch.apply(self, [nodeSwitch, e]);\n        });\n    }\n    collapse() {\n        if (!this.collapsed) {\n            this.toggleCollapse();\n        }\n        return this;\n    }\n    expand() {\n        if (this.collapsed) {\n            this.toggleCollapse();\n        }\n        return this;\n    }\n    toggleCollapse() {\n        const oTree = this.getTree();\n        if (!oTree.inAnimation) {\n            oTree.inAnimation = true;\n            this.collapsed = !this.collapsed;\n            this.util.toggleClass(this.nodeDOM, 'collapsed', this.collapsed);\n            oTree.positionTree();\n            var self = this;\n            setTimeout((oTree) => {\n                oTree.inAnimation = false;\n                oTree.CONFIG.callback.onToggleCollapseFinished.apply(oTree, [\n                    self,\n                    self.collapsed,\n                ]);\n            }, oTree.CONFIG.animation.nodeSpeed >\n                oTree.CONFIG.animation.connectorsSpeed\n                ? oTree.CONFIG.animation.nodeSpeed\n                : oTree.CONFIG.animation.connectorsSpeed, oTree);\n        }\n        return this;\n    }\n    hide(collapse_to_point) {\n        var bCurrentState = this.hidden;\n        this.hidden = true;\n        this.nodeDOM.style.overflow = 'hidden';\n        var tree = this.getTree(), config = this.getTreeConfig(), oNewState = {\n            opacity: '0',\n        };\n        if (collapse_to_point) {\n            oNewState['left'] = collapse_to_point.x.toString();\n            oNewState['top'] = collapse_to_point.y.toString();\n        }\n        if (!this.positioned || bCurrentState) {\n            this.nodeDOM.style.visibility = 'hidden';\n            if (jquery_1.default) {\n                (0, jquery_1.default)(this.nodeDOM).css(oNewState);\n            }\n            else {\n                this.nodeDOM.style.left = oNewState['left'] + 'px';\n                this.nodeDOM.style.top = oNewState['top'] + 'px';\n            }\n            this.positioned = true;\n        }\n        else {\n            if (jquery_1.default) {\n                (0, jquery_1.default)(this.nodeDOM).animate(oNewState, config.animation.nodeSpeed, config.animation.nodeAnimation, function () {\n                    this.style.visibility = 'hidden';\n                });\n            }\n            else {\n                this.nodeDOM.style.transition =\n                    'all ' + config.animation.nodeSpeed + 'ms ease';\n                this.nodeDOM.style.transitionProperty = 'opacity, left, top';\n                this.nodeDOM.style.opacity = oNewState['opacity'].toString();\n                this.nodeDOM.style.left = oNewState['left'] + 'px';\n                this.nodeDOM.style.top = oNewState['top'] + 'px';\n                this.nodeDOM.style.visibility = 'hidden';\n            }\n        }\n        if (this.lineThroughMe) {\n            var new_path = tree.getPointPathString(collapse_to_point);\n            if (bCurrentState) {\n                this.lineThroughMe.attr({ path: new_path });\n            }\n            else {\n                tree.animatePath(this.lineThroughMe, tree.getPointPathString(collapse_to_point));\n            }\n        }\n        return this;\n    }\n    hideConnector() {\n        var oTree = this.getTree();\n        var oPath = oTree.connectionStore[this.id];\n        if (oPath) {\n            oPath.animate({ opacity: 0 }, oTree.CONFIG.animation.connectorsSpeed, oTree.CONFIG.animation.connectorsAnimation);\n        }\n        return this;\n    }\n    show() {\n        this.hidden = false;\n        this.nodeDOM.style.visibility = 'visible';\n        var oNewState = {\n            left: this.X,\n            top: this.Y,\n            opacity: 1,\n        };\n        const config = this.getTreeConfig();\n        if (jquery_1.default) {\n            (0, jquery_1.default)(this.nodeDOM).animate(oNewState, config.animation.nodeSpeed, config.animation.nodeAnimation, function () {\n                this.style.overflow = '';\n            });\n        }\n        else {\n            this.nodeDOM.style.transition =\n                'all ' + config.animation.nodeSpeed + 'ms ease';\n            this.nodeDOM.style.transitionProperty = 'opacity, left, top';\n            this.nodeDOM.style.left = oNewState.left + 'px';\n            this.nodeDOM.style.top = oNewState.top + 'px';\n            this.nodeDOM.style.opacity = oNewState.opacity.toString();\n            this.nodeDOM.style.overflow = '';\n        }\n        if (this.lineThroughMe) {\n            this.getTree().animatePath(this.lineThroughMe, this.pathStringThrough());\n        }\n        return this;\n    }\n    showConnector() {\n        var oTree = this.getTree();\n        var oPath = oTree.connectionStore[this.id];\n        if (oPath) {\n            oPath.animate({ opacity: 1 }, oTree.CONFIG.animation.connectorsSpeed, oTree.CONFIG.animation.connectorsAnimation);\n        }\n        return this;\n    }\n    buildNodeFromText(node) {\n        if (this.image) {\n            const image = document.createElement('img');\n            image.src = this.image;\n            node.appendChild(image);\n        }\n        if (this.text) {\n            for (var key in this.text) {\n                const keyTyped = key;\n                if (key.startsWith('data-')) {\n                    node.setAttribute(key, this.text[keyTyped]);\n                }\n                else {\n                    let textValue;\n                    let href;\n                    let target;\n                    let val;\n                    if (typeof this.text[keyTyped] === 'object') {\n                        textValue = this.text[keyTyped];\n                        href = textValue['href'];\n                        target = textValue['target'];\n                        val = textValue['val'];\n                    }\n                    else {\n                        textValue = this.text[keyTyped];\n                    }\n                    var textElement = document.createElement(href ? 'a' : 'p');\n                    if (href) {\n                        textElement.href = href;\n                        if (target) {\n                            textElement.target = target;\n                        }\n                    }\n                    textElement.className = 'node-' + key;\n                    textElement.appendChild(document.createTextNode(val\n                        ? val\n                        : textValue instanceof Object\n                            ? \"'val' param missing!\"\n                            : this.text[keyTyped]));\n                    node.appendChild(textElement);\n                }\n            }\n        }\n        return node;\n    }\n    buildNodeFromHtml(node) {\n        if (this.nodeInnerHTML.charAt(0) === '#') {\n            var elem = document.getElementById(this.nodeInnerHTML.substring(1));\n            if (elem) {\n                if (node instanceof HTMLAnchorElement) {\n                    node = elem.cloneNode(true);\n                }\n                if (node instanceof HTMLDivElement) {\n                    node = elem.cloneNode(true);\n                }\n                node.id += '-clone';\n                node.className += ' node';\n            }\n            else {\n                node.innerHTML = '<b> Wrong ID selector </b>';\n            }\n        }\n        else {\n            node.innerHTML = this.nodeInnerHTML;\n        }\n        return node;\n    }\n    createGeometry(tree) {\n        if (this.id === 0 && tree.CONFIG.hideRootNode) {\n            this.width = 0;\n            this.height = 0;\n            return;\n        }\n        var drawArea = tree.drawArea;\n        let node = document.createElement(this.link.href ? 'a' : 'div');\n        node.className = !this.pseudo ? this.CONFIG.nodeHTMLclass : 'pseudo';\n        if (this.nodeHTMLclass && !this.pseudo) {\n            node.className += ' ' + this.nodeHTMLclass;\n        }\n        if (this.nodeHTMLid) {\n            node.id = this.nodeHTMLid\n                ? this.nodeHTMLid.toString()\n                : this.id.toString();\n        }\n        if (this.link.href && node instanceof HTMLAnchorElement) {\n            node.href = this.link.href;\n            node.target = this.link.target;\n        }\n        if (jquery_1.default) {\n            (0, jquery_1.default)(node).data('treenode', this);\n        }\n        else {\n            node.setAttribute('data', JSON.stringify({\n                treenode: this,\n            }));\n        }\n        if (!this.pseudo) {\n            node = this.nodeInnerHTML\n                ? this.buildNodeFromHtml(node)\n                : this.buildNodeFromText(node);\n            if (this.collapsed ||\n                (this.collapsable && this.childrenCount() && !this.stackParentId)) {\n                this.createSwitchGeometry(tree, node);\n            }\n        }\n        tree.CONFIG.callback.onCreateNode.apply(tree, [this, node]);\n        drawArea.appendChild(node);\n        this.width = node.offsetWidth;\n        this.height = node.offsetHeight;\n        this.nodeDOM = node;\n        tree.imageLoader.processNode(this);\n    }\n    createSwitchGeometry(tree, nodeEl) {\n        nodeEl = nodeEl || this.nodeDOM;\n        var nodeSwitchEl = this.util.findEl('.collapse-switch', true, nodeEl);\n        if (!nodeSwitchEl) {\n            nodeSwitchEl = document.createElement('a');\n            nodeSwitchEl.className = 'collapse-switch';\n            nodeEl.appendChild(nodeSwitchEl);\n            this.addSwitchEvent(nodeSwitchEl);\n            if (this.collapsed) {\n                nodeEl.className += ' collapsed';\n            }\n            tree.CONFIG.callback.onCreateNodeCollapseSwitch.apply(tree, [\n                this,\n                nodeEl,\n                nodeSwitchEl,\n            ]);\n        }\n        return nodeSwitchEl;\n    }\n};\nexports.TreeNode = TreeNode = __decorate([\n    (0, inversify_1.injectable)()\n], TreeNode);\n\n\n//# sourceURL=webpack://pointlinejs/./src/pointlinejs/vendor/treant/TreeNode.ts?");

/***/ }),

/***/ "./src/pointlinejs/vendor/treant/TreeStore.ts":
/*!****************************************************!*\
  !*** ./src/pointlinejs/vendor/treant/TreeStore.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TreeStore = void 0;\nconst inversify_1 = __webpack_require__(/*! inversify */ \"./node_modules/inversify/es/inversify.js\");\n__webpack_require__(/*! reflect-metadata */ \"./node_modules/reflect-metadata/Reflect.js\");\nconst InjectableList_1 = __webpack_require__(/*! ../../InjectableList */ \"./src/pointlinejs/InjectableList.ts\");\nlet TreeStore = exports.TreeStore = class TreeStore {\n    constructor(tree) {\n        this.tree = tree;\n        this.store = [];\n    }\n    createTree(jsonConfig) {\n        var nNewTreeId = this.store.length;\n        this.store.push(this.tree.init(jsonConfig, nNewTreeId));\n        return this.get(nNewTreeId);\n    }\n    get(treeId) {\n        return this.store[treeId];\n    }\n    destroy(treeId) {\n        var tree = this.get(treeId);\n        if (tree) {\n            tree._R.remove();\n            var draw_area = tree.drawArea;\n            while (draw_area.firstChild) {\n                draw_area.removeChild(draw_area.firstChild);\n            }\n            var classes = draw_area.className.split(' '), classes_to_stay = [];\n            for (var i = 0; i < classes.length; i++) {\n                var cls = classes[i];\n                if (cls !== 'Treant' && cls !== 'Treant-loaded') {\n                    classes_to_stay.push(cls);\n                }\n            }\n            draw_area.style.overflowY = '';\n            draw_area.style.overflowX = '';\n            draw_area.className = classes_to_stay.join(' ');\n            this.store[treeId] = null;\n        }\n        return this;\n    }\n};\nexports.TreeStore = TreeStore = __decorate([\n    (0, inversify_1.injectable)(),\n    __param(0, (0, inversify_1.inject)(InjectableList_1.DI_LIST.tree))\n], TreeStore);\n\n\n//# sourceURL=webpack://pointlinejs/./src/pointlinejs/vendor/treant/TreeStore.ts?");

/***/ }),

/***/ "./src/pointlinejs/vendor/treant/Util.ts":
/*!***********************************************!*\
  !*** ./src/pointlinejs/vendor/treant/Util.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UTIL = void 0;\nconst inversify_1 = __webpack_require__(/*! inversify */ \"./node_modules/inversify/es/inversify.js\");\nconst jquery_1 = __importDefault(__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"));\nlet UTIL = exports.UTIL = class UTIL {\n    inheritAttrs(applyTo, applyFrom) {\n        for (var attr in applyFrom) {\n            if (applyFrom.hasOwnProperty(attr)) {\n                if (typeof applyTo[attr] === 'object' &&\n                    typeof applyFrom[attr] === 'object' &&\n                    typeof applyFrom[attr] !== 'function') {\n                    this.inheritAttrs(applyTo[attr], applyFrom[attr]);\n                }\n                else {\n                    applyTo[attr] = applyFrom[attr];\n                }\n            }\n        }\n        return applyTo;\n    }\n    createMerge(obj1, obj2) {\n        var newObj = {};\n        if (obj1) {\n            this.inheritAttrs(newObj, this.cloneObj(obj1));\n        }\n        if (obj2) {\n            this.inheritAttrs(newObj, obj2);\n        }\n        return newObj;\n    }\n    extend(...args) {\n        if (typeof jquery_1.default !== 'undefined') {\n            Array.prototype.unshift.apply(args, [true, {}]);\n            return jquery_1.default.extend.apply(jquery_1.default, args);\n        }\n        else {\n            return this.createMerge.apply(this, args);\n        }\n    }\n    cloneObj(obj) {\n        if (Object(obj) !== obj) {\n            return obj;\n        }\n        var res = new obj.constructor();\n        for (var key in obj) {\n            if (typeof obj === 'object' && obj.hasOwnProperty(key)) {\n                res[key] = this.cloneObj(obj[key]);\n            }\n        }\n        return res;\n    }\n    addEvent(el, eventType, handler) {\n        if (jquery_1.default) {\n            (0, jquery_1.default)(el).on(eventType + '.treant', handler);\n        }\n        else if (el.addEventListener) {\n            el.addEventListener(eventType, handler, false);\n        }\n        else if (el['attachEvent']) {\n            let elementInOldIE = el;\n            elementInOldIE.attachEvent('on' + eventType, handler);\n        }\n        else {\n            el['on' + eventType] = handler;\n        }\n    }\n    findEl(selector, raw, parentEl) {\n        const element = parentEl || window.document;\n        if (jquery_1.default) {\n            var $element = (0, jquery_1.default)(selector, parentEl);\n            return raw ? $element.get(0) : $element;\n        }\n        else {\n            if (selector.charAt(0) === '#') {\n                return element.getElementById(selector.substring(1));\n            }\n            else if (selector.charAt(0) === '.') {\n                var oElements = element.getElementsByClassName(selector.substring(1));\n                return oElements.length ? oElements[0] : null;\n            }\n            throw new Error('Unknown container element');\n        }\n    }\n    getOuterHeight(element) {\n        var nRoundingCompensation = 1;\n        if (typeof element.getBoundingClientRect === 'function') {\n            return element.getBoundingClientRect().height;\n        }\n        else if (jquery_1.default) {\n            return Math.ceil((0, jquery_1.default)(element).outerHeight()) + nRoundingCompensation;\n        }\n        else {\n            return Math.ceil(element.clientHeight +\n                this.getStyle(element, 'border-top-width', true) +\n                this.getStyle(element, 'border-bottom-width', true) +\n                this.getStyle(element, 'padding-top', true) +\n                this.getStyle(element, 'padding-bottom', true) +\n                nRoundingCompensation);\n        }\n    }\n    getOuterWidth(element) {\n        var nRoundingCompensation = 1;\n        if (typeof element.getBoundingClientRect === 'function') {\n            return element.getBoundingClientRect().width;\n        }\n        else if (jquery_1.default) {\n            return Math.ceil((0, jquery_1.default)(element).outerWidth()) + nRoundingCompensation;\n        }\n        else {\n            return Math.ceil(element.clientWidth +\n                this.getStyle(element, 'border-left-width', true) +\n                this.getStyle(element, 'border-right-width', true) +\n                this.getStyle(element, 'padding-left', true) +\n                this.getStyle(element, 'padding-right', true) +\n                nRoundingCompensation);\n        }\n    }\n    getStyle(element, strCssRule, asInt) {\n        var strValue = '';\n        if (document.defaultView && document.defaultView.getComputedStyle) {\n            strValue = document.defaultView\n                .getComputedStyle(element, '')\n                .getPropertyValue(strCssRule);\n        }\n        else if (element.currentStyle) {\n            strCssRule = strCssRule.replace(/\\-(\\w)/g, function (strMatch, p1) {\n                return p1.toUpperCase();\n            });\n            strValue = element.currentStyle[strCssRule];\n        }\n        return asInt ? parseFloat(strValue) : strValue;\n    }\n    addClass(element, cssClass) {\n        if (jquery_1.default) {\n            (0, jquery_1.default)(element).addClass(cssClass);\n        }\n        else {\n            if (!this.hasClass(element, cssClass)) {\n                if (element.classList) {\n                    element.classList.add(cssClass);\n                }\n                else {\n                    element.className += ' ' + cssClass;\n                }\n            }\n        }\n    }\n    hasClass(element, my_class) {\n        return ((' ' + element.className + ' ')\n            .replace(/[\\n\\t]/g, ' ')\n            .indexOf(' ' + my_class + ' ') > -1);\n    }\n    toggleClass(element, cls, apply) {\n        if (jquery_1.default) {\n            (0, jquery_1.default)(element).toggleClass(cls, apply);\n        }\n        else {\n            if (apply) {\n                element.classList.add(cls);\n            }\n            else {\n                element.classList.remove(cls);\n            }\n        }\n    }\n    setDimensions(element, width, height) {\n        if (jquery_1.default) {\n            (0, jquery_1.default)(element).width(width).height(height);\n        }\n        else {\n            element.style.width = width + 'px';\n            element.style.height = height + 'px';\n        }\n    }\n    isjQueryAvailable() {\n        return typeof jquery_1.default !== 'undefined' && jquery_1.default;\n    }\n};\nexports.UTIL = UTIL = __decorate([\n    (0, inversify_1.injectable)()\n], UTIL);\n\n\n//# sourceURL=webpack://pointlinejs/./src/pointlinejs/vendor/treant/Util.ts?");

/***/ }),

/***/ "./src/pointlinejs/vendor/raphael/raphael.no-deps.js":
/*!***********************************************************!*\
  !*** ./src/pointlinejs/vendor/raphael/raphael.no-deps.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// ┌───────────────────────────────────────────────────────────────────────────────────────────────────────┐ \\\\\r\n// │ Raphaël 2.3.0 - JavaScript Vector Library                                                             │ \\\\\r\n// ├───────────────────────────────────────────────────────────────────────────────────────────────────────┤ \\\\\r\n// │ Copyright © 2008-2016 Dmitry Baranovskiy (http://raphaeljs.com)                                       │ \\\\\r\n// │ Copyright © 2008-2016 Sencha Labs (http://sencha.com)                                                 │ \\\\\r\n// ├───────────────────────────────────────────────────────────────────────────────────────────────────────┤ \\\\\r\n// │ Licensed under the MIT (https://github.com/DmitryBaranovskiy/raphael/blob/master/license.txt) license.│ \\\\\r\n// └───────────────────────────────────────────────────────────────────────────────────────────────────────┘ \\\\\r\n\r\n(function webpackUniversalModuleDefinition(root, factory) {\r\n  if (true)\r\n    module.exports = factory(__webpack_require__(/*! eve */ \"./node_modules/eve-raphael/eve.js\"));\r\n  else {}\r\n})(window, function (__WEBPACK_EXTERNAL_MODULE_eve__) {\r\n  return /******/ (function (modules) {\r\n    // webpackBootstrap\r\n    /******/ // The module cache\r\n    /******/ var installedModules = {};\r\n    /******/\r\n    /******/ // The require function\r\n    /******/ function __nested_webpack_require_1565__(moduleId) {\r\n      /******/\r\n      /******/ // Check if module is in cache\r\n      /******/ if (installedModules[moduleId]) {\r\n        /******/ return installedModules[moduleId].exports;\r\n        /******/\r\n      }\r\n      /******/ // Create a new module (and put it into the cache)\r\n      /******/ var module = (installedModules[moduleId] = {\r\n        /******/ i: moduleId,\r\n        /******/ l: false,\r\n        /******/ exports: {},\r\n        /******/\r\n      });\r\n      /******/\r\n      /******/ // Execute the module function\r\n      /******/ modules[moduleId].call(\r\n        module.exports,\r\n        module,\r\n        module.exports,\r\n        __nested_webpack_require_1565__\r\n      );\r\n      /******/\r\n      /******/ // Flag the module as loaded\r\n      /******/ module.l = true;\r\n      /******/\r\n      /******/ // Return the exports of the module\r\n      /******/ return module.exports;\r\n      /******/\r\n    }\r\n    /******/\r\n    /******/\r\n    /******/ // expose the modules object (__webpack_modules__)\r\n    /******/ __nested_webpack_require_1565__.m = modules;\r\n    /******/\r\n    /******/ // expose the module cache\r\n    /******/ __nested_webpack_require_1565__.c = installedModules;\r\n    /******/\r\n    /******/ // define getter function for harmony exports\r\n    /******/ __nested_webpack_require_1565__.d = function (exports, name, getter) {\r\n      /******/ if (!__nested_webpack_require_1565__.o(exports, name)) {\r\n        /******/ Object.defineProperty(exports, name, {\r\n          enumerable: true,\r\n          get: getter,\r\n        });\r\n        /******/\r\n      }\r\n      /******/\r\n    };\r\n    /******/\r\n    /******/ // define __esModule on exports\r\n    /******/ __nested_webpack_require_1565__.r = function (exports) {\r\n      /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\r\n        /******/ Object.defineProperty(exports, Symbol.toStringTag, {\r\n          value: 'Module',\r\n        });\r\n        /******/\r\n      }\r\n      /******/ Object.defineProperty(exports, '__esModule', { value: true });\r\n      /******/\r\n    };\r\n    /******/\r\n    /******/ // create a fake namespace object\r\n    /******/ // mode & 1: value is a module id, require it\r\n    /******/ // mode & 2: merge all properties of value into the ns\r\n    /******/ // mode & 4: return value when already ns object\r\n    /******/ // mode & 8|1: behave like require\r\n    /******/ __nested_webpack_require_1565__.t = function (value, mode) {\r\n      /******/ if (mode & 1) value = __nested_webpack_require_1565__(value);\r\n      /******/ if (mode & 8) return value;\r\n      /******/ if (\r\n        mode & 4 &&\r\n        typeof value === 'object' &&\r\n        value &&\r\n        value.__esModule\r\n      )\r\n        return value;\r\n      /******/ var ns = Object.create(null);\r\n      /******/ __nested_webpack_require_1565__.r(ns);\r\n      /******/ Object.defineProperty(ns, 'default', {\r\n        enumerable: true,\r\n        value: value,\r\n      });\r\n      /******/ if (mode & 2 && typeof value != 'string')\r\n        for (var key in value)\r\n          __nested_webpack_require_1565__.d(\r\n            ns,\r\n            key,\r\n            function (key) {\r\n              return value[key];\r\n            }.bind(null, key)\r\n          );\r\n      /******/ return ns;\r\n      /******/\r\n    };\r\n    /******/\r\n    /******/ // getDefaultExport function for compatibility with non-harmony modules\r\n    /******/ __nested_webpack_require_1565__.n = function (module) {\r\n      /******/ var getter =\r\n        module && module.__esModule\r\n          ? /******/ function getDefault() {\r\n              return module['default'];\r\n            }\r\n          : /******/ function getModuleExports() {\r\n              return module;\r\n            };\r\n      /******/ __nested_webpack_require_1565__.d(getter, 'a', getter);\r\n      /******/ return getter;\r\n      /******/\r\n    };\r\n    /******/\r\n    /******/ // Object.prototype.hasOwnProperty.call\r\n    /******/ __nested_webpack_require_1565__.o = function (object, property) {\r\n      return Object.prototype.hasOwnProperty.call(object, property);\r\n    };\r\n    /******/\r\n    /******/ // __webpack_public_path__\r\n    /******/ __nested_webpack_require_1565__.p = '';\r\n    /******/\r\n    /******/\r\n    /******/ // Load entry module and return exports\r\n    /******/ return __nested_webpack_require_1565__(\r\n      (__nested_webpack_require_1565__.s = './dev/raphael.amd.js')\r\n    );\r\n    /******/\r\n  })(\r\n    /************************************************************************/\r\n    /******/ {\r\n      /***/ './dev/raphael.amd.js':\r\n        /*!****************************!*\\\r\n  !*** ./dev/raphael.amd.js ***!\r\n  \\****************************/\r\n        /*! no static exports found */\r\n        /***/ function (module, exports, __nested_webpack_require_6098__) {\r\n          var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\r\n          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n            __nested_webpack_require_6098__(/*! ./raphael.core */ './dev/raphael.core.js'),\r\n            __nested_webpack_require_6098__(/*! ./raphael.svg */ './dev/raphael.svg.js'),\r\n            __nested_webpack_require_6098__(/*! ./raphael.vml */ './dev/raphael.vml.js'),\r\n          ]),\r\n          (__WEBPACK_AMD_DEFINE_RESULT__ = function (R) {\r\n            return R;\r\n          }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)),\r\n          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&\r\n            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n          /***/\r\n        },\r\n\r\n      /***/ './dev/raphael.core.js':\r\n        /*!*****************************!*\\\r\n  !*** ./dev/raphael.core.js ***!\r\n  \\*****************************/\r\n        /*! no static exports found */\r\n        /***/ function (module, exports, __nested_webpack_require_7030__) {\r\n          var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\r\n          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n            __nested_webpack_require_7030__(/*! eve */ 'eve'),\r\n          ]),\r\n          (__WEBPACK_AMD_DEFINE_RESULT__ = function (eve) {\r\n            /*\\\r\n     * Raphael\r\n     [ method ]\r\n     **\r\n     * Creates a canvas object on which to draw.\r\n     * You must do this first, as all future calls to drawing methods\r\n     * from this instance will be bound to this canvas.\r\n     > Parameters\r\n     **\r\n     - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface\r\n     - width (number)\r\n     - height (number)\r\n     - callback (function) #optional callback function which is going to be executed in the context of newly created paper\r\n     * or\r\n     - x (number)\r\n     - y (number)\r\n     - width (number)\r\n     - height (number)\r\n     - callback (function) #optional callback function which is going to be executed in the context of newly created paper\r\n     * or\r\n     - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.\r\n     - callback (function) #optional callback function which is going to be executed in the context of newly created paper\r\n     * or\r\n     - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eve’s “DOMLoad” event. In this case method returns `undefined`.\r\n     = (object) @Paper\r\n     > Usage\r\n     | // Each of the following examples create a canvas\r\n     | // that is 320px wide by 200px high.\r\n     | // Canvas is created at the viewport’s 10,50 coordinate.\r\n     | var paper = Raphael(10, 50, 320, 200);\r\n     | // Canvas is created at the top left corner of the #notepad element\r\n     | // (or its top right corner in dir=\"rtl\" elements)\r\n     | var paper = Raphael(document.getElementById(\"notepad\"), 320, 200);\r\n     | // Same as above\r\n     | var paper = Raphael(\"notepad\", 320, 200);\r\n     | // Image dump\r\n     | var set = Raphael([\"notepad\", 320, 200, {\r\n     |     type: \"rect\",\r\n     |     x: 10,\r\n     |     y: 10,\r\n     |     width: 25,\r\n     |     height: 25,\r\n     |     stroke: \"#f00\"\r\n     | }, {\r\n     |     type: \"text\",\r\n     |     x: 30,\r\n     |     y: 40,\r\n     |     text: \"Dump\"\r\n     | }]);\r\n    \\*/\r\n            function R(first) {\r\n              if (R.is(first, 'function')) {\r\n                return loaded ? first() : eve.on('raphael.DOMload', first);\r\n              } else if (R.is(first, array)) {\r\n                return R._engine.create[apply](\r\n                  R,\r\n                  first.splice(0, 3 + R.is(first[0], nu))\r\n                ).add(first);\r\n              } else {\r\n                var args = Array.prototype.slice.call(arguments, 0);\r\n                if (R.is(args[args.length - 1], 'function')) {\r\n                  var f = args.pop();\r\n                  return loaded\r\n                    ? f.call(R._engine.create[apply](R, args))\r\n                    : eve.on('raphael.DOMload', function () {\r\n                        f.call(R._engine.create[apply](R, args));\r\n                      });\r\n                } else {\r\n                  return R._engine.create[apply](R, arguments);\r\n                }\r\n              }\r\n            }\r\n            R.version = '2.3.0';\r\n            R.eve = eve;\r\n            var loaded,\r\n              separator = /[, ]+/,\r\n              elements = {\r\n                circle: 1,\r\n                rect: 1,\r\n                path: 1,\r\n                ellipse: 1,\r\n                text: 1,\r\n                image: 1,\r\n              },\r\n              formatrg = /\\{(\\d+)\\}/g,\r\n              proto = 'prototype',\r\n              has = 'hasOwnProperty',\r\n              g = {\r\n                doc: document,\r\n                win: window,\r\n              },\r\n              oldRaphael = {\r\n                was: Object.prototype[has].call(g.win, 'Raphael'),\r\n                is: g.win.Raphael,\r\n              },\r\n              Paper = function () {\r\n                /*\\\r\n             * Paper.ca\r\n             [ property (object) ]\r\n             **\r\n             * Shortcut for @Paper.customAttributes\r\n            \\*/\r\n                /*\\\r\n             * Paper.customAttributes\r\n             [ property (object) ]\r\n             **\r\n             * If you have a set of attributes that you would like to represent\r\n             * as a function of some number you can do it easily with custom attributes:\r\n             > Usage\r\n             | paper.customAttributes.hue = function (num) {\r\n             |     num = num % 1;\r\n             |     return {fill: \"hsb(\" + num + \", 0.75, 1)\"};\r\n             | };\r\n             | // Custom attribute “hue” will change fill\r\n             | // to be given hue with fixed saturation and brightness.\r\n             | // Now you can use it like this:\r\n             | var c = paper.circle(10, 10, 10).attr({hue: .45});\r\n             | // or even like this:\r\n             | c.animate({hue: 1}, 1e3);\r\n             |\r\n             | // You could also create custom attribute\r\n             | // with multiple parameters:\r\n             | paper.customAttributes.hsb = function (h, s, b) {\r\n             |     return {fill: \"hsb(\" + [h, s, b].join(\",\") + \")\"};\r\n             | };\r\n             | c.attr({hsb: \"0.5 .8 1\"});\r\n             | c.animate({hsb: [1, 0, 0.5]}, 1e3);\r\n            \\*/\r\n                this.ca = this.customAttributes = {};\r\n              },\r\n              paperproto,\r\n              appendChild = 'appendChild',\r\n              apply = 'apply',\r\n              concat = 'concat',\r\n              //taken from Modernizr touch test: https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js#L40\r\n              supportsTouch =\r\n                'ontouchstart' in window ||\r\n                window.TouchEvent ||\r\n                (window.DocumentTouch && document instanceof DocumentTouch),\r\n              E = '',\r\n              S = ' ',\r\n              Str = String,\r\n              split = 'split',\r\n              events =\r\n                'click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel'[\r\n                  split\r\n                ](S),\r\n              touchMap = {\r\n                mousedown: 'touchstart',\r\n                mousemove: 'touchmove',\r\n                mouseup: 'touchend',\r\n              },\r\n              lowerCase = Str.prototype.toLowerCase,\r\n              math = Math,\r\n              mmax = math.max,\r\n              mmin = math.min,\r\n              abs = math.abs,\r\n              pow = math.pow,\r\n              PI = math.PI,\r\n              nu = 'number',\r\n              string = 'string',\r\n              array = 'array',\r\n              toString = 'toString',\r\n              fillString = 'fill',\r\n              objectToString = Object.prototype.toString,\r\n              paper = {},\r\n              push = 'push',\r\n              ISURL = (R._ISURL = /^url\\(['\"]?(.+?)['\"]?\\)$/i),\r\n              colourRegExp =\r\n                /^\\s*((#[a-f\\d]{6})|(#[a-f\\d]{3})|rgba?\\(\\s*([\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+%?)?)\\s*\\)|hsba?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?)%?\\s*\\)|hsla?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?)%?\\s*\\))\\s*$/i,\r\n              isnan = { NaN: 1, Infinity: 1, '-Infinity': 1 },\r\n              bezierrg =\r\n                /^(?:cubic-)?bezier\\(([^,]+),([^,]+),([^,]+),([^\\)]+)\\)/,\r\n              round = math.round,\r\n              setAttribute = 'setAttribute',\r\n              toFloat = parseFloat,\r\n              toInt = parseInt,\r\n              upperCase = Str.prototype.toUpperCase,\r\n              availableAttrs = (R._availableAttrs = {\r\n                'arrow-end': 'none',\r\n                'arrow-start': 'none',\r\n                blur: 0,\r\n                'clip-rect': '0 0 1e9 1e9',\r\n                cursor: 'default',\r\n                cx: 0,\r\n                cy: 0,\r\n                fill: '#fff',\r\n                'fill-opacity': 1,\r\n                font: '10px \"Arial\"',\r\n                'font-family': '\"Arial\"',\r\n                'font-size': '10',\r\n                'font-style': 'normal',\r\n                'font-weight': 400,\r\n                gradient: 0,\r\n                height: 0,\r\n                href: 'http://raphaeljs.com/',\r\n                'letter-spacing': 0,\r\n                opacity: 1,\r\n                path: 'M0,0',\r\n                r: 0,\r\n                rx: 0,\r\n                ry: 0,\r\n                src: '',\r\n                stroke: '#000',\r\n                'stroke-dasharray': '',\r\n                'stroke-linecap': 'butt',\r\n                'stroke-linejoin': 'butt',\r\n                'stroke-miterlimit': 0,\r\n                'stroke-opacity': 1,\r\n                'stroke-width': 1,\r\n                target: '_blank',\r\n                'text-anchor': 'middle',\r\n                title: 'Raphael',\r\n                transform: '',\r\n                width: 0,\r\n                x: 0,\r\n                y: 0,\r\n                class: '',\r\n              }),\r\n              availableAnimAttrs = (R._availableAnimAttrs = {\r\n                blur: nu,\r\n                'clip-rect': 'csv',\r\n                cx: nu,\r\n                cy: nu,\r\n                fill: 'colour',\r\n                'fill-opacity': nu,\r\n                'font-size': nu,\r\n                height: nu,\r\n                opacity: nu,\r\n                path: 'path',\r\n                r: nu,\r\n                rx: nu,\r\n                ry: nu,\r\n                stroke: 'colour',\r\n                'stroke-opacity': nu,\r\n                'stroke-width': nu,\r\n                transform: 'transform',\r\n                width: nu,\r\n                x: nu,\r\n                y: nu,\r\n              }),\r\n              whitespace =\r\n                /[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]/g,\r\n              commaSpaces =\r\n                /[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*/,\r\n              hsrg = { hs: 1, rg: 1 },\r\n              p2s = /,?([achlmqrstvxz]),?/gi,\r\n              pathCommand =\r\n                /([achlmrqstvz])[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*)+)/gi,\r\n              tCommand =\r\n                /([rstm])[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*)+)/gi,\r\n              pathValues =\r\n                /(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*/gi,\r\n              radial_gradient = (R._radial_gradient =\r\n                /^r(?:\\(([^,]+?)[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*([^\\)]+?)\\))?/),\r\n              eldata = {},\r\n              sortByKey = function (a, b) {\r\n                return a.key - b.key;\r\n              },\r\n              sortByNumber = function (a, b) {\r\n                return toFloat(a) - toFloat(b);\r\n              },\r\n              fun = function () {},\r\n              pipe = function (x) {\r\n                return x;\r\n              },\r\n              rectPath = (R._rectPath = function (x, y, w, h, r) {\r\n                if (r) {\r\n                  return [\r\n                    ['M', x + r, y],\r\n                    ['l', w - r * 2, 0],\r\n                    ['a', r, r, 0, 0, 1, r, r],\r\n                    ['l', 0, h - r * 2],\r\n                    ['a', r, r, 0, 0, 1, -r, r],\r\n                    ['l', r * 2 - w, 0],\r\n                    ['a', r, r, 0, 0, 1, -r, -r],\r\n                    ['l', 0, r * 2 - h],\r\n                    ['a', r, r, 0, 0, 1, r, -r],\r\n                    ['z'],\r\n                  ];\r\n                }\r\n                return [\r\n                  ['M', x, y],\r\n                  ['l', w, 0],\r\n                  ['l', 0, h],\r\n                  ['l', -w, 0],\r\n                  ['z'],\r\n                ];\r\n              }),\r\n              ellipsePath = function (x, y, rx, ry) {\r\n                if (ry == null) {\r\n                  ry = rx;\r\n                }\r\n                return [\r\n                  ['M', x, y],\r\n                  ['m', 0, -ry],\r\n                  ['a', rx, ry, 0, 1, 1, 0, 2 * ry],\r\n                  ['a', rx, ry, 0, 1, 1, 0, -2 * ry],\r\n                  ['z'],\r\n                ];\r\n              },\r\n              getPath = (R._getPath = {\r\n                path: function (el) {\r\n                  return el.attr('path');\r\n                },\r\n                circle: function (el) {\r\n                  var a = el.attrs;\r\n                  return ellipsePath(a.cx, a.cy, a.r);\r\n                },\r\n                ellipse: function (el) {\r\n                  var a = el.attrs;\r\n                  return ellipsePath(a.cx, a.cy, a.rx, a.ry);\r\n                },\r\n                rect: function (el) {\r\n                  var a = el.attrs;\r\n                  return rectPath(a.x, a.y, a.width, a.height, a.r);\r\n                },\r\n                image: function (el) {\r\n                  var a = el.attrs;\r\n                  return rectPath(a.x, a.y, a.width, a.height);\r\n                },\r\n                text: function (el) {\r\n                  var bbox = el._getBBox();\r\n                  return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\r\n                },\r\n                set: function (el) {\r\n                  var bbox = el._getBBox();\r\n                  return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\r\n                },\r\n              }),\r\n              /*\\\r\n         * Raphael.mapPath\r\n         [ method ]\r\n         **\r\n         * Transform the path string with given matrix.\r\n         > Parameters\r\n         - path (string) path string\r\n         - matrix (object) see @Matrix\r\n         = (string) transformed path string\r\n        \\*/\r\n              mapPath = (R.mapPath = function (path, matrix) {\r\n                if (!matrix) {\r\n                  return path;\r\n                }\r\n                var x, y, i, j, ii, jj, pathi;\r\n                path = path2curve(path);\r\n                for (i = 0, ii = path.length; i < ii; i++) {\r\n                  pathi = path[i];\r\n                  for (j = 1, jj = pathi.length; j < jj; j += 2) {\r\n                    x = matrix.x(pathi[j], pathi[j + 1]);\r\n                    y = matrix.y(pathi[j], pathi[j + 1]);\r\n                    pathi[j] = x;\r\n                    pathi[j + 1] = y;\r\n                  }\r\n                }\r\n                return path;\r\n              });\r\n\r\n            R._g = g;\r\n            /*\\\r\n     * Raphael.type\r\n     [ property (string) ]\r\n     **\r\n     * Can be “SVG”, “VML” or empty, depending on browser support.\r\n    \\*/\r\n            R.type =\r\n              g.win.SVGAngle ||\r\n              g.doc.implementation.hasFeature(\r\n                'http://www.w3.org/TR/SVG11/feature#BasicStructure',\r\n                '1.1'\r\n              )\r\n                ? 'SVG'\r\n                : 'VML';\r\n            if (R.type == 'VML') {\r\n              var d = g.doc.createElement('div'),\r\n                b;\r\n              d.innerHTML = '<v:shape adj=\"1\"/>';\r\n              b = d.firstChild;\r\n              b.style.behavior = 'url(#default#VML)';\r\n              if (!(b && typeof b.adj == 'object')) {\r\n                return (R.type = E);\r\n              }\r\n              d = null;\r\n            }\r\n            /*\\\r\n     * Raphael.svg\r\n     [ property (boolean) ]\r\n     **\r\n     * `true` if browser supports SVG.\r\n    \\*/\r\n            /*\\\r\n     * Raphael.vml\r\n     [ property (boolean) ]\r\n     **\r\n     * `true` if browser supports VML.\r\n    \\*/\r\n            R.svg = !(R.vml = R.type == 'VML');\r\n            R._Paper = Paper;\r\n            /*\\\r\n     * Raphael.fn\r\n     [ property (object) ]\r\n     **\r\n     * You can add your own method to the canvas. For example if you want to draw a pie chart,\r\n     * you can create your own pie chart function and ship it as a Raphaël plugin. To do this\r\n     * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a\r\n     * Raphaël instance is created, otherwise it will take no effect. Please note that the\r\n     * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to\r\n     * ensure any namespacing ensures proper context.\r\n     > Usage\r\n     | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {\r\n     |     return this.path( ... );\r\n     | };\r\n     | // or create namespace\r\n     | Raphael.fn.mystuff = {\r\n     |     arrow: function () {…},\r\n     |     star: function () {…},\r\n     |     // etc…\r\n     | };\r\n     | var paper = Raphael(10, 10, 630, 480);\r\n     | // then use it\r\n     | paper.arrow(10, 10, 30, 30, 5).attr({fill: \"#f00\"});\r\n     | paper.mystuff.arrow();\r\n     | paper.mystuff.star();\r\n    \\*/\r\n            R.fn = paperproto = Paper.prototype = R.prototype;\r\n            R._id = 0;\r\n            /*\\\r\n     * Raphael.is\r\n     [ method ]\r\n     **\r\n     * Handful of replacements for `typeof` operator.\r\n     > Parameters\r\n     - o (…) any object or primitive\r\n     - type (string) name of the type, i.e. “string”, “function”, “number”, etc.\r\n     = (boolean) is given value is of given type\r\n    \\*/\r\n            R.is = function (o, type) {\r\n              type = lowerCase.call(type);\r\n              if (type == 'finite') {\r\n                return !isnan[has](+o);\r\n              }\r\n              if (type == 'array') {\r\n                return o instanceof Array;\r\n              }\r\n              return (\r\n                (type == 'null' && o === null) ||\r\n                (type == typeof o && o !== null) ||\r\n                (type == 'object' && o === Object(o)) ||\r\n                (type == 'array' && Array.isArray && Array.isArray(o)) ||\r\n                objectToString.call(o).slice(8, -1).toLowerCase() == type\r\n              );\r\n            };\r\n\r\n            function clone(obj) {\r\n              if (typeof obj == 'function' || Object(obj) !== obj) {\r\n                return obj;\r\n              }\r\n              var res = new obj.constructor();\r\n              for (var key in obj)\r\n                if (obj[has](key)) {\r\n                  res[key] = clone(obj[key]);\r\n                }\r\n              return res;\r\n            }\r\n\r\n            /*\\\r\n     * Raphael.angle\r\n     [ method ]\r\n     **\r\n     * Returns angle between two or three points\r\n     > Parameters\r\n     - x1 (number) x coord of first point\r\n     - y1 (number) y coord of first point\r\n     - x2 (number) x coord of second point\r\n     - y2 (number) y coord of second point\r\n     - x3 (number) #optional x coord of third point\r\n     - y3 (number) #optional y coord of third point\r\n     = (number) angle in degrees.\r\n    \\*/\r\n            R.angle = function (x1, y1, x2, y2, x3, y3) {\r\n              if (x3 == null) {\r\n                var x = x1 - x2,\r\n                  y = y1 - y2;\r\n                if (!x && !y) {\r\n                  return 0;\r\n                }\r\n                return (180 + (math.atan2(-y, -x) * 180) / PI + 360) % 360;\r\n              } else {\r\n                return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);\r\n              }\r\n            };\r\n            /*\\\r\n     * Raphael.rad\r\n     [ method ]\r\n     **\r\n     * Transform angle to radians\r\n     > Parameters\r\n     - deg (number) angle in degrees\r\n     = (number) angle in radians.\r\n    \\*/\r\n            R.rad = function (deg) {\r\n              return ((deg % 360) * PI) / 180;\r\n            };\r\n            /*\\\r\n     * Raphael.deg\r\n     [ method ]\r\n     **\r\n     * Transform angle to degrees\r\n     > Parameters\r\n     - rad (number) angle in radians\r\n     = (number) angle in degrees.\r\n    \\*/\r\n            R.deg = function (rad) {\r\n              return Math.round((((rad * 180) / PI) % 360) * 1000) / 1000;\r\n            };\r\n            /*\\\r\n     * Raphael.snapTo\r\n     [ method ]\r\n     **\r\n     * Snaps given value to given grid.\r\n     > Parameters\r\n     - values (array|number) given array of values or step of the grid\r\n     - value (number) value to adjust\r\n     - tolerance (number) #optional tolerance for snapping. Default is `10`.\r\n     = (number) adjusted value.\r\n    \\*/\r\n            R.snapTo = function (values, value, tolerance) {\r\n              tolerance = R.is(tolerance, 'finite') ? tolerance : 10;\r\n              if (R.is(values, array)) {\r\n                var i = values.length;\r\n                while (i--)\r\n                  if (abs(values[i] - value) <= tolerance) {\r\n                    return values[i];\r\n                  }\r\n              } else {\r\n                values = +values;\r\n                var rem = value % values;\r\n                if (rem < tolerance) {\r\n                  return value - rem;\r\n                }\r\n                if (rem > values - tolerance) {\r\n                  return value - rem + values;\r\n                }\r\n              }\r\n              return value;\r\n            };\r\n\r\n            /*\\\r\n     * Raphael.createUUID\r\n     [ method ]\r\n     **\r\n     * Returns RFC4122, version 4 ID\r\n    \\*/\r\n            var createUUID = (R.createUUID = (function (\r\n              uuidRegEx,\r\n              uuidReplacer\r\n            ) {\r\n              return function () {\r\n                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'\r\n                  .replace(uuidRegEx, uuidReplacer)\r\n                  .toUpperCase();\r\n              };\r\n            })(/[xy]/g, function (c) {\r\n              var r = (math.random() * 16) | 0,\r\n                v = c == 'x' ? r : (r & 3) | 8;\r\n              return v.toString(16);\r\n            }));\r\n\r\n            /*\\\r\n     * Raphael.setWindow\r\n     [ method ]\r\n     **\r\n     * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.\r\n     > Parameters\r\n     - newwin (window) new window object\r\n    \\*/\r\n            R.setWindow = function (newwin) {\r\n              eve('raphael.setWindow', R, g.win, newwin);\r\n              g.win = newwin;\r\n              g.doc = g.win.document;\r\n              if (R._engine.initWin) {\r\n                R._engine.initWin(g.win);\r\n              }\r\n            };\r\n            var toHex = function (color) {\r\n                if (R.vml) {\r\n                  // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/\r\n                  var trim = /^\\s+|\\s+$/g;\r\n                  var bod;\r\n                  try {\r\n                    var docum = new ActiveXObject('htmlfile');\r\n                    docum.write('<body>');\r\n                    docum.close();\r\n                    bod = docum.body;\r\n                  } catch (e) {\r\n                    bod = createPopup().document.body;\r\n                  }\r\n                  var range = bod.createTextRange();\r\n                  toHex = cacher(function (color) {\r\n                    try {\r\n                      bod.style.color = Str(color).replace(trim, E);\r\n                      var value = range.queryCommandValue('ForeColor');\r\n                      value =\r\n                        ((value & 255) << 16) |\r\n                        (value & 65280) |\r\n                        ((value & 16711680) >>> 16);\r\n                      return '#' + ('000000' + value.toString(16)).slice(-6);\r\n                    } catch (e) {\r\n                      return 'none';\r\n                    }\r\n                  });\r\n                } else {\r\n                  var i = g.doc.createElement('i');\r\n                  i.title = 'Rapha\\xebl Colour Picker';\r\n                  i.style.display = 'none';\r\n                  g.doc.body.appendChild(i);\r\n                  toHex = cacher(function (color) {\r\n                    i.style.color = color;\r\n                    return g.doc.defaultView\r\n                      .getComputedStyle(i, E)\r\n                      .getPropertyValue('color');\r\n                  });\r\n                }\r\n                return toHex(color);\r\n              },\r\n              hsbtoString = function () {\r\n                return 'hsb(' + [this.h, this.s, this.b] + ')';\r\n              },\r\n              hsltoString = function () {\r\n                return 'hsl(' + [this.h, this.s, this.l] + ')';\r\n              },\r\n              rgbtoString = function () {\r\n                return this.hex;\r\n              },\r\n              prepareRGB = function (r, g, b) {\r\n                if (\r\n                  g == null &&\r\n                  R.is(r, 'object') &&\r\n                  'r' in r &&\r\n                  'g' in r &&\r\n                  'b' in r\r\n                ) {\r\n                  b = r.b;\r\n                  g = r.g;\r\n                  r = r.r;\r\n                }\r\n                if (g == null && R.is(r, string)) {\r\n                  var clr = R.getRGB(r);\r\n                  r = clr.r;\r\n                  g = clr.g;\r\n                  b = clr.b;\r\n                }\r\n                if (r > 1 || g > 1 || b > 1) {\r\n                  r /= 255;\r\n                  g /= 255;\r\n                  b /= 255;\r\n                }\r\n\r\n                return [r, g, b];\r\n              },\r\n              packageRGB = function (r, g, b, o) {\r\n                r *= 255;\r\n                g *= 255;\r\n                b *= 255;\r\n                var rgb = {\r\n                  r: r,\r\n                  g: g,\r\n                  b: b,\r\n                  hex: R.rgb(r, g, b),\r\n                  toString: rgbtoString,\r\n                };\r\n                R.is(o, 'finite') && (rgb.opacity = o);\r\n                return rgb;\r\n              };\r\n\r\n            /*\\\r\n     * Raphael.color\r\n     [ method ]\r\n     **\r\n     * Parses the color string and returns object with all values for the given color.\r\n     > Parameters\r\n     - clr (string) color string in one of the supported formats (see @Raphael.getRGB)\r\n     = (object) Combined RGB & HSB object in format:\r\n     o {\r\n     o     r (number) red,\r\n     o     g (number) green,\r\n     o     b (number) blue,\r\n     o     hex (string) color in HTML/CSS format: #••••••,\r\n     o     error (boolean) `true` if string can’t be parsed,\r\n     o     h (number) hue,\r\n     o     s (number) saturation,\r\n     o     v (number) value (brightness),\r\n     o     l (number) lightness\r\n     o }\r\n    \\*/\r\n            R.color = function (clr) {\r\n              var rgb;\r\n              if (\r\n                R.is(clr, 'object') &&\r\n                'h' in clr &&\r\n                's' in clr &&\r\n                'b' in clr\r\n              ) {\r\n                rgb = R.hsb2rgb(clr);\r\n                clr.r = rgb.r;\r\n                clr.g = rgb.g;\r\n                clr.b = rgb.b;\r\n                clr.hex = rgb.hex;\r\n              } else if (\r\n                R.is(clr, 'object') &&\r\n                'h' in clr &&\r\n                's' in clr &&\r\n                'l' in clr\r\n              ) {\r\n                rgb = R.hsl2rgb(clr);\r\n                clr.r = rgb.r;\r\n                clr.g = rgb.g;\r\n                clr.b = rgb.b;\r\n                clr.hex = rgb.hex;\r\n              } else {\r\n                if (R.is(clr, 'string')) {\r\n                  clr = R.getRGB(clr);\r\n                }\r\n                if (\r\n                  R.is(clr, 'object') &&\r\n                  'r' in clr &&\r\n                  'g' in clr &&\r\n                  'b' in clr\r\n                ) {\r\n                  rgb = R.rgb2hsl(clr);\r\n                  clr.h = rgb.h;\r\n                  clr.s = rgb.s;\r\n                  clr.l = rgb.l;\r\n                  rgb = R.rgb2hsb(clr);\r\n                  clr.v = rgb.b;\r\n                } else {\r\n                  clr = { hex: 'none' };\r\n                  clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;\r\n                }\r\n              }\r\n              clr.toString = rgbtoString;\r\n              return clr;\r\n            };\r\n            /*\\\r\n     * Raphael.hsb2rgb\r\n     [ method ]\r\n     **\r\n     * Converts HSB values to RGB object.\r\n     > Parameters\r\n     - h (number) hue\r\n     - s (number) saturation\r\n     - v (number) value or brightness\r\n     = (object) RGB object in format:\r\n     o {\r\n     o     r (number) red,\r\n     o     g (number) green,\r\n     o     b (number) blue,\r\n     o     hex (string) color in HTML/CSS format: #••••••\r\n     o }\r\n    \\*/\r\n            R.hsb2rgb = function (h, s, v, o) {\r\n              if (this.is(h, 'object') && 'h' in h && 's' in h && 'b' in h) {\r\n                v = h.b;\r\n                s = h.s;\r\n                o = h.o;\r\n                h = h.h;\r\n              }\r\n              h *= 360;\r\n              var R, G, B, X, C;\r\n              h = (h % 360) / 60;\r\n              C = v * s;\r\n              X = C * (1 - abs((h % 2) - 1));\r\n              R = G = B = v - C;\r\n\r\n              h = ~~h;\r\n              R += [C, X, 0, 0, X, C][h];\r\n              G += [X, C, C, X, 0, 0][h];\r\n              B += [0, 0, X, C, C, X][h];\r\n              return packageRGB(R, G, B, o);\r\n            };\r\n            /*\\\r\n     * Raphael.hsl2rgb\r\n     [ method ]\r\n     **\r\n     * Converts HSL values to RGB object.\r\n     > Parameters\r\n     - h (number) hue\r\n     - s (number) saturation\r\n     - l (number) luminosity\r\n     = (object) RGB object in format:\r\n     o {\r\n     o     r (number) red,\r\n     o     g (number) green,\r\n     o     b (number) blue,\r\n     o     hex (string) color in HTML/CSS format: #••••••\r\n     o }\r\n    \\*/\r\n            R.hsl2rgb = function (h, s, l, o) {\r\n              if (this.is(h, 'object') && 'h' in h && 's' in h && 'l' in h) {\r\n                l = h.l;\r\n                s = h.s;\r\n                h = h.h;\r\n              }\r\n              if (h > 1 || s > 1 || l > 1) {\r\n                h /= 360;\r\n                s /= 100;\r\n                l /= 100;\r\n              }\r\n              h *= 360;\r\n              var R, G, B, X, C;\r\n              h = (h % 360) / 60;\r\n              C = 2 * s * (l < 0.5 ? l : 1 - l);\r\n              X = C * (1 - abs((h % 2) - 1));\r\n              R = G = B = l - C / 2;\r\n\r\n              h = ~~h;\r\n              R += [C, X, 0, 0, X, C][h];\r\n              G += [X, C, C, X, 0, 0][h];\r\n              B += [0, 0, X, C, C, X][h];\r\n              return packageRGB(R, G, B, o);\r\n            };\r\n            /*\\\r\n     * Raphael.rgb2hsb\r\n     [ method ]\r\n     **\r\n     * Converts RGB values to HSB object.\r\n     > Parameters\r\n     - r (number) red\r\n     - g (number) green\r\n     - b (number) blue\r\n     = (object) HSB object in format:\r\n     o {\r\n     o     h (number) hue\r\n     o     s (number) saturation\r\n     o     b (number) brightness\r\n     o }\r\n    \\*/\r\n            R.rgb2hsb = function (r, g, b) {\r\n              b = prepareRGB(r, g, b);\r\n              r = b[0];\r\n              g = b[1];\r\n              b = b[2];\r\n\r\n              var H, S, V, C;\r\n              V = mmax(r, g, b);\r\n              C = V - mmin(r, g, b);\r\n              H =\r\n                C == 0\r\n                  ? null\r\n                  : V == r\r\n                  ? (g - b) / C\r\n                  : V == g\r\n                  ? (b - r) / C + 2\r\n                  : (r - g) / C + 4;\r\n              H = (((H + 360) % 6) * 60) / 360;\r\n              S = C == 0 ? 0 : C / V;\r\n              return { h: H, s: S, b: V, toString: hsbtoString };\r\n            };\r\n            /*\\\r\n     * Raphael.rgb2hsl\r\n     [ method ]\r\n     **\r\n     * Converts RGB values to HSL object.\r\n     > Parameters\r\n     - r (number) red\r\n     - g (number) green\r\n     - b (number) blue\r\n     = (object) HSL object in format:\r\n     o {\r\n     o     h (number) hue\r\n     o     s (number) saturation\r\n     o     l (number) luminosity\r\n     o }\r\n    \\*/\r\n            R.rgb2hsl = function (r, g, b) {\r\n              b = prepareRGB(r, g, b);\r\n              r = b[0];\r\n              g = b[1];\r\n              b = b[2];\r\n\r\n              var H, S, L, M, m, C;\r\n              M = mmax(r, g, b);\r\n              m = mmin(r, g, b);\r\n              C = M - m;\r\n              H =\r\n                C == 0\r\n                  ? null\r\n                  : M == r\r\n                  ? (g - b) / C\r\n                  : M == g\r\n                  ? (b - r) / C + 2\r\n                  : (r - g) / C + 4;\r\n              H = (((H + 360) % 6) * 60) / 360;\r\n              L = (M + m) / 2;\r\n              S = C == 0 ? 0 : L < 0.5 ? C / (2 * L) : C / (2 - 2 * L);\r\n              return { h: H, s: S, l: L, toString: hsltoString };\r\n            };\r\n            R._path2string = function () {\r\n              return this.join(',').replace(p2s, '$1');\r\n            };\r\n            function repush(array, item) {\r\n              for (var i = 0, ii = array.length; i < ii; i++)\r\n                if (array[i] === item) {\r\n                  return array.push(array.splice(i, 1)[0]);\r\n                }\r\n            }\r\n            function cacher(f, scope, postprocessor) {\r\n              function newf() {\r\n                var arg = Array.prototype.slice.call(arguments, 0),\r\n                  args = arg.join('\\u2400'),\r\n                  cache = (newf.cache = newf.cache || {}),\r\n                  count = (newf.count = newf.count || []);\r\n                if (cache[has](args)) {\r\n                  repush(count, args);\r\n                  return postprocessor\r\n                    ? postprocessor(cache[args])\r\n                    : cache[args];\r\n                }\r\n                count.length >= 1e3 && delete cache[count.shift()];\r\n                count.push(args);\r\n                cache[args] = f[apply](scope, arg);\r\n                return postprocessor ? postprocessor(cache[args]) : cache[args];\r\n              }\r\n              return newf;\r\n            }\r\n\r\n            var preload = (R._preload = function (src, f) {\r\n              var img = g.doc.createElement('img');\r\n              img.style.cssText = 'position:absolute;left:-9999em;top:-9999em';\r\n              img.onload = function () {\r\n                f.call(this);\r\n                this.onload = null;\r\n                g.doc.body.removeChild(this);\r\n              };\r\n              img.onerror = function () {\r\n                g.doc.body.removeChild(this);\r\n              };\r\n              g.doc.body.appendChild(img);\r\n              img.src = src;\r\n            });\r\n\r\n            function clrToString() {\r\n              return this.hex;\r\n            }\r\n\r\n            /*\\\r\n     * Raphael.getRGB\r\n     [ method ]\r\n     **\r\n     * Parses colour string as RGB object\r\n     > Parameters\r\n     - colour (string) colour string in one of formats:\r\n     # <ul>\r\n     #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>\r\n     #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>\r\n     #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>\r\n     #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>\r\n     #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>\r\n     #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>\r\n     #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>\r\n     #     <li>hsl(•••, •••, •••) — same as hsb</li>\r\n     #     <li>hsl(•••%, •••%, •••%) — same as hsb</li>\r\n     # </ul>\r\n     = (object) RGB object in format:\r\n     o {\r\n     o     r (number) red,\r\n     o     g (number) green,\r\n     o     b (number) blue\r\n     o     hex (string) color in HTML/CSS format: #••••••,\r\n     o     error (boolean) true if string can’t be parsed\r\n     o }\r\n    \\*/\r\n            R.getRGB = cacher(function (colour) {\r\n              if (!colour || !!((colour = Str(colour)).indexOf('-') + 1)) {\r\n                return {\r\n                  r: -1,\r\n                  g: -1,\r\n                  b: -1,\r\n                  hex: 'none',\r\n                  error: 1,\r\n                  toString: clrToString,\r\n                };\r\n              }\r\n              if (colour == 'none') {\r\n                return {\r\n                  r: -1,\r\n                  g: -1,\r\n                  b: -1,\r\n                  hex: 'none',\r\n                  toString: clrToString,\r\n                };\r\n              }\r\n              !(\r\n                hsrg[has](colour.toLowerCase().substring(0, 2)) ||\r\n                colour.charAt() == '#'\r\n              ) && (colour = toHex(colour));\r\n              var res,\r\n                red,\r\n                green,\r\n                blue,\r\n                opacity,\r\n                t,\r\n                values,\r\n                rgb = colour.match(colourRegExp);\r\n              if (rgb) {\r\n                if (rgb[2]) {\r\n                  blue = toInt(rgb[2].substring(5), 16);\r\n                  green = toInt(rgb[2].substring(3, 5), 16);\r\n                  red = toInt(rgb[2].substring(1, 3), 16);\r\n                }\r\n                if (rgb[3]) {\r\n                  blue = toInt((t = rgb[3].charAt(3)) + t, 16);\r\n                  green = toInt((t = rgb[3].charAt(2)) + t, 16);\r\n                  red = toInt((t = rgb[3].charAt(1)) + t, 16);\r\n                }\r\n                if (rgb[4]) {\r\n                  values = rgb[4][split](commaSpaces);\r\n                  red = toFloat(values[0]);\r\n                  values[0].slice(-1) == '%' && (red *= 2.55);\r\n                  green = toFloat(values[1]);\r\n                  values[1].slice(-1) == '%' && (green *= 2.55);\r\n                  blue = toFloat(values[2]);\r\n                  values[2].slice(-1) == '%' && (blue *= 2.55);\r\n                  rgb[1].toLowerCase().slice(0, 4) == 'rgba' &&\r\n                    (opacity = toFloat(values[3]));\r\n                  values[3] && values[3].slice(-1) == '%' && (opacity /= 100);\r\n                }\r\n                if (rgb[5]) {\r\n                  values = rgb[5][split](commaSpaces);\r\n                  red = toFloat(values[0]);\r\n                  values[0].slice(-1) == '%' && (red *= 2.55);\r\n                  green = toFloat(values[1]);\r\n                  values[1].slice(-1) == '%' && (green *= 2.55);\r\n                  blue = toFloat(values[2]);\r\n                  values[2].slice(-1) == '%' && (blue *= 2.55);\r\n                  (values[0].slice(-3) == 'deg' ||\r\n                    values[0].slice(-1) == '\\xb0') &&\r\n                    (red /= 360);\r\n                  rgb[1].toLowerCase().slice(0, 4) == 'hsba' &&\r\n                    (opacity = toFloat(values[3]));\r\n                  values[3] && values[3].slice(-1) == '%' && (opacity /= 100);\r\n                  return R.hsb2rgb(red, green, blue, opacity);\r\n                }\r\n                if (rgb[6]) {\r\n                  values = rgb[6][split](commaSpaces);\r\n                  red = toFloat(values[0]);\r\n                  values[0].slice(-1) == '%' && (red *= 2.55);\r\n                  green = toFloat(values[1]);\r\n                  values[1].slice(-1) == '%' && (green *= 2.55);\r\n                  blue = toFloat(values[2]);\r\n                  values[2].slice(-1) == '%' && (blue *= 2.55);\r\n                  (values[0].slice(-3) == 'deg' ||\r\n                    values[0].slice(-1) == '\\xb0') &&\r\n                    (red /= 360);\r\n                  rgb[1].toLowerCase().slice(0, 4) == 'hsla' &&\r\n                    (opacity = toFloat(values[3]));\r\n                  values[3] && values[3].slice(-1) == '%' && (opacity /= 100);\r\n                  return R.hsl2rgb(red, green, blue, opacity);\r\n                }\r\n                rgb = { r: red, g: green, b: blue, toString: clrToString };\r\n                rgb.hex =\r\n                  '#' +\r\n                  (16777216 | blue | (green << 8) | (red << 16))\r\n                    .toString(16)\r\n                    .slice(1);\r\n                R.is(opacity, 'finite') && (rgb.opacity = opacity);\r\n                return rgb;\r\n              }\r\n              return {\r\n                r: -1,\r\n                g: -1,\r\n                b: -1,\r\n                hex: 'none',\r\n                error: 1,\r\n                toString: clrToString,\r\n              };\r\n            }, R);\r\n            /*\\\r\n     * Raphael.hsb\r\n     [ method ]\r\n     **\r\n     * Converts HSB values to hex representation of the colour.\r\n     > Parameters\r\n     - h (number) hue\r\n     - s (number) saturation\r\n     - b (number) value or brightness\r\n     = (string) hex representation of the colour.\r\n    \\*/\r\n            R.hsb = cacher(function (h, s, b) {\r\n              return R.hsb2rgb(h, s, b).hex;\r\n            });\r\n            /*\\\r\n     * Raphael.hsl\r\n     [ method ]\r\n     **\r\n     * Converts HSL values to hex representation of the colour.\r\n     > Parameters\r\n     - h (number) hue\r\n     - s (number) saturation\r\n     - l (number) luminosity\r\n     = (string) hex representation of the colour.\r\n    \\*/\r\n            R.hsl = cacher(function (h, s, l) {\r\n              return R.hsl2rgb(h, s, l).hex;\r\n            });\r\n            /*\\\r\n     * Raphael.rgb\r\n     [ method ]\r\n     **\r\n     * Converts RGB values to hex representation of the colour.\r\n     > Parameters\r\n     - r (number) red\r\n     - g (number) green\r\n     - b (number) blue\r\n     = (string) hex representation of the colour.\r\n    \\*/\r\n            R.rgb = cacher(function (r, g, b) {\r\n              function round(x) {\r\n                return (x + 0.5) | 0;\r\n              }\r\n              return (\r\n                '#' +\r\n                (16777216 | round(b) | (round(g) << 8) | (round(r) << 16))\r\n                  .toString(16)\r\n                  .slice(1)\r\n              );\r\n            });\r\n            /*\\\r\n     * Raphael.getColor\r\n     [ method ]\r\n     **\r\n     * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset\r\n     > Parameters\r\n     - value (number) #optional brightness, default is `0.75`\r\n     = (string) hex representation of the colour.\r\n    \\*/\r\n            R.getColor = function (value) {\r\n              var start = (this.getColor.start = this.getColor.start || {\r\n                  h: 0,\r\n                  s: 1,\r\n                  b: value || 0.75,\r\n                }),\r\n                rgb = this.hsb2rgb(start.h, start.s, start.b);\r\n              start.h += 0.075;\r\n              if (start.h > 1) {\r\n                start.h = 0;\r\n                start.s -= 0.2;\r\n                start.s <= 0 &&\r\n                  (this.getColor.start = { h: 0, s: 1, b: start.b });\r\n              }\r\n              return rgb.hex;\r\n            };\r\n            /*\\\r\n     * Raphael.getColor.reset\r\n     [ method ]\r\n     **\r\n     * Resets spectrum position for @Raphael.getColor back to red.\r\n    \\*/\r\n            R.getColor.reset = function () {\r\n              delete this.start;\r\n            };\r\n\r\n            // http://schepers.cc/getting-to-the-point\r\n            function catmullRom2bezier(crp, z) {\r\n              var d = [];\r\n              for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\r\n                var p = [\r\n                  { x: +crp[i - 2], y: +crp[i - 1] },\r\n                  { x: +crp[i], y: +crp[i + 1] },\r\n                  { x: +crp[i + 2], y: +crp[i + 3] },\r\n                  { x: +crp[i + 4], y: +crp[i + 5] },\r\n                ];\r\n                if (z) {\r\n                  if (!i) {\r\n                    p[0] = { x: +crp[iLen - 2], y: +crp[iLen - 1] };\r\n                  } else if (iLen - 4 == i) {\r\n                    p[3] = { x: +crp[0], y: +crp[1] };\r\n                  } else if (iLen - 2 == i) {\r\n                    p[2] = { x: +crp[0], y: +crp[1] };\r\n                    p[3] = { x: +crp[2], y: +crp[3] };\r\n                  }\r\n                } else {\r\n                  if (iLen - 4 == i) {\r\n                    p[3] = p[2];\r\n                  } else if (!i) {\r\n                    p[0] = { x: +crp[i], y: +crp[i + 1] };\r\n                  }\r\n                }\r\n                d.push([\r\n                  'C',\r\n                  (-p[0].x + 6 * p[1].x + p[2].x) / 6,\r\n                  (-p[0].y + 6 * p[1].y + p[2].y) / 6,\r\n                  (p[1].x + 6 * p[2].x - p[3].x) / 6,\r\n                  (p[1].y + 6 * p[2].y - p[3].y) / 6,\r\n                  p[2].x,\r\n                  p[2].y,\r\n                ]);\r\n              }\r\n\r\n              return d;\r\n            }\r\n            /*\\\r\n     * Raphael.parsePathString\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Parses given path string into an array of arrays of path segments.\r\n     > Parameters\r\n     - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)\r\n     = (array) array of segments.\r\n    \\*/\r\n            R.parsePathString = function (pathString) {\r\n              if (!pathString) {\r\n                return null;\r\n              }\r\n              var pth = paths(pathString);\r\n              if (pth.arr) {\r\n                return pathClone(pth.arr);\r\n              }\r\n\r\n              var paramCounts = {\r\n                  a: 7,\r\n                  c: 6,\r\n                  h: 1,\r\n                  l: 2,\r\n                  m: 2,\r\n                  r: 4,\r\n                  q: 4,\r\n                  s: 4,\r\n                  t: 2,\r\n                  v: 1,\r\n                  z: 0,\r\n                },\r\n                data = [];\r\n              if (R.is(pathString, array) && R.is(pathString[0], array)) {\r\n                // rough assumption\r\n                data = pathClone(pathString);\r\n              }\r\n              if (!data.length) {\r\n                Str(pathString).replace(pathCommand, function (a, b, c) {\r\n                  var params = [],\r\n                    name = b.toLowerCase();\r\n                  c.replace(pathValues, function (a, b) {\r\n                    b && params.push(+b);\r\n                  });\r\n                  if (name == 'm' && params.length > 2) {\r\n                    data.push([b][concat](params.splice(0, 2)));\r\n                    name = 'l';\r\n                    b = b == 'm' ? 'l' : 'L';\r\n                  }\r\n                  if (name == 'r') {\r\n                    data.push([b][concat](params));\r\n                  } else\r\n                    while (params.length >= paramCounts[name]) {\r\n                      data.push(\r\n                        [b][concat](params.splice(0, paramCounts[name]))\r\n                      );\r\n                      if (!paramCounts[name]) {\r\n                        break;\r\n                      }\r\n                    }\r\n                });\r\n              }\r\n              data.toString = R._path2string;\r\n              pth.arr = pathClone(data);\r\n              return data;\r\n            };\r\n            /*\\\r\n     * Raphael.parseTransformString\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Parses given path string into an array of transformations.\r\n     > Parameters\r\n     - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)\r\n     = (array) array of transformations.\r\n    \\*/\r\n            R.parseTransformString = cacher(\r\n              function (TString) {\r\n                if (!TString) {\r\n                  return null;\r\n                }\r\n                var paramCounts = { r: 3, s: 4, t: 2, m: 6 },\r\n                  data = [];\r\n                if (R.is(TString, array) && R.is(TString[0], array)) {\r\n                  // rough assumption\r\n                  data = pathClone(TString);\r\n                }\r\n                if (!data.length) {\r\n                  Str(TString).replace(tCommand, function (a, b, c) {\r\n                    var params = [],\r\n                      name = lowerCase.call(b);\r\n                    c.replace(pathValues, function (a, b) {\r\n                      b && params.push(+b);\r\n                    });\r\n                    data.push([b][concat](params));\r\n                  });\r\n                }\r\n                data.toString = R._path2string;\r\n                return data;\r\n              },\r\n              this,\r\n              function (elem) {\r\n                if (!elem) return elem;\r\n                var newData = [];\r\n                for (var i = 0; i < elem.length; i++) {\r\n                  var newLevel = [];\r\n                  for (var j = 0; j < elem[i].length; j++) {\r\n                    newLevel.push(elem[i][j]);\r\n                  }\r\n                  newData.push(newLevel);\r\n                }\r\n                return newData;\r\n              }\r\n            );\r\n            // PATHS\r\n            var paths = function (ps) {\r\n              var p = (paths.ps = paths.ps || {});\r\n              if (p[ps]) {\r\n                p[ps].sleep = 100;\r\n              } else {\r\n                p[ps] = {\r\n                  sleep: 100,\r\n                };\r\n              }\r\n              setTimeout(function () {\r\n                for (var key in p)\r\n                  if (p[has](key) && key != ps) {\r\n                    p[key].sleep--;\r\n                    !p[key].sleep && delete p[key];\r\n                  }\r\n              });\r\n              return p[ps];\r\n            };\r\n            /*\\\r\n     * Raphael.findDotsAtSegment\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Find dot coordinates on the given cubic bezier curve at the given t.\r\n     > Parameters\r\n     - p1x (number) x of the first point of the curve\r\n     - p1y (number) y of the first point of the curve\r\n     - c1x (number) x of the first anchor of the curve\r\n     - c1y (number) y of the first anchor of the curve\r\n     - c2x (number) x of the second anchor of the curve\r\n     - c2y (number) y of the second anchor of the curve\r\n     - p2x (number) x of the second point of the curve\r\n     - p2y (number) y of the second point of the curve\r\n     - t (number) position on the curve (0..1)\r\n     = (object) point information in format:\r\n     o {\r\n     o     x: (number) x coordinate of the point\r\n     o     y: (number) y coordinate of the point\r\n     o     m: {\r\n     o         x: (number) x coordinate of the left anchor\r\n     o         y: (number) y coordinate of the left anchor\r\n     o     }\r\n     o     n: {\r\n     o         x: (number) x coordinate of the right anchor\r\n     o         y: (number) y coordinate of the right anchor\r\n     o     }\r\n     o     start: {\r\n     o         x: (number) x coordinate of the start of the curve\r\n     o         y: (number) y coordinate of the start of the curve\r\n     o     }\r\n     o     end: {\r\n     o         x: (number) x coordinate of the end of the curve\r\n     o         y: (number) y coordinate of the end of the curve\r\n     o     }\r\n     o     alpha: (number) angle of the curve derivative at the point\r\n     o }\r\n    \\*/\r\n            R.findDotsAtSegment = function (\r\n              p1x,\r\n              p1y,\r\n              c1x,\r\n              c1y,\r\n              c2x,\r\n              c2y,\r\n              p2x,\r\n              p2y,\r\n              t\r\n            ) {\r\n              var t1 = 1 - t,\r\n                t13 = pow(t1, 3),\r\n                t12 = pow(t1, 2),\r\n                t2 = t * t,\r\n                t3 = t2 * t,\r\n                x =\r\n                  t13 * p1x +\r\n                  t12 * 3 * t * c1x +\r\n                  t1 * 3 * t * t * c2x +\r\n                  t3 * p2x,\r\n                y =\r\n                  t13 * p1y +\r\n                  t12 * 3 * t * c1y +\r\n                  t1 * 3 * t * t * c2y +\r\n                  t3 * p2y,\r\n                mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),\r\n                my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),\r\n                nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),\r\n                ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),\r\n                ax = t1 * p1x + t * c1x,\r\n                ay = t1 * p1y + t * c1y,\r\n                cx = t1 * c2x + t * p2x,\r\n                cy = t1 * c2y + t * p2y,\r\n                alpha = 90 - (math.atan2(mx - nx, my - ny) * 180) / PI;\r\n              (mx > nx || my < ny) && (alpha += 180);\r\n              return {\r\n                x: x,\r\n                y: y,\r\n                m: { x: mx, y: my },\r\n                n: { x: nx, y: ny },\r\n                start: { x: ax, y: ay },\r\n                end: { x: cx, y: cy },\r\n                alpha: alpha,\r\n              };\r\n            };\r\n            /*\\\r\n     * Raphael.bezierBBox\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Return bounding box of a given cubic bezier curve\r\n     > Parameters\r\n     - p1x (number) x of the first point of the curve\r\n     - p1y (number) y of the first point of the curve\r\n     - c1x (number) x of the first anchor of the curve\r\n     - c1y (number) y of the first anchor of the curve\r\n     - c2x (number) x of the second anchor of the curve\r\n     - c2y (number) y of the second anchor of the curve\r\n     - p2x (number) x of the second point of the curve\r\n     - p2y (number) y of the second point of the curve\r\n     * or\r\n     - bez (array) array of six points for bezier curve\r\n     = (object) point information in format:\r\n     o {\r\n     o     min: {\r\n     o         x: (number) x coordinate of the left point\r\n     o         y: (number) y coordinate of the top point\r\n     o     }\r\n     o     max: {\r\n     o         x: (number) x coordinate of the right point\r\n     o         y: (number) y coordinate of the bottom point\r\n     o     }\r\n     o }\r\n    \\*/\r\n            R.bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\r\n              if (!R.is(p1x, 'array')) {\r\n                p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\r\n              }\r\n              var bbox = curveDim.apply(null, p1x);\r\n              return {\r\n                x: bbox.min.x,\r\n                y: bbox.min.y,\r\n                x2: bbox.max.x,\r\n                y2: bbox.max.y,\r\n                width: bbox.max.x - bbox.min.x,\r\n                height: bbox.max.y - bbox.min.y,\r\n              };\r\n            };\r\n            /*\\\r\n     * Raphael.isPointInsideBBox\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Returns `true` if given point is inside bounding boxes.\r\n     > Parameters\r\n     - bbox (string) bounding box\r\n     - x (string) x coordinate of the point\r\n     - y (string) y coordinate of the point\r\n     = (boolean) `true` if point inside\r\n    \\*/\r\n            R.isPointInsideBBox = function (bbox, x, y) {\r\n              return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;\r\n            };\r\n            /*\\\r\n     * Raphael.isBBoxIntersect\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Returns `true` if two bounding boxes intersect\r\n     > Parameters\r\n     - bbox1 (string) first bounding box\r\n     - bbox2 (string) second bounding box\r\n     = (boolean) `true` if they intersect\r\n    \\*/\r\n            R.isBBoxIntersect = function (bbox1, bbox2) {\r\n              var i = R.isPointInsideBBox;\r\n              return (\r\n                i(bbox2, bbox1.x, bbox1.y) ||\r\n                i(bbox2, bbox1.x2, bbox1.y) ||\r\n                i(bbox2, bbox1.x, bbox1.y2) ||\r\n                i(bbox2, bbox1.x2, bbox1.y2) ||\r\n                i(bbox1, bbox2.x, bbox2.y) ||\r\n                i(bbox1, bbox2.x2, bbox2.y) ||\r\n                i(bbox1, bbox2.x, bbox2.y2) ||\r\n                i(bbox1, bbox2.x2, bbox2.y2) ||\r\n                (((bbox1.x < bbox2.x2 && bbox1.x > bbox2.x) ||\r\n                  (bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)) &&\r\n                  ((bbox1.y < bbox2.y2 && bbox1.y > bbox2.y) ||\r\n                    (bbox2.y < bbox1.y2 && bbox2.y > bbox1.y)))\r\n              );\r\n            };\r\n            function base3(t, p1, p2, p3, p4) {\r\n              var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,\r\n                t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\r\n              return t * t2 - 3 * p1 + 3 * p2;\r\n            }\r\n            function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {\r\n              if (z == null) {\r\n                z = 1;\r\n              }\r\n              z = z > 1 ? 1 : z < 0 ? 0 : z;\r\n              var z2 = z / 2,\r\n                n = 12,\r\n                Tvalues = [\r\n                  -0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699,\r\n                  0.7699, -0.9041, 0.9041, -0.9816, 0.9816,\r\n                ],\r\n                Cvalues = [\r\n                  0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601,\r\n                  0.1601, 0.1069, 0.1069, 0.0472, 0.0472,\r\n                ],\r\n                sum = 0;\r\n              for (var i = 0; i < n; i++) {\r\n                var ct = z2 * Tvalues[i] + z2,\r\n                  xbase = base3(ct, x1, x2, x3, x4),\r\n                  ybase = base3(ct, y1, y2, y3, y4),\r\n                  comb = xbase * xbase + ybase * ybase;\r\n                sum += Cvalues[i] * math.sqrt(comb);\r\n              }\r\n              return z2 * sum;\r\n            }\r\n            function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {\r\n              if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {\r\n                return;\r\n              }\r\n              var t = 1,\r\n                step = t / 2,\r\n                t2 = t - step,\r\n                l,\r\n                e = 0.01;\r\n              l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\r\n              while (abs(l - ll) > e) {\r\n                step /= 2;\r\n                t2 += (l < ll ? 1 : -1) * step;\r\n                l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\r\n              }\r\n              return t2;\r\n            }\r\n            function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\r\n              if (\r\n                mmax(x1, x2) < mmin(x3, x4) ||\r\n                mmin(x1, x2) > mmax(x3, x4) ||\r\n                mmax(y1, y2) < mmin(y3, y4) ||\r\n                mmin(y1, y2) > mmax(y3, y4)\r\n              ) {\r\n                return;\r\n              }\r\n              var nx =\r\n                  (x1 * y2 - y1 * x2) * (x3 - x4) -\r\n                  (x1 - x2) * (x3 * y4 - y3 * x4),\r\n                ny =\r\n                  (x1 * y2 - y1 * x2) * (y3 - y4) -\r\n                  (y1 - y2) * (x3 * y4 - y3 * x4),\r\n                denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\r\n\r\n              if (!denominator) {\r\n                return;\r\n              }\r\n              var px = nx / denominator,\r\n                py = ny / denominator,\r\n                px2 = +px.toFixed(2),\r\n                py2 = +py.toFixed(2);\r\n              if (\r\n                px2 < +mmin(x1, x2).toFixed(2) ||\r\n                px2 > +mmax(x1, x2).toFixed(2) ||\r\n                px2 < +mmin(x3, x4).toFixed(2) ||\r\n                px2 > +mmax(x3, x4).toFixed(2) ||\r\n                py2 < +mmin(y1, y2).toFixed(2) ||\r\n                py2 > +mmax(y1, y2).toFixed(2) ||\r\n                py2 < +mmin(y3, y4).toFixed(2) ||\r\n                py2 > +mmax(y3, y4).toFixed(2)\r\n              ) {\r\n                return;\r\n              }\r\n              return { x: px, y: py };\r\n            }\r\n            function inter(bez1, bez2) {\r\n              return interHelper(bez1, bez2);\r\n            }\r\n            function interCount(bez1, bez2) {\r\n              return interHelper(bez1, bez2, 1);\r\n            }\r\n            function interHelper(bez1, bez2, justCount) {\r\n              var bbox1 = R.bezierBBox(bez1),\r\n                bbox2 = R.bezierBBox(bez2);\r\n              if (!R.isBBoxIntersect(bbox1, bbox2)) {\r\n                return justCount ? 0 : [];\r\n              }\r\n              var l1 = bezlen.apply(0, bez1),\r\n                l2 = bezlen.apply(0, bez2),\r\n                n1 = mmax(~~(l1 / 5), 1),\r\n                n2 = mmax(~~(l2 / 5), 1),\r\n                dots1 = [],\r\n                dots2 = [],\r\n                xy = {},\r\n                res = justCount ? 0 : [];\r\n              for (var i = 0; i < n1 + 1; i++) {\r\n                var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));\r\n                dots1.push({ x: p.x, y: p.y, t: i / n1 });\r\n              }\r\n              for (i = 0; i < n2 + 1; i++) {\r\n                p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));\r\n                dots2.push({ x: p.x, y: p.y, t: i / n2 });\r\n              }\r\n              for (i = 0; i < n1; i++) {\r\n                for (var j = 0; j < n2; j++) {\r\n                  var di = dots1[i],\r\n                    di1 = dots1[i + 1],\r\n                    dj = dots2[j],\r\n                    dj1 = dots2[j + 1],\r\n                    ci = abs(di1.x - di.x) < 0.001 ? 'y' : 'x',\r\n                    cj = abs(dj1.x - dj.x) < 0.001 ? 'y' : 'x',\r\n                    is = intersect(\r\n                      di.x,\r\n                      di.y,\r\n                      di1.x,\r\n                      di1.y,\r\n                      dj.x,\r\n                      dj.y,\r\n                      dj1.x,\r\n                      dj1.y\r\n                    );\r\n                  if (is) {\r\n                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {\r\n                      continue;\r\n                    }\r\n                    xy[is.x.toFixed(4)] = is.y.toFixed(4);\r\n                    var t1 =\r\n                        di.t +\r\n                        abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) *\r\n                          (di1.t - di.t),\r\n                      t2 =\r\n                        dj.t +\r\n                        abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) *\r\n                          (dj1.t - dj.t);\r\n                    if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {\r\n                      if (justCount) {\r\n                        res++;\r\n                      } else {\r\n                        res.push({\r\n                          x: is.x,\r\n                          y: is.y,\r\n                          t1: mmin(t1, 1),\r\n                          t2: mmin(t2, 1),\r\n                        });\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n              return res;\r\n            }\r\n            /*\\\r\n     * Raphael.pathIntersection\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Finds intersections of two paths\r\n     > Parameters\r\n     - path1 (string) path string\r\n     - path2 (string) path string\r\n     = (array) dots of intersection\r\n     o [\r\n     o     {\r\n     o         x: (number) x coordinate of the point\r\n     o         y: (number) y coordinate of the point\r\n     o         t1: (number) t value for segment of path1\r\n     o         t2: (number) t value for segment of path2\r\n     o         segment1: (number) order number for segment of path1\r\n     o         segment2: (number) order number for segment of path2\r\n     o         bez1: (array) eight coordinates representing beziér curve for the segment of path1\r\n     o         bez2: (array) eight coordinates representing beziér curve for the segment of path2\r\n     o     }\r\n     o ]\r\n    \\*/\r\n            R.pathIntersection = function (path1, path2) {\r\n              return interPathHelper(path1, path2);\r\n            };\r\n            R.pathIntersectionNumber = function (path1, path2) {\r\n              return interPathHelper(path1, path2, 1);\r\n            };\r\n            function interPathHelper(path1, path2, justCount) {\r\n              path1 = R._path2curve(path1);\r\n              path2 = R._path2curve(path2);\r\n              var x1,\r\n                y1,\r\n                x2,\r\n                y2,\r\n                x1m,\r\n                y1m,\r\n                x2m,\r\n                y2m,\r\n                bez1,\r\n                bez2,\r\n                res = justCount ? 0 : [];\r\n              for (var i = 0, ii = path1.length; i < ii; i++) {\r\n                var pi = path1[i];\r\n                if (pi[0] == 'M') {\r\n                  x1 = x1m = pi[1];\r\n                  y1 = y1m = pi[2];\r\n                } else {\r\n                  if (pi[0] == 'C') {\r\n                    bez1 = [x1, y1].concat(pi.slice(1));\r\n                    x1 = bez1[6];\r\n                    y1 = bez1[7];\r\n                  } else {\r\n                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\r\n                    x1 = x1m;\r\n                    y1 = y1m;\r\n                  }\r\n                  for (var j = 0, jj = path2.length; j < jj; j++) {\r\n                    var pj = path2[j];\r\n                    if (pj[0] == 'M') {\r\n                      x2 = x2m = pj[1];\r\n                      y2 = y2m = pj[2];\r\n                    } else {\r\n                      if (pj[0] == 'C') {\r\n                        bez2 = [x2, y2].concat(pj.slice(1));\r\n                        x2 = bez2[6];\r\n                        y2 = bez2[7];\r\n                      } else {\r\n                        bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\r\n                        x2 = x2m;\r\n                        y2 = y2m;\r\n                      }\r\n                      var intr = interHelper(bez1, bez2, justCount);\r\n                      if (justCount) {\r\n                        res += intr;\r\n                      } else {\r\n                        for (var k = 0, kk = intr.length; k < kk; k++) {\r\n                          intr[k].segment1 = i;\r\n                          intr[k].segment2 = j;\r\n                          intr[k].bez1 = bez1;\r\n                          intr[k].bez2 = bez2;\r\n                        }\r\n                        res = res.concat(intr);\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n              return res;\r\n            }\r\n            /*\\\r\n     * Raphael.isPointInsidePath\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Returns `true` if given point is inside a given closed path.\r\n     > Parameters\r\n     - path (string) path string\r\n     - x (number) x of the point\r\n     - y (number) y of the point\r\n     = (boolean) true, if point is inside the path\r\n    \\*/\r\n            R.isPointInsidePath = function (path, x, y) {\r\n              var bbox = R.pathBBox(path);\r\n              return (\r\n                R.isPointInsideBBox(bbox, x, y) &&\r\n                interPathHelper(\r\n                  path,\r\n                  [\r\n                    ['M', x, y],\r\n                    ['H', bbox.x2 + 10],\r\n                  ],\r\n                  1\r\n                ) %\r\n                  2 ==\r\n                  1\r\n              );\r\n            };\r\n            R._removedFactory = function (methodname) {\r\n              return function () {\r\n                eve(\r\n                  'raphael.log',\r\n                  null,\r\n                  'Rapha\\xebl: you are calling to method \\u201c' +\r\n                    methodname +\r\n                    '\\u201d of removed object',\r\n                  methodname\r\n                );\r\n              };\r\n            };\r\n            /*\\\r\n     * Raphael.pathBBox\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Return bounding box of a given path\r\n     > Parameters\r\n     - path (string) path string\r\n     = (object) bounding box\r\n     o {\r\n     o     x: (number) x coordinate of the left top point of the box\r\n     o     y: (number) y coordinate of the left top point of the box\r\n     o     x2: (number) x coordinate of the right bottom point of the box\r\n     o     y2: (number) y coordinate of the right bottom point of the box\r\n     o     width: (number) width of the box\r\n     o     height: (number) height of the box\r\n     o     cx: (number) x coordinate of the center of the box\r\n     o     cy: (number) y coordinate of the center of the box\r\n     o }\r\n    \\*/\r\n            var pathDimensions = (R.pathBBox = function (path) {\r\n                var pth = paths(path);\r\n                if (pth.bbox) {\r\n                  return clone(pth.bbox);\r\n                }\r\n                if (!path) {\r\n                  return { x: 0, y: 0, width: 0, height: 0, x2: 0, y2: 0 };\r\n                }\r\n                path = path2curve(path);\r\n                var x = 0,\r\n                  y = 0,\r\n                  X = [],\r\n                  Y = [],\r\n                  p;\r\n                for (var i = 0, ii = path.length; i < ii; i++) {\r\n                  p = path[i];\r\n                  if (p[0] == 'M') {\r\n                    x = p[1];\r\n                    y = p[2];\r\n                    X.push(x);\r\n                    Y.push(y);\r\n                  } else {\r\n                    var dim = curveDim(\r\n                      x,\r\n                      y,\r\n                      p[1],\r\n                      p[2],\r\n                      p[3],\r\n                      p[4],\r\n                      p[5],\r\n                      p[6]\r\n                    );\r\n                    X = X[concat](dim.min.x, dim.max.x);\r\n                    Y = Y[concat](dim.min.y, dim.max.y);\r\n                    x = p[5];\r\n                    y = p[6];\r\n                  }\r\n                }\r\n                var xmin = mmin[apply](0, X),\r\n                  ymin = mmin[apply](0, Y),\r\n                  xmax = mmax[apply](0, X),\r\n                  ymax = mmax[apply](0, Y),\r\n                  width = xmax - xmin,\r\n                  height = ymax - ymin,\r\n                  bb = {\r\n                    x: xmin,\r\n                    y: ymin,\r\n                    x2: xmax,\r\n                    y2: ymax,\r\n                    width: width,\r\n                    height: height,\r\n                    cx: xmin + width / 2,\r\n                    cy: ymin + height / 2,\r\n                  };\r\n                pth.bbox = clone(bb);\r\n                return bb;\r\n              }),\r\n              pathClone = function (pathArray) {\r\n                var res = clone(pathArray);\r\n                res.toString = R._path2string;\r\n                return res;\r\n              },\r\n              pathToRelative = (R._pathToRelative = function (pathArray) {\r\n                var pth = paths(pathArray);\r\n                if (pth.rel) {\r\n                  return pathClone(pth.rel);\r\n                }\r\n                if (\r\n                  !R.is(pathArray, array) ||\r\n                  !R.is(pathArray && pathArray[0], array)\r\n                ) {\r\n                  // rough assumption\r\n                  pathArray = R.parsePathString(pathArray);\r\n                }\r\n                var res = [],\r\n                  x = 0,\r\n                  y = 0,\r\n                  mx = 0,\r\n                  my = 0,\r\n                  start = 0;\r\n                if (pathArray[0][0] == 'M') {\r\n                  x = pathArray[0][1];\r\n                  y = pathArray[0][2];\r\n                  mx = x;\r\n                  my = y;\r\n                  start++;\r\n                  res.push(['M', x, y]);\r\n                }\r\n                for (var i = start, ii = pathArray.length; i < ii; i++) {\r\n                  var r = (res[i] = []),\r\n                    pa = pathArray[i];\r\n                  if (pa[0] != lowerCase.call(pa[0])) {\r\n                    r[0] = lowerCase.call(pa[0]);\r\n                    switch (r[0]) {\r\n                      case 'a':\r\n                        r[1] = pa[1];\r\n                        r[2] = pa[2];\r\n                        r[3] = pa[3];\r\n                        r[4] = pa[4];\r\n                        r[5] = pa[5];\r\n                        r[6] = +(pa[6] - x).toFixed(3);\r\n                        r[7] = +(pa[7] - y).toFixed(3);\r\n                        break;\r\n                      case 'v':\r\n                        r[1] = +(pa[1] - y).toFixed(3);\r\n                        break;\r\n                      case 'm':\r\n                        mx = pa[1];\r\n                        my = pa[2];\r\n                      default:\r\n                        for (var j = 1, jj = pa.length; j < jj; j++) {\r\n                          r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);\r\n                        }\r\n                    }\r\n                  } else {\r\n                    r = res[i] = [];\r\n                    if (pa[0] == 'm') {\r\n                      mx = pa[1] + x;\r\n                      my = pa[2] + y;\r\n                    }\r\n                    for (var k = 0, kk = pa.length; k < kk; k++) {\r\n                      res[i][k] = pa[k];\r\n                    }\r\n                  }\r\n                  var len = res[i].length;\r\n                  switch (res[i][0]) {\r\n                    case 'z':\r\n                      x = mx;\r\n                      y = my;\r\n                      break;\r\n                    case 'h':\r\n                      x += +res[i][len - 1];\r\n                      break;\r\n                    case 'v':\r\n                      y += +res[i][len - 1];\r\n                      break;\r\n                    default:\r\n                      x += +res[i][len - 2];\r\n                      y += +res[i][len - 1];\r\n                  }\r\n                }\r\n                res.toString = R._path2string;\r\n                pth.rel = pathClone(res);\r\n                return res;\r\n              }),\r\n              pathToAbsolute = (R._pathToAbsolute = function (pathArray) {\r\n                var pth = paths(pathArray);\r\n                if (pth.abs) {\r\n                  return pathClone(pth.abs);\r\n                }\r\n                if (\r\n                  !R.is(pathArray, array) ||\r\n                  !R.is(pathArray && pathArray[0], array)\r\n                ) {\r\n                  // rough assumption\r\n                  pathArray = R.parsePathString(pathArray);\r\n                }\r\n                if (!pathArray || !pathArray.length) {\r\n                  return [['M', 0, 0]];\r\n                }\r\n                var res = [],\r\n                  x = 0,\r\n                  y = 0,\r\n                  mx = 0,\r\n                  my = 0,\r\n                  start = 0;\r\n                if (pathArray[0][0] == 'M') {\r\n                  x = +pathArray[0][1];\r\n                  y = +pathArray[0][2];\r\n                  mx = x;\r\n                  my = y;\r\n                  start++;\r\n                  res[0] = ['M', x, y];\r\n                }\r\n                var crz =\r\n                  pathArray.length == 3 &&\r\n                  pathArray[0][0] == 'M' &&\r\n                  pathArray[1][0].toUpperCase() == 'R' &&\r\n                  pathArray[2][0].toUpperCase() == 'Z';\r\n                for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {\r\n                  res.push((r = []));\r\n                  pa = pathArray[i];\r\n                  if (pa[0] != upperCase.call(pa[0])) {\r\n                    r[0] = upperCase.call(pa[0]);\r\n                    switch (r[0]) {\r\n                      case 'A':\r\n                        r[1] = pa[1];\r\n                        r[2] = pa[2];\r\n                        r[3] = pa[3];\r\n                        r[4] = pa[4];\r\n                        r[5] = pa[5];\r\n                        r[6] = +(pa[6] + x);\r\n                        r[7] = +(pa[7] + y);\r\n                        break;\r\n                      case 'V':\r\n                        r[1] = +pa[1] + y;\r\n                        break;\r\n                      case 'H':\r\n                        r[1] = +pa[1] + x;\r\n                        break;\r\n                      case 'R':\r\n                        var dots = [x, y][concat](pa.slice(1));\r\n                        for (var j = 2, jj = dots.length; j < jj; j++) {\r\n                          dots[j] = +dots[j] + x;\r\n                          dots[++j] = +dots[j] + y;\r\n                        }\r\n                        res.pop();\r\n                        res = res[concat](catmullRom2bezier(dots, crz));\r\n                        break;\r\n                      case 'M':\r\n                        mx = +pa[1] + x;\r\n                        my = +pa[2] + y;\r\n                      default:\r\n                        for (j = 1, jj = pa.length; j < jj; j++) {\r\n                          r[j] = +pa[j] + (j % 2 ? x : y);\r\n                        }\r\n                    }\r\n                  } else if (pa[0] == 'R') {\r\n                    dots = [x, y][concat](pa.slice(1));\r\n                    res.pop();\r\n                    res = res[concat](catmullRom2bezier(dots, crz));\r\n                    r = ['R'][concat](pa.slice(-2));\r\n                  } else {\r\n                    for (var k = 0, kk = pa.length; k < kk; k++) {\r\n                      r[k] = pa[k];\r\n                    }\r\n                  }\r\n                  switch (r[0]) {\r\n                    case 'Z':\r\n                      x = mx;\r\n                      y = my;\r\n                      break;\r\n                    case 'H':\r\n                      x = r[1];\r\n                      break;\r\n                    case 'V':\r\n                      y = r[1];\r\n                      break;\r\n                    case 'M':\r\n                      mx = r[r.length - 2];\r\n                      my = r[r.length - 1];\r\n                    default:\r\n                      x = r[r.length - 2];\r\n                      y = r[r.length - 1];\r\n                  }\r\n                }\r\n                res.toString = R._path2string;\r\n                pth.abs = pathClone(res);\r\n                return res;\r\n              }),\r\n              l2c = function (x1, y1, x2, y2) {\r\n                return [x1, y1, x2, y2, x2, y2];\r\n              },\r\n              q2c = function (x1, y1, ax, ay, x2, y2) {\r\n                var _13 = 1 / 3,\r\n                  _23 = 2 / 3;\r\n                return [\r\n                  _13 * x1 + _23 * ax,\r\n                  _13 * y1 + _23 * ay,\r\n                  _13 * x2 + _23 * ax,\r\n                  _13 * y2 + _23 * ay,\r\n                  x2,\r\n                  y2,\r\n                ];\r\n              },\r\n              a2c = function (\r\n                x1,\r\n                y1,\r\n                rx,\r\n                ry,\r\n                angle,\r\n                large_arc_flag,\r\n                sweep_flag,\r\n                x2,\r\n                y2,\r\n                recursive\r\n              ) {\r\n                // for more information of where this math came from visit:\r\n                // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\r\n                var _120 = (PI * 120) / 180,\r\n                  rad = (PI / 180) * (+angle || 0),\r\n                  res = [],\r\n                  xy,\r\n                  rotate = cacher(function (x, y, rad) {\r\n                    var X = x * math.cos(rad) - y * math.sin(rad),\r\n                      Y = x * math.sin(rad) + y * math.cos(rad);\r\n                    return { x: X, y: Y };\r\n                  });\r\n                if (!recursive) {\r\n                  xy = rotate(x1, y1, -rad);\r\n                  x1 = xy.x;\r\n                  y1 = xy.y;\r\n                  xy = rotate(x2, y2, -rad);\r\n                  x2 = xy.x;\r\n                  y2 = xy.y;\r\n                  var cos = math.cos((PI / 180) * angle),\r\n                    sin = math.sin((PI / 180) * angle),\r\n                    x = (x1 - x2) / 2,\r\n                    y = (y1 - y2) / 2;\r\n                  var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\r\n                  if (h > 1) {\r\n                    h = math.sqrt(h);\r\n                    rx = h * rx;\r\n                    ry = h * ry;\r\n                  }\r\n                  var rx2 = rx * rx,\r\n                    ry2 = ry * ry,\r\n                    k =\r\n                      (large_arc_flag == sweep_flag ? -1 : 1) *\r\n                      math.sqrt(\r\n                        abs(\r\n                          (rx2 * ry2 - rx2 * y * y - ry2 * x * x) /\r\n                            (rx2 * y * y + ry2 * x * x)\r\n                        )\r\n                      ),\r\n                    cx = (k * rx * y) / ry + (x1 + x2) / 2,\r\n                    cy = (k * -ry * x) / rx + (y1 + y2) / 2,\r\n                    f1 = math.asin(((y1 - cy) / ry).toFixed(9)),\r\n                    f2 = math.asin(((y2 - cy) / ry).toFixed(9));\r\n\r\n                  f1 = x1 < cx ? PI - f1 : f1;\r\n                  f2 = x2 < cx ? PI - f2 : f2;\r\n                  f1 < 0 && (f1 = PI * 2 + f1);\r\n                  f2 < 0 && (f2 = PI * 2 + f2);\r\n                  if (sweep_flag && f1 > f2) {\r\n                    f1 = f1 - PI * 2;\r\n                  }\r\n                  if (!sweep_flag && f2 > f1) {\r\n                    f2 = f2 - PI * 2;\r\n                  }\r\n                } else {\r\n                  f1 = recursive[0];\r\n                  f2 = recursive[1];\r\n                  cx = recursive[2];\r\n                  cy = recursive[3];\r\n                }\r\n                var df = f2 - f1;\r\n                if (abs(df) > _120) {\r\n                  var f2old = f2,\r\n                    x2old = x2,\r\n                    y2old = y2;\r\n                  f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\r\n                  x2 = cx + rx * math.cos(f2);\r\n                  y2 = cy + ry * math.sin(f2);\r\n                  res = a2c(\r\n                    x2,\r\n                    y2,\r\n                    rx,\r\n                    ry,\r\n                    angle,\r\n                    0,\r\n                    sweep_flag,\r\n                    x2old,\r\n                    y2old,\r\n                    [f2, f2old, cx, cy]\r\n                  );\r\n                }\r\n                df = f2 - f1;\r\n                var c1 = math.cos(f1),\r\n                  s1 = math.sin(f1),\r\n                  c2 = math.cos(f2),\r\n                  s2 = math.sin(f2),\r\n                  t = math.tan(df / 4),\r\n                  hx = (4 / 3) * rx * t,\r\n                  hy = (4 / 3) * ry * t,\r\n                  m1 = [x1, y1],\r\n                  m2 = [x1 + hx * s1, y1 - hy * c1],\r\n                  m3 = [x2 + hx * s2, y2 - hy * c2],\r\n                  m4 = [x2, y2];\r\n                m2[0] = 2 * m1[0] - m2[0];\r\n                m2[1] = 2 * m1[1] - m2[1];\r\n                if (recursive) {\r\n                  return [m2, m3, m4][concat](res);\r\n                } else {\r\n                  res = [m2, m3, m4][concat](res).join()[split](',');\r\n                  var newres = [];\r\n                  for (var i = 0, ii = res.length; i < ii; i++) {\r\n                    newres[i] =\r\n                      i % 2\r\n                        ? rotate(res[i - 1], res[i], rad).y\r\n                        : rotate(res[i], res[i + 1], rad).x;\r\n                  }\r\n                  return newres;\r\n                }\r\n              },\r\n              findDotAtSegment = function (\r\n                p1x,\r\n                p1y,\r\n                c1x,\r\n                c1y,\r\n                c2x,\r\n                c2y,\r\n                p2x,\r\n                p2y,\r\n                t\r\n              ) {\r\n                var t1 = 1 - t;\r\n                return {\r\n                  x:\r\n                    pow(t1, 3) * p1x +\r\n                    pow(t1, 2) * 3 * t * c1x +\r\n                    t1 * 3 * t * t * c2x +\r\n                    pow(t, 3) * p2x,\r\n                  y:\r\n                    pow(t1, 3) * p1y +\r\n                    pow(t1, 2) * 3 * t * c1y +\r\n                    t1 * 3 * t * t * c2y +\r\n                    pow(t, 3) * p2y,\r\n                };\r\n              },\r\n              curveDim = cacher(function (\r\n                p1x,\r\n                p1y,\r\n                c1x,\r\n                c1y,\r\n                c2x,\r\n                c2y,\r\n                p2x,\r\n                p2y\r\n              ) {\r\n                var a = c2x - 2 * c1x + p1x - (p2x - 2 * c2x + c1x),\r\n                  b = 2 * (c1x - p1x) - 2 * (c2x - c1x),\r\n                  c = p1x - c1x,\r\n                  t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,\r\n                  t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,\r\n                  y = [p1y, p2y],\r\n                  x = [p1x, p2x],\r\n                  dot;\r\n                abs(t1) > '1e12' && (t1 = 0.5);\r\n                abs(t2) > '1e12' && (t2 = 0.5);\r\n                if (t1 > 0 && t1 < 1) {\r\n                  dot = findDotAtSegment(\r\n                    p1x,\r\n                    p1y,\r\n                    c1x,\r\n                    c1y,\r\n                    c2x,\r\n                    c2y,\r\n                    p2x,\r\n                    p2y,\r\n                    t1\r\n                  );\r\n                  x.push(dot.x);\r\n                  y.push(dot.y);\r\n                }\r\n                if (t2 > 0 && t2 < 1) {\r\n                  dot = findDotAtSegment(\r\n                    p1x,\r\n                    p1y,\r\n                    c1x,\r\n                    c1y,\r\n                    c2x,\r\n                    c2y,\r\n                    p2x,\r\n                    p2y,\r\n                    t2\r\n                  );\r\n                  x.push(dot.x);\r\n                  y.push(dot.y);\r\n                }\r\n                a = c2y - 2 * c1y + p1y - (p2y - 2 * c2y + c1y);\r\n                b = 2 * (c1y - p1y) - 2 * (c2y - c1y);\r\n                c = p1y - c1y;\r\n                t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;\r\n                t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;\r\n                abs(t1) > '1e12' && (t1 = 0.5);\r\n                abs(t2) > '1e12' && (t2 = 0.5);\r\n                if (t1 > 0 && t1 < 1) {\r\n                  dot = findDotAtSegment(\r\n                    p1x,\r\n                    p1y,\r\n                    c1x,\r\n                    c1y,\r\n                    c2x,\r\n                    c2y,\r\n                    p2x,\r\n                    p2y,\r\n                    t1\r\n                  );\r\n                  x.push(dot.x);\r\n                  y.push(dot.y);\r\n                }\r\n                if (t2 > 0 && t2 < 1) {\r\n                  dot = findDotAtSegment(\r\n                    p1x,\r\n                    p1y,\r\n                    c1x,\r\n                    c1y,\r\n                    c2x,\r\n                    c2y,\r\n                    p2x,\r\n                    p2y,\r\n                    t2\r\n                  );\r\n                  x.push(dot.x);\r\n                  y.push(dot.y);\r\n                }\r\n                return {\r\n                  min: { x: mmin[apply](0, x), y: mmin[apply](0, y) },\r\n                  max: { x: mmax[apply](0, x), y: mmax[apply](0, y) },\r\n                };\r\n              }),\r\n              path2curve = (R._path2curve = cacher(\r\n                function (path, path2) {\r\n                  var pth = !path2 && paths(path);\r\n                  if (!path2 && pth.curve) {\r\n                    return pathClone(pth.curve);\r\n                  }\r\n                  var p = pathToAbsolute(path),\r\n                    p2 = path2 && pathToAbsolute(path2),\r\n                    attrs = {\r\n                      x: 0,\r\n                      y: 0,\r\n                      bx: 0,\r\n                      by: 0,\r\n                      X: 0,\r\n                      Y: 0,\r\n                      qx: null,\r\n                      qy: null,\r\n                    },\r\n                    attrs2 = {\r\n                      x: 0,\r\n                      y: 0,\r\n                      bx: 0,\r\n                      by: 0,\r\n                      X: 0,\r\n                      Y: 0,\r\n                      qx: null,\r\n                      qy: null,\r\n                    },\r\n                    processPath = function (path, d, pcom) {\r\n                      var nx,\r\n                        ny,\r\n                        tq = { T: 1, Q: 1 };\r\n                      if (!path) {\r\n                        return ['C', d.x, d.y, d.x, d.y, d.x, d.y];\r\n                      }\r\n                      !(path[0] in tq) && (d.qx = d.qy = null);\r\n                      switch (path[0]) {\r\n                        case 'M':\r\n                          d.X = path[1];\r\n                          d.Y = path[2];\r\n                          break;\r\n                        case 'A':\r\n                          path = ['C'][concat](\r\n                            a2c[apply](0, [d.x, d.y][concat](path.slice(1)))\r\n                          );\r\n                          break;\r\n                        case 'S':\r\n                          if (pcom == 'C' || pcom == 'S') {\r\n                            // In \"S\" case we have to take into account, if the previous command is C/S.\r\n                            nx = d.x * 2 - d.bx; // And reflect the previous\r\n                            ny = d.y * 2 - d.by; // command's control point relative to the current point.\r\n                          } else {\r\n                            // or some else or nothing\r\n                            nx = d.x;\r\n                            ny = d.y;\r\n                          }\r\n                          path = ['C', nx, ny][concat](path.slice(1));\r\n                          break;\r\n                        case 'T':\r\n                          if (pcom == 'Q' || pcom == 'T') {\r\n                            // In \"T\" case we have to take into account, if the previous command is Q/T.\r\n                            d.qx = d.x * 2 - d.qx; // And make a reflection similar\r\n                            d.qy = d.y * 2 - d.qy; // to case \"S\".\r\n                          } else {\r\n                            // or something else or nothing\r\n                            d.qx = d.x;\r\n                            d.qy = d.y;\r\n                          }\r\n                          path = ['C'][concat](\r\n                            q2c(d.x, d.y, d.qx, d.qy, path[1], path[2])\r\n                          );\r\n                          break;\r\n                        case 'Q':\r\n                          d.qx = path[1];\r\n                          d.qy = path[2];\r\n                          path = ['C'][concat](\r\n                            q2c(d.x, d.y, path[1], path[2], path[3], path[4])\r\n                          );\r\n                          break;\r\n                        case 'L':\r\n                          path = ['C'][concat](l2c(d.x, d.y, path[1], path[2]));\r\n                          break;\r\n                        case 'H':\r\n                          path = ['C'][concat](l2c(d.x, d.y, path[1], d.y));\r\n                          break;\r\n                        case 'V':\r\n                          path = ['C'][concat](l2c(d.x, d.y, d.x, path[1]));\r\n                          break;\r\n                        case 'Z':\r\n                          path = ['C'][concat](l2c(d.x, d.y, d.X, d.Y));\r\n                          break;\r\n                      }\r\n                      return path;\r\n                    },\r\n                    fixArc = function (pp, i) {\r\n                      if (pp[i].length > 7) {\r\n                        pp[i].shift();\r\n                        var pi = pp[i];\r\n                        while (pi.length) {\r\n                          pcoms1[i] = 'A'; // if created multiple C:s, their original seg is saved\r\n                          p2 && (pcoms2[i] = 'A'); // the same as above\r\n                          pp.splice(i++, 0, ['C'][concat](pi.splice(0, 6)));\r\n                        }\r\n                        pp.splice(i, 1);\r\n                        ii = mmax(p.length, (p2 && p2.length) || 0);\r\n                      }\r\n                    },\r\n                    fixM = function (path1, path2, a1, a2, i) {\r\n                      if (\r\n                        path1 &&\r\n                        path2 &&\r\n                        path1[i][0] == 'M' &&\r\n                        path2[i][0] != 'M'\r\n                      ) {\r\n                        path2.splice(i, 0, ['M', a2.x, a2.y]);\r\n                        a1.bx = 0;\r\n                        a1.by = 0;\r\n                        a1.x = path1[i][1];\r\n                        a1.y = path1[i][2];\r\n                        ii = mmax(p.length, (p2 && p2.length) || 0);\r\n                      }\r\n                    },\r\n                    pcoms1 = [], // path commands of original path p\r\n                    pcoms2 = [], // path commands of original path p2\r\n                    pfirst = '', // temporary holder for original path command\r\n                    pcom = ''; // holder for previous path command of original path\r\n                  for (\r\n                    var i = 0, ii = mmax(p.length, (p2 && p2.length) || 0);\r\n                    i < ii;\r\n                    i++\r\n                  ) {\r\n                    p[i] && (pfirst = p[i][0]); // save current path command\r\n\r\n                    if (pfirst != 'C') {\r\n                      // C is not saved yet, because it may be result of conversion\r\n                      pcoms1[i] = pfirst; // Save current path command\r\n                      i && (pcom = pcoms1[i - 1]); // Get previous path command pcom\r\n                    }\r\n                    p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\r\n\r\n                    if (pcoms1[i] != 'A' && pfirst == 'C') pcoms1[i] = 'C'; // A is the only command\r\n                    // which may produce multiple C:s\r\n                    // so we have to make sure that C is also C in original path\r\n\r\n                    fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\r\n\r\n                    if (p2) {\r\n                      // the same procedures is done to p2\r\n                      p2[i] && (pfirst = p2[i][0]);\r\n                      if (pfirst != 'C') {\r\n                        pcoms2[i] = pfirst;\r\n                        i && (pcom = pcoms2[i - 1]);\r\n                      }\r\n                      p2[i] = processPath(p2[i], attrs2, pcom);\r\n\r\n                      if (pcoms2[i] != 'A' && pfirst == 'C') pcoms2[i] = 'C';\r\n\r\n                      fixArc(p2, i);\r\n                    }\r\n                    fixM(p, p2, attrs, attrs2, i);\r\n                    fixM(p2, p, attrs2, attrs, i);\r\n                    var seg = p[i],\r\n                      seg2 = p2 && p2[i],\r\n                      seglen = seg.length,\r\n                      seg2len = p2 && seg2.length;\r\n                    attrs.x = seg[seglen - 2];\r\n                    attrs.y = seg[seglen - 1];\r\n                    attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;\r\n                    attrs.by = toFloat(seg[seglen - 3]) || attrs.y;\r\n                    attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);\r\n                    attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);\r\n                    attrs2.x = p2 && seg2[seg2len - 2];\r\n                    attrs2.y = p2 && seg2[seg2len - 1];\r\n                  }\r\n                  if (!p2) {\r\n                    pth.curve = pathClone(p);\r\n                  }\r\n                  return p2 ? [p, p2] : p;\r\n                },\r\n                null,\r\n                pathClone\r\n              )),\r\n              parseDots = (R._parseDots = cacher(function (gradient) {\r\n                var dots = [];\r\n                for (var i = 0, ii = gradient.length; i < ii; i++) {\r\n                  var dot = {},\r\n                    par = gradient[i].match(/^([^:]*):?([\\d\\.]*)/);\r\n                  dot.color = R.getRGB(par[1]);\r\n                  if (dot.color.error) {\r\n                    return null;\r\n                  }\r\n                  dot.opacity = dot.color.opacity;\r\n                  dot.color = dot.color.hex;\r\n                  par[2] && (dot.offset = par[2] + '%');\r\n                  dots.push(dot);\r\n                }\r\n                for (i = 1, ii = dots.length - 1; i < ii; i++) {\r\n                  if (!dots[i].offset) {\r\n                    var start = toFloat(dots[i - 1].offset || 0),\r\n                      end = 0;\r\n                    for (var j = i + 1; j < ii; j++) {\r\n                      if (dots[j].offset) {\r\n                        end = dots[j].offset;\r\n                        break;\r\n                      }\r\n                    }\r\n                    if (!end) {\r\n                      end = 100;\r\n                      j = ii;\r\n                    }\r\n                    end = toFloat(end);\r\n                    var d = (end - start) / (j - i + 1);\r\n                    for (; i < j; i++) {\r\n                      start += d;\r\n                      dots[i].offset = start + '%';\r\n                    }\r\n                  }\r\n                }\r\n                return dots;\r\n              })),\r\n              tear = (R._tear = function (el, paper) {\r\n                el == paper.top && (paper.top = el.prev);\r\n                el == paper.bottom && (paper.bottom = el.next);\r\n                el.next && (el.next.prev = el.prev);\r\n                el.prev && (el.prev.next = el.next);\r\n              }),\r\n              tofront = (R._tofront = function (el, paper) {\r\n                if (paper.top === el) {\r\n                  return;\r\n                }\r\n                tear(el, paper);\r\n                el.next = null;\r\n                el.prev = paper.top;\r\n                paper.top.next = el;\r\n                paper.top = el;\r\n              }),\r\n              toback = (R._toback = function (el, paper) {\r\n                if (paper.bottom === el) {\r\n                  return;\r\n                }\r\n                tear(el, paper);\r\n                el.next = paper.bottom;\r\n                el.prev = null;\r\n                paper.bottom.prev = el;\r\n                paper.bottom = el;\r\n              }),\r\n              insertafter = (R._insertafter = function (el, el2, paper) {\r\n                tear(el, paper);\r\n                el2 == paper.top && (paper.top = el);\r\n                el2.next && (el2.next.prev = el);\r\n                el.next = el2.next;\r\n                el.prev = el2;\r\n                el2.next = el;\r\n              }),\r\n              insertbefore = (R._insertbefore = function (el, el2, paper) {\r\n                tear(el, paper);\r\n                el2 == paper.bottom && (paper.bottom = el);\r\n                el2.prev && (el2.prev.next = el);\r\n                el.prev = el2.prev;\r\n                el2.prev = el;\r\n                el.next = el2;\r\n              }),\r\n              /*\\\r\n         * Raphael.toMatrix\r\n         [ method ]\r\n         **\r\n         * Utility method\r\n         **\r\n         * Returns matrix of transformations applied to a given path\r\n         > Parameters\r\n         - path (string) path string\r\n         - transform (string|array) transformation string\r\n         = (object) @Matrix\r\n        \\*/\r\n              toMatrix = (R.toMatrix = function (path, transform) {\r\n                var bb = pathDimensions(path),\r\n                  el = {\r\n                    _: {\r\n                      transform: E,\r\n                    },\r\n                    getBBox: function () {\r\n                      return bb;\r\n                    },\r\n                  };\r\n                extractTransform(el, transform);\r\n                return el.matrix;\r\n              }),\r\n              /*\\\r\n         * Raphael.transformPath\r\n         [ method ]\r\n         **\r\n         * Utility method\r\n         **\r\n         * Returns path transformed by a given transformation\r\n         > Parameters\r\n         - path (string) path string\r\n         - transform (string|array) transformation string\r\n         = (string) path\r\n        \\*/\r\n              transformPath = (R.transformPath = function (path, transform) {\r\n                return mapPath(path, toMatrix(path, transform));\r\n              }),\r\n              extractTransform = (R._extractTransform = function (el, tstr) {\r\n                if (tstr == null) {\r\n                  return el._.transform;\r\n                }\r\n                tstr = Str(tstr).replace(/\\.{3}|\\u2026/g, el._.transform || E);\r\n                var tdata = R.parseTransformString(tstr),\r\n                  deg = 0,\r\n                  dx = 0,\r\n                  dy = 0,\r\n                  sx = 1,\r\n                  sy = 1,\r\n                  _ = el._,\r\n                  m = new Matrix();\r\n                _.transform = tdata || [];\r\n                if (tdata) {\r\n                  for (var i = 0, ii = tdata.length; i < ii; i++) {\r\n                    var t = tdata[i],\r\n                      tlen = t.length,\r\n                      command = Str(t[0]).toLowerCase(),\r\n                      absolute = t[0] != command,\r\n                      inver = absolute ? m.invert() : 0,\r\n                      x1,\r\n                      y1,\r\n                      x2,\r\n                      y2,\r\n                      bb;\r\n                    if (command == 't' && tlen == 3) {\r\n                      if (absolute) {\r\n                        x1 = inver.x(0, 0);\r\n                        y1 = inver.y(0, 0);\r\n                        x2 = inver.x(t[1], t[2]);\r\n                        y2 = inver.y(t[1], t[2]);\r\n                        m.translate(x2 - x1, y2 - y1);\r\n                      } else {\r\n                        m.translate(t[1], t[2]);\r\n                      }\r\n                    } else if (command == 'r') {\r\n                      if (tlen == 2) {\r\n                        bb = bb || el.getBBox(1);\r\n                        m.rotate(\r\n                          t[1],\r\n                          bb.x + bb.width / 2,\r\n                          bb.y + bb.height / 2\r\n                        );\r\n                        deg += t[1];\r\n                      } else if (tlen == 4) {\r\n                        if (absolute) {\r\n                          x2 = inver.x(t[2], t[3]);\r\n                          y2 = inver.y(t[2], t[3]);\r\n                          m.rotate(t[1], x2, y2);\r\n                        } else {\r\n                          m.rotate(t[1], t[2], t[3]);\r\n                        }\r\n                        deg += t[1];\r\n                      }\r\n                    } else if (command == 's') {\r\n                      if (tlen == 2 || tlen == 3) {\r\n                        bb = bb || el.getBBox(1);\r\n                        m.scale(\r\n                          t[1],\r\n                          t[tlen - 1],\r\n                          bb.x + bb.width / 2,\r\n                          bb.y + bb.height / 2\r\n                        );\r\n                        sx *= t[1];\r\n                        sy *= t[tlen - 1];\r\n                      } else if (tlen == 5) {\r\n                        if (absolute) {\r\n                          x2 = inver.x(t[3], t[4]);\r\n                          y2 = inver.y(t[3], t[4]);\r\n                          m.scale(t[1], t[2], x2, y2);\r\n                        } else {\r\n                          m.scale(t[1], t[2], t[3], t[4]);\r\n                        }\r\n                        sx *= t[1];\r\n                        sy *= t[2];\r\n                      }\r\n                    } else if (command == 'm' && tlen == 7) {\r\n                      m.add(t[1], t[2], t[3], t[4], t[5], t[6]);\r\n                    }\r\n                    _.dirtyT = 1;\r\n                    el.matrix = m;\r\n                  }\r\n                }\r\n\r\n                /*\\\r\n             * Element.matrix\r\n             [ property (object) ]\r\n             **\r\n             * Keeps @Matrix object, which represents element transformation\r\n            \\*/\r\n                el.matrix = m;\r\n\r\n                _.sx = sx;\r\n                _.sy = sy;\r\n                _.deg = deg;\r\n                _.dx = dx = m.e;\r\n                _.dy = dy = m.f;\r\n\r\n                if (sx == 1 && sy == 1 && !deg && _.bbox) {\r\n                  _.bbox.x += +dx;\r\n                  _.bbox.y += +dy;\r\n                } else {\r\n                  _.dirtyT = 1;\r\n                }\r\n              }),\r\n              getEmpty = function (item) {\r\n                var l = item[0];\r\n                switch (l.toLowerCase()) {\r\n                  case 't':\r\n                    return [l, 0, 0];\r\n                  case 'm':\r\n                    return [l, 1, 0, 0, 1, 0, 0];\r\n                  case 'r':\r\n                    if (item.length == 4) {\r\n                      return [l, 0, item[2], item[3]];\r\n                    } else {\r\n                      return [l, 0];\r\n                    }\r\n                  case 's':\r\n                    if (item.length == 5) {\r\n                      return [l, 1, 1, item[3], item[4]];\r\n                    } else if (item.length == 3) {\r\n                      return [l, 1, 1];\r\n                    } else {\r\n                      return [l, 1];\r\n                    }\r\n                }\r\n              },\r\n              equaliseTransform = (R._equaliseTransform = function (t1, t2) {\r\n                t2 = Str(t2).replace(/\\.{3}|\\u2026/g, t1);\r\n                t1 = R.parseTransformString(t1) || [];\r\n                t2 = R.parseTransformString(t2) || [];\r\n                var maxlength = mmax(t1.length, t2.length),\r\n                  from = [],\r\n                  to = [],\r\n                  i = 0,\r\n                  j,\r\n                  jj,\r\n                  tt1,\r\n                  tt2;\r\n                for (; i < maxlength; i++) {\r\n                  tt1 = t1[i] || getEmpty(t2[i]);\r\n                  tt2 = t2[i] || getEmpty(tt1);\r\n                  if (\r\n                    tt1[0] != tt2[0] ||\r\n                    (tt1[0].toLowerCase() == 'r' &&\r\n                      (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||\r\n                    (tt1[0].toLowerCase() == 's' &&\r\n                      (tt1[3] != tt2[3] || tt1[4] != tt2[4]))\r\n                  ) {\r\n                    return;\r\n                  }\r\n                  from[i] = [];\r\n                  to[i] = [];\r\n                  for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {\r\n                    j in tt1 && (from[i][j] = tt1[j]);\r\n                    j in tt2 && (to[i][j] = tt2[j]);\r\n                  }\r\n                }\r\n                return {\r\n                  from: from,\r\n                  to: to,\r\n                };\r\n              });\r\n            R._getContainer = function (x, y, w, h) {\r\n              var container;\r\n              container =\r\n                h == null && !R.is(x, 'object') ? g.doc.getElementById(x) : x;\r\n              if (container == null) {\r\n                return;\r\n              }\r\n              if (container.tagName) {\r\n                if (y == null) {\r\n                  return {\r\n                    container: container,\r\n                    width: container.style.pixelWidth || container.offsetWidth,\r\n                    height:\r\n                      container.style.pixelHeight || container.offsetHeight,\r\n                  };\r\n                } else {\r\n                  return {\r\n                    container: container,\r\n                    width: y,\r\n                    height: w,\r\n                  };\r\n                }\r\n              }\r\n              return {\r\n                container: 1,\r\n                x: x,\r\n                y: y,\r\n                width: w,\r\n                height: h,\r\n              };\r\n            };\r\n            /*\\\r\n     * Raphael.pathToRelative\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Converts path to relative form\r\n     > Parameters\r\n     - pathString (string|array) path string or array of segments\r\n     = (array) array of segments.\r\n    \\*/\r\n            R.pathToRelative = pathToRelative;\r\n            R._engine = {};\r\n            /*\\\r\n     * Raphael.path2curve\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Converts path to a new path where all segments are cubic bezier curves.\r\n     > Parameters\r\n     - pathString (string|array) path string or array of segments\r\n     = (array) array of segments.\r\n    \\*/\r\n            R.path2curve = path2curve;\r\n            /*\\\r\n     * Raphael.matrix\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Returns matrix based on given parameters.\r\n     > Parameters\r\n     - a (number)\r\n     - b (number)\r\n     - c (number)\r\n     - d (number)\r\n     - e (number)\r\n     - f (number)\r\n     = (object) @Matrix\r\n    \\*/\r\n            R.matrix = function (a, b, c, d, e, f) {\r\n              return new Matrix(a, b, c, d, e, f);\r\n            };\r\n            function Matrix(a, b, c, d, e, f) {\r\n              if (a != null) {\r\n                this.a = +a;\r\n                this.b = +b;\r\n                this.c = +c;\r\n                this.d = +d;\r\n                this.e = +e;\r\n                this.f = +f;\r\n              } else {\r\n                this.a = 1;\r\n                this.b = 0;\r\n                this.c = 0;\r\n                this.d = 1;\r\n                this.e = 0;\r\n                this.f = 0;\r\n              }\r\n            }\r\n            (function (matrixproto) {\r\n              /*\\\r\n         * Matrix.add\r\n         [ method ]\r\n         **\r\n         * Adds given matrix to existing one.\r\n         > Parameters\r\n         - a (number)\r\n         - b (number)\r\n         - c (number)\r\n         - d (number)\r\n         - e (number)\r\n         - f (number)\r\n         or\r\n         - matrix (object) @Matrix\r\n        \\*/\r\n              matrixproto.add = function (a, b, c, d, e, f) {\r\n                var out = [[], [], []],\r\n                  m = [\r\n                    [this.a, this.c, this.e],\r\n                    [this.b, this.d, this.f],\r\n                    [0, 0, 1],\r\n                  ],\r\n                  matrix = [\r\n                    [a, c, e],\r\n                    [b, d, f],\r\n                    [0, 0, 1],\r\n                  ],\r\n                  x,\r\n                  y,\r\n                  z,\r\n                  res;\r\n\r\n                if (a && a instanceof Matrix) {\r\n                  matrix = [\r\n                    [a.a, a.c, a.e],\r\n                    [a.b, a.d, a.f],\r\n                    [0, 0, 1],\r\n                  ];\r\n                }\r\n\r\n                for (x = 0; x < 3; x++) {\r\n                  for (y = 0; y < 3; y++) {\r\n                    res = 0;\r\n                    for (z = 0; z < 3; z++) {\r\n                      res += m[x][z] * matrix[z][y];\r\n                    }\r\n                    out[x][y] = res;\r\n                  }\r\n                }\r\n                this.a = out[0][0];\r\n                this.b = out[1][0];\r\n                this.c = out[0][1];\r\n                this.d = out[1][1];\r\n                this.e = out[0][2];\r\n                this.f = out[1][2];\r\n              };\r\n              /*\\\r\n         * Matrix.invert\r\n         [ method ]\r\n         **\r\n         * Returns inverted version of the matrix\r\n         = (object) @Matrix\r\n        \\*/\r\n              matrixproto.invert = function () {\r\n                var me = this,\r\n                  x = me.a * me.d - me.b * me.c;\r\n                return new Matrix(\r\n                  me.d / x,\r\n                  -me.b / x,\r\n                  -me.c / x,\r\n                  me.a / x,\r\n                  (me.c * me.f - me.d * me.e) / x,\r\n                  (me.b * me.e - me.a * me.f) / x\r\n                );\r\n              };\r\n              /*\\\r\n         * Matrix.clone\r\n         [ method ]\r\n         **\r\n         * Returns copy of the matrix\r\n         = (object) @Matrix\r\n        \\*/\r\n              matrixproto.clone = function () {\r\n                return new Matrix(\r\n                  this.a,\r\n                  this.b,\r\n                  this.c,\r\n                  this.d,\r\n                  this.e,\r\n                  this.f\r\n                );\r\n              };\r\n              /*\\\r\n         * Matrix.translate\r\n         [ method ]\r\n         **\r\n         * Translate the matrix\r\n         > Parameters\r\n         - x (number)\r\n         - y (number)\r\n        \\*/\r\n              matrixproto.translate = function (x, y) {\r\n                this.add(1, 0, 0, 1, x, y);\r\n              };\r\n              /*\\\r\n         * Matrix.scale\r\n         [ method ]\r\n         **\r\n         * Scales the matrix\r\n         > Parameters\r\n         - x (number)\r\n         - y (number) #optional\r\n         - cx (number) #optional\r\n         - cy (number) #optional\r\n        \\*/\r\n              matrixproto.scale = function (x, y, cx, cy) {\r\n                y == null && (y = x);\r\n                (cx || cy) && this.add(1, 0, 0, 1, cx, cy);\r\n                this.add(x, 0, 0, y, 0, 0);\r\n                (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);\r\n              };\r\n              /*\\\r\n         * Matrix.rotate\r\n         [ method ]\r\n         **\r\n         * Rotates the matrix\r\n         > Parameters\r\n         - a (number)\r\n         - x (number)\r\n         - y (number)\r\n        \\*/\r\n              matrixproto.rotate = function (a, x, y) {\r\n                a = R.rad(a);\r\n                x = x || 0;\r\n                y = y || 0;\r\n                var cos = +math.cos(a).toFixed(9),\r\n                  sin = +math.sin(a).toFixed(9);\r\n                this.add(cos, sin, -sin, cos, x, y);\r\n                this.add(1, 0, 0, 1, -x, -y);\r\n              };\r\n              /*\\\r\n         * Matrix.x\r\n         [ method ]\r\n         **\r\n         * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y\r\n         > Parameters\r\n         - x (number)\r\n         - y (number)\r\n         = (number) x\r\n        \\*/\r\n              matrixproto.x = function (x, y) {\r\n                return x * this.a + y * this.c + this.e;\r\n              };\r\n              /*\\\r\n         * Matrix.y\r\n         [ method ]\r\n         **\r\n         * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x\r\n         > Parameters\r\n         - x (number)\r\n         - y (number)\r\n         = (number) y\r\n        \\*/\r\n              matrixproto.y = function (x, y) {\r\n                return x * this.b + y * this.d + this.f;\r\n              };\r\n              matrixproto.get = function (i) {\r\n                return +this[Str.fromCharCode(97 + i)].toFixed(4);\r\n              };\r\n              matrixproto.toString = function () {\r\n                return R.svg\r\n                  ? 'matrix(' +\r\n                      [\r\n                        this.get(0),\r\n                        this.get(1),\r\n                        this.get(2),\r\n                        this.get(3),\r\n                        this.get(4),\r\n                        this.get(5),\r\n                      ].join() +\r\n                      ')'\r\n                  : [\r\n                      this.get(0),\r\n                      this.get(2),\r\n                      this.get(1),\r\n                      this.get(3),\r\n                      0,\r\n                      0,\r\n                    ].join();\r\n              };\r\n              matrixproto.toFilter = function () {\r\n                return (\r\n                  'progid:DXImageTransform.Microsoft.Matrix(M11=' +\r\n                  this.get(0) +\r\n                  ', M12=' +\r\n                  this.get(2) +\r\n                  ', M21=' +\r\n                  this.get(1) +\r\n                  ', M22=' +\r\n                  this.get(3) +\r\n                  ', Dx=' +\r\n                  this.get(4) +\r\n                  ', Dy=' +\r\n                  this.get(5) +\r\n                  \", sizingmethod='auto expand')\"\r\n                );\r\n              };\r\n              matrixproto.offset = function () {\r\n                return [this.e.toFixed(4), this.f.toFixed(4)];\r\n              };\r\n              function norm(a) {\r\n                return a[0] * a[0] + a[1] * a[1];\r\n              }\r\n              function normalize(a) {\r\n                var mag = math.sqrt(norm(a));\r\n                a[0] && (a[0] /= mag);\r\n                a[1] && (a[1] /= mag);\r\n              }\r\n              /*\\\r\n         * Matrix.split\r\n         [ method ]\r\n         **\r\n         * Splits matrix into primitive transformations\r\n         = (object) in format:\r\n         o dx (number) translation by x\r\n         o dy (number) translation by y\r\n         o scalex (number) scale by x\r\n         o scaley (number) scale by y\r\n         o shear (number) shear\r\n         o rotate (number) rotation in deg\r\n         o isSimple (boolean) could it be represented via simple transformations\r\n        \\*/\r\n              matrixproto.split = function () {\r\n                var out = {};\r\n                // translation\r\n                out.dx = this.e;\r\n                out.dy = this.f;\r\n\r\n                // scale and shear\r\n                var row = [\r\n                  [this.a, this.c],\r\n                  [this.b, this.d],\r\n                ];\r\n                out.scalex = math.sqrt(norm(row[0]));\r\n                normalize(row[0]);\r\n\r\n                out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];\r\n                row[1] = [\r\n                  row[1][0] - row[0][0] * out.shear,\r\n                  row[1][1] - row[0][1] * out.shear,\r\n                ];\r\n\r\n                out.scaley = math.sqrt(norm(row[1]));\r\n                normalize(row[1]);\r\n                out.shear /= out.scaley;\r\n\r\n                // rotation\r\n                var sin = -row[0][1],\r\n                  cos = row[1][1];\r\n                if (cos < 0) {\r\n                  out.rotate = R.deg(math.acos(cos));\r\n                  if (sin < 0) {\r\n                    out.rotate = 360 - out.rotate;\r\n                  }\r\n                } else {\r\n                  out.rotate = R.deg(math.asin(sin));\r\n                }\r\n\r\n                out.isSimple =\r\n                  !+out.shear.toFixed(9) &&\r\n                  (out.scalex.toFixed(9) == out.scaley.toFixed(9) ||\r\n                    !out.rotate);\r\n                out.isSuperSimple =\r\n                  !+out.shear.toFixed(9) &&\r\n                  out.scalex.toFixed(9) == out.scaley.toFixed(9) &&\r\n                  !out.rotate;\r\n                out.noRotation = !+out.shear.toFixed(9) && !out.rotate;\r\n                return out;\r\n              };\r\n              /*\\\r\n         * Matrix.toTransformString\r\n         [ method ]\r\n         **\r\n         * Return transform string that represents given matrix\r\n         = (string) transform string\r\n        \\*/\r\n              matrixproto.toTransformString = function (shorter) {\r\n                var s = shorter || this[split]();\r\n                if (s.isSimple) {\r\n                  s.scalex = +s.scalex.toFixed(4);\r\n                  s.scaley = +s.scaley.toFixed(4);\r\n                  s.rotate = +s.rotate.toFixed(4);\r\n                  return (\r\n                    (s.dx || s.dy ? 't' + [s.dx, s.dy] : E) +\r\n                    (s.scalex != 1 || s.scaley != 1\r\n                      ? 's' + [s.scalex, s.scaley, 0, 0]\r\n                      : E) +\r\n                    (s.rotate ? 'r' + [s.rotate, 0, 0] : E)\r\n                  );\r\n                } else {\r\n                  return (\r\n                    'm' +\r\n                    [\r\n                      this.get(0),\r\n                      this.get(1),\r\n                      this.get(2),\r\n                      this.get(3),\r\n                      this.get(4),\r\n                      this.get(5),\r\n                    ]\r\n                  );\r\n                }\r\n              };\r\n            })(Matrix.prototype);\r\n\r\n            var preventDefault = function () {\r\n                this.returnValue = false;\r\n              },\r\n              preventTouch = function () {\r\n                return this.originalEvent.preventDefault();\r\n              },\r\n              stopPropagation = function () {\r\n                this.cancelBubble = true;\r\n              },\r\n              stopTouch = function () {\r\n                return this.originalEvent.stopPropagation();\r\n              },\r\n              getEventPosition = function (e) {\r\n                var scrollY =\r\n                    g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\r\n                  scrollX =\r\n                    g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;\r\n\r\n                return {\r\n                  x: e.clientX + scrollX,\r\n                  y: e.clientY + scrollY,\r\n                };\r\n              },\r\n              addEvent = (function () {\r\n                if (g.doc.addEventListener) {\r\n                  return function (obj, type, fn, element) {\r\n                    var f = function (e) {\r\n                      var pos = getEventPosition(e);\r\n                      return fn.call(element, e, pos.x, pos.y);\r\n                    };\r\n                    obj.addEventListener(type, f, false);\r\n\r\n                    if (supportsTouch && touchMap[type]) {\r\n                      var _f = function (e) {\r\n                        var pos = getEventPosition(e),\r\n                          olde = e;\r\n\r\n                        for (\r\n                          var i = 0,\r\n                            ii = e.targetTouches && e.targetTouches.length;\r\n                          i < ii;\r\n                          i++\r\n                        ) {\r\n                          if (e.targetTouches[i].target == obj) {\r\n                            e = e.targetTouches[i];\r\n                            e.originalEvent = olde;\r\n                            e.preventDefault = preventTouch;\r\n                            e.stopPropagation = stopTouch;\r\n                            break;\r\n                          }\r\n                        }\r\n\r\n                        return fn.call(element, e, pos.x, pos.y);\r\n                      };\r\n                      obj.addEventListener(touchMap[type], _f, false);\r\n                    }\r\n\r\n                    return function () {\r\n                      obj.removeEventListener(type, f, false);\r\n\r\n                      if (supportsTouch && touchMap[type])\r\n                        obj.removeEventListener(touchMap[type], _f, false);\r\n\r\n                      return true;\r\n                    };\r\n                  };\r\n                } else if (g.doc.attachEvent) {\r\n                  return function (obj, type, fn, element) {\r\n                    var f = function (e) {\r\n                      e = e || g.win.event;\r\n                      var scrollY =\r\n                          g.doc.documentElement.scrollTop ||\r\n                          g.doc.body.scrollTop,\r\n                        scrollX =\r\n                          g.doc.documentElement.scrollLeft ||\r\n                          g.doc.body.scrollLeft,\r\n                        x = e.clientX + scrollX,\r\n                        y = e.clientY + scrollY;\r\n                      e.preventDefault = e.preventDefault || preventDefault;\r\n                      e.stopPropagation = e.stopPropagation || stopPropagation;\r\n                      return fn.call(element, e, x, y);\r\n                    };\r\n                    obj.attachEvent('on' + type, f);\r\n                    var detacher = function () {\r\n                      obj.detachEvent('on' + type, f);\r\n                      return true;\r\n                    };\r\n                    return detacher;\r\n                  };\r\n                }\r\n              })(),\r\n              drag = [],\r\n              dragMove = function (e) {\r\n                var x = e.clientX,\r\n                  y = e.clientY,\r\n                  scrollY =\r\n                    g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\r\n                  scrollX =\r\n                    g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,\r\n                  dragi,\r\n                  j = drag.length;\r\n                while (j--) {\r\n                  dragi = drag[j];\r\n                  if (supportsTouch && e.touches) {\r\n                    var i = e.touches.length,\r\n                      touch;\r\n                    while (i--) {\r\n                      touch = e.touches[i];\r\n                      if (touch.identifier == dragi.el._drag.id) {\r\n                        x = touch.clientX;\r\n                        y = touch.clientY;\r\n                        (e.originalEvent\r\n                          ? e.originalEvent\r\n                          : e\r\n                        ).preventDefault();\r\n                        break;\r\n                      }\r\n                    }\r\n                  } else {\r\n                    e.preventDefault();\r\n                  }\r\n                  var node = dragi.el.node,\r\n                    o,\r\n                    next = node.nextSibling,\r\n                    parent = node.parentNode,\r\n                    display = node.style.display;\r\n                  g.win.opera && parent.removeChild(node);\r\n                  node.style.display = 'none';\r\n                  o = dragi.el.paper.getElementByPoint(x, y);\r\n                  node.style.display = display;\r\n                  g.win.opera &&\r\n                    (next\r\n                      ? parent.insertBefore(node, next)\r\n                      : parent.appendChild(node));\r\n                  o && eve('raphael.drag.over.' + dragi.el.id, dragi.el, o);\r\n                  x += scrollX;\r\n                  y += scrollY;\r\n                  eve(\r\n                    'raphael.drag.move.' + dragi.el.id,\r\n                    dragi.move_scope || dragi.el,\r\n                    x - dragi.el._drag.x,\r\n                    y - dragi.el._drag.y,\r\n                    x,\r\n                    y,\r\n                    e\r\n                  );\r\n                }\r\n              },\r\n              dragUp = function (e) {\r\n                R.unmousemove(dragMove).unmouseup(dragUp);\r\n                var i = drag.length,\r\n                  dragi;\r\n                while (i--) {\r\n                  dragi = drag[i];\r\n                  dragi.el._drag = {};\r\n                  eve(\r\n                    'raphael.drag.end.' + dragi.el.id,\r\n                    dragi.end_scope ||\r\n                      dragi.start_scope ||\r\n                      dragi.move_scope ||\r\n                      dragi.el,\r\n                    e\r\n                  );\r\n                }\r\n                drag = [];\r\n              },\r\n              /*\\\r\n     * Raphael.el\r\n     [ property (object) ]\r\n     **\r\n     * You can add your own method to elements. This is useful when you want to hack default functionality or\r\n     * want to wrap some common transformation or attributes in one method. In difference to canvas methods,\r\n     * you can redefine element method at any time. Expending element methods wouldn’t affect set.\r\n     > Usage\r\n     | Raphael.el.red = function () {\r\n     |     this.attr({fill: \"#f00\"});\r\n     | };\r\n     | // then use it\r\n     | paper.circle(100, 100, 20).red();\r\n    \\*/\r\n              elproto = (R.el = {});\r\n            /*\\\r\n     * Element.click\r\n     [ method ]\r\n     **\r\n     * Adds event handler for click for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n            /*\\\r\n     * Element.unclick\r\n     [ method ]\r\n     **\r\n     * Removes event handler for click for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n\r\n            /*\\\r\n     * Element.dblclick\r\n     [ method ]\r\n     **\r\n     * Adds event handler for double click for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n            /*\\\r\n     * Element.undblclick\r\n     [ method ]\r\n     **\r\n     * Removes event handler for double click for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n\r\n            /*\\\r\n     * Element.mousedown\r\n     [ method ]\r\n     **\r\n     * Adds event handler for mousedown for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n            /*\\\r\n     * Element.unmousedown\r\n     [ method ]\r\n     **\r\n     * Removes event handler for mousedown for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n\r\n            /*\\\r\n     * Element.mousemove\r\n     [ method ]\r\n     **\r\n     * Adds event handler for mousemove for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n            /*\\\r\n     * Element.unmousemove\r\n     [ method ]\r\n     **\r\n     * Removes event handler for mousemove for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n\r\n            /*\\\r\n     * Element.mouseout\r\n     [ method ]\r\n     **\r\n     * Adds event handler for mouseout for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n            /*\\\r\n     * Element.unmouseout\r\n     [ method ]\r\n     **\r\n     * Removes event handler for mouseout for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n\r\n            /*\\\r\n     * Element.mouseover\r\n     [ method ]\r\n     **\r\n     * Adds event handler for mouseover for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n            /*\\\r\n     * Element.unmouseover\r\n     [ method ]\r\n     **\r\n     * Removes event handler for mouseover for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n\r\n            /*\\\r\n     * Element.mouseup\r\n     [ method ]\r\n     **\r\n     * Adds event handler for mouseup for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n            /*\\\r\n     * Element.unmouseup\r\n     [ method ]\r\n     **\r\n     * Removes event handler for mouseup for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n\r\n            /*\\\r\n     * Element.touchstart\r\n     [ method ]\r\n     **\r\n     * Adds event handler for touchstart for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n            /*\\\r\n     * Element.untouchstart\r\n     [ method ]\r\n     **\r\n     * Removes event handler for touchstart for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n\r\n            /*\\\r\n     * Element.touchmove\r\n     [ method ]\r\n     **\r\n     * Adds event handler for touchmove for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n            /*\\\r\n     * Element.untouchmove\r\n     [ method ]\r\n     **\r\n     * Removes event handler for touchmove for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n\r\n            /*\\\r\n     * Element.touchend\r\n     [ method ]\r\n     **\r\n     * Adds event handler for touchend for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n            /*\\\r\n     * Element.untouchend\r\n     [ method ]\r\n     **\r\n     * Removes event handler for touchend for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n\r\n            /*\\\r\n     * Element.touchcancel\r\n     [ method ]\r\n     **\r\n     * Adds event handler for touchcancel for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n            /*\\\r\n     * Element.untouchcancel\r\n     [ method ]\r\n     **\r\n     * Removes event handler for touchcancel for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n    \\*/\r\n            for (var i = events.length; i--; ) {\r\n              (function (eventName) {\r\n                R[eventName] = elproto[eventName] = function (fn, scope) {\r\n                  if (R.is(fn, 'function')) {\r\n                    this.events = this.events || [];\r\n                    this.events.push({\r\n                      name: eventName,\r\n                      f: fn,\r\n                      unbind: addEvent(\r\n                        this.shape || this.node || g.doc,\r\n                        eventName,\r\n                        fn,\r\n                        scope || this\r\n                      ),\r\n                    });\r\n                  }\r\n                  return this;\r\n                };\r\n                R['un' + eventName] = elproto['un' + eventName] = function (\r\n                  fn\r\n                ) {\r\n                  var events = this.events || [],\r\n                    l = events.length;\r\n                  while (l--) {\r\n                    if (\r\n                      events[l].name == eventName &&\r\n                      (R.is(fn, 'undefined') || events[l].f == fn)\r\n                    ) {\r\n                      events[l].unbind();\r\n                      events.splice(l, 1);\r\n                      !events.length && delete this.events;\r\n                    }\r\n                  }\r\n                  return this;\r\n                };\r\n              })(events[i]);\r\n            }\r\n\r\n            /*\\\r\n     * Element.data\r\n     [ method ]\r\n     **\r\n     * Adds or retrieves given value associated with given key.\r\n     **\r\n     * See also @Element.removeData\r\n     > Parameters\r\n     - key (string) key to store data\r\n     - value (any) #optional value to store\r\n     = (object) @Element\r\n     * or, if value is not specified:\r\n     = (any) value\r\n     * or, if key and value are not specified:\r\n     = (object) Key/value pairs for all the data associated with the element.\r\n     > Usage\r\n     | for (var i = 0, i < 5, i++) {\r\n     |     paper.circle(10 + 15 * i, 10, 10)\r\n     |          .attr({fill: \"#000\"})\r\n     |          .data(\"i\", i)\r\n     |          .click(function () {\r\n     |             alert(this.data(\"i\"));\r\n     |          });\r\n     | }\r\n    \\*/\r\n            elproto.data = function (key, value) {\r\n              var data = (eldata[this.id] = eldata[this.id] || {});\r\n              if (arguments.length == 0) {\r\n                return data;\r\n              }\r\n              if (arguments.length == 1) {\r\n                if (R.is(key, 'object')) {\r\n                  for (var i in key)\r\n                    if (key[has](i)) {\r\n                      this.data(i, key[i]);\r\n                    }\r\n                  return this;\r\n                }\r\n                eve('raphael.data.get.' + this.id, this, data[key], key);\r\n                return data[key];\r\n              }\r\n              data[key] = value;\r\n              eve('raphael.data.set.' + this.id, this, value, key);\r\n              return this;\r\n            };\r\n            /*\\\r\n     * Element.removeData\r\n     [ method ]\r\n     **\r\n     * Removes value associated with an element by given key.\r\n     * If key is not provided, removes all the data of the element.\r\n     > Parameters\r\n     - key (string) #optional key\r\n     = (object) @Element\r\n    \\*/\r\n            elproto.removeData = function (key) {\r\n              if (key == null) {\r\n                delete eldata[this.id];\r\n              } else {\r\n                eldata[this.id] && delete eldata[this.id][key];\r\n              }\r\n              return this;\r\n            };\r\n            /*\\\r\n     * Element.getData\r\n     [ method ]\r\n     **\r\n     * Retrieves the element data\r\n     = (object) data\r\n    \\*/\r\n            elproto.getData = function () {\r\n              return clone(eldata[this.id] || {});\r\n            };\r\n            /*\\\r\n     * Element.hover\r\n     [ method ]\r\n     **\r\n     * Adds event handlers for hover for the element.\r\n     > Parameters\r\n     - f_in (function) handler for hover in\r\n     - f_out (function) handler for hover out\r\n     - icontext (object) #optional context for hover in handler\r\n     - ocontext (object) #optional context for hover out handler\r\n     = (object) @Element\r\n    \\*/\r\n            elproto.hover = function (f_in, f_out, scope_in, scope_out) {\r\n              return this.mouseover(f_in, scope_in).mouseout(\r\n                f_out,\r\n                scope_out || scope_in\r\n              );\r\n            };\r\n            /*\\\r\n     * Element.unhover\r\n     [ method ]\r\n     **\r\n     * Removes event handlers for hover for the element.\r\n     > Parameters\r\n     - f_in (function) handler for hover in\r\n     - f_out (function) handler for hover out\r\n     = (object) @Element\r\n    \\*/\r\n            elproto.unhover = function (f_in, f_out) {\r\n              return this.unmouseover(f_in).unmouseout(f_out);\r\n            };\r\n            var draggable = [];\r\n            /*\\\r\n     * Element.drag\r\n     [ method ]\r\n     **\r\n     * Adds event handlers for drag of the element.\r\n     > Parameters\r\n     - onmove (function) handler for moving\r\n     - onstart (function) handler for drag start\r\n     - onend (function) handler for drag end\r\n     - mcontext (object) #optional context for moving handler\r\n     - scontext (object) #optional context for drag start handler\r\n     - econtext (object) #optional context for drag end handler\r\n     * Additionally following `drag` events will be triggered: `drag.start.<id>` on start,\r\n     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element\r\n     * `drag.over.<id>` will be fired as well.\r\n     *\r\n     * Start event and start handler will be called in specified context or in context of the element with following parameters:\r\n     o x (number) x position of the mouse\r\n     o y (number) y position of the mouse\r\n     o event (object) DOM event object\r\n     * Move event and move handler will be called in specified context or in context of the element with following parameters:\r\n     o dx (number) shift by x from the start point\r\n     o dy (number) shift by y from the start point\r\n     o x (number) x position of the mouse\r\n     o y (number) y position of the mouse\r\n     o event (object) DOM event object\r\n     * End event and end handler will be called in specified context or in context of the element with following parameters:\r\n     o event (object) DOM event object\r\n     = (object) @Element\r\n    \\*/\r\n            elproto.drag = function (\r\n              onmove,\r\n              onstart,\r\n              onend,\r\n              move_scope,\r\n              start_scope,\r\n              end_scope\r\n            ) {\r\n              function start(e) {\r\n                (e.originalEvent || e).preventDefault();\r\n                var x = e.clientX,\r\n                  y = e.clientY,\r\n                  scrollY =\r\n                    g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\r\n                  scrollX =\r\n                    g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;\r\n                this._drag.id = e.identifier;\r\n                if (supportsTouch && e.touches) {\r\n                  var i = e.touches.length,\r\n                    touch;\r\n                  while (i--) {\r\n                    touch = e.touches[i];\r\n                    this._drag.id = touch.identifier;\r\n                    if (touch.identifier == this._drag.id) {\r\n                      x = touch.clientX;\r\n                      y = touch.clientY;\r\n                      break;\r\n                    }\r\n                  }\r\n                }\r\n                this._drag.x = x + scrollX;\r\n                this._drag.y = y + scrollY;\r\n                !drag.length && R.mousemove(dragMove).mouseup(dragUp);\r\n                drag.push({\r\n                  el: this,\r\n                  move_scope: move_scope,\r\n                  start_scope: start_scope,\r\n                  end_scope: end_scope,\r\n                });\r\n                onstart && eve.on('raphael.drag.start.' + this.id, onstart);\r\n                onmove && eve.on('raphael.drag.move.' + this.id, onmove);\r\n                onend && eve.on('raphael.drag.end.' + this.id, onend);\r\n                eve(\r\n                  'raphael.drag.start.' + this.id,\r\n                  start_scope || move_scope || this,\r\n                  this._drag.x,\r\n                  this._drag.y,\r\n                  e\r\n                );\r\n              }\r\n              this._drag = {};\r\n              draggable.push({ el: this, start: start });\r\n              this.mousedown(start);\r\n              return this;\r\n            };\r\n            /*\\\r\n     * Element.onDragOver\r\n     [ method ]\r\n     **\r\n     * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).\r\n     > Parameters\r\n     - f (function) handler for event, first argument would be the element you are dragging over\r\n    \\*/\r\n            elproto.onDragOver = function (f) {\r\n              f\r\n                ? eve.on('raphael.drag.over.' + this.id, f)\r\n                : eve.unbind('raphael.drag.over.' + this.id);\r\n            };\r\n            /*\\\r\n     * Element.undrag\r\n     [ method ]\r\n     **\r\n     * Removes all drag event handlers from given element.\r\n    \\*/\r\n            elproto.undrag = function () {\r\n              var i = draggable.length;\r\n              while (i--)\r\n                if (draggable[i].el == this) {\r\n                  this.unmousedown(draggable[i].start);\r\n                  draggable.splice(i, 1);\r\n                  eve.unbind('raphael.drag.*.' + this.id);\r\n                }\r\n              !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);\r\n              drag = [];\r\n            };\r\n            /*\\\r\n     * Paper.circle\r\n     [ method ]\r\n     **\r\n     * Draws a circle.\r\n     **\r\n     > Parameters\r\n     **\r\n     - x (number) x coordinate of the centre\r\n     - y (number) y coordinate of the centre\r\n     - r (number) radius\r\n     = (object) Raphaël element object with type “circle”\r\n     **\r\n     > Usage\r\n     | var c = paper.circle(50, 50, 40);\r\n    \\*/\r\n            paperproto.circle = function (x, y, r) {\r\n              var out = R._engine.circle(this, x || 0, y || 0, r || 0);\r\n              this.__set__ && this.__set__.push(out);\r\n              return out;\r\n            };\r\n            /*\\\r\n     * Paper.rect\r\n     [ method ]\r\n     *\r\n     * Draws a rectangle.\r\n     **\r\n     > Parameters\r\n     **\r\n     - x (number) x coordinate of the top left corner\r\n     - y (number) y coordinate of the top left corner\r\n     - width (number) width\r\n     - height (number) height\r\n     - r (number) #optional radius for rounded corners, default is 0\r\n     = (object) Raphaël element object with type “rect”\r\n     **\r\n     > Usage\r\n     | // regular rectangle\r\n     | var c = paper.rect(10, 10, 50, 50);\r\n     | // rectangle with rounded corners\r\n     | var c = paper.rect(40, 40, 50, 50, 10);\r\n    \\*/\r\n            paperproto.rect = function (x, y, w, h, r) {\r\n              var out = R._engine.rect(\r\n                this,\r\n                x || 0,\r\n                y || 0,\r\n                w || 0,\r\n                h || 0,\r\n                r || 0\r\n              );\r\n              this.__set__ && this.__set__.push(out);\r\n              return out;\r\n            };\r\n            /*\\\r\n     * Paper.ellipse\r\n     [ method ]\r\n     **\r\n     * Draws an ellipse.\r\n     **\r\n     > Parameters\r\n     **\r\n     - x (number) x coordinate of the centre\r\n     - y (number) y coordinate of the centre\r\n     - rx (number) horizontal radius\r\n     - ry (number) vertical radius\r\n     = (object) Raphaël element object with type “ellipse”\r\n     **\r\n     > Usage\r\n     | var c = paper.ellipse(50, 50, 40, 20);\r\n    \\*/\r\n            paperproto.ellipse = function (x, y, rx, ry) {\r\n              var out = R._engine.ellipse(\r\n                this,\r\n                x || 0,\r\n                y || 0,\r\n                rx || 0,\r\n                ry || 0\r\n              );\r\n              this.__set__ && this.__set__.push(out);\r\n              return out;\r\n            };\r\n            /*\\\r\n     * Paper.path\r\n     [ method ]\r\n     **\r\n     * Creates a path element by given path data string.\r\n     > Parameters\r\n     - pathString (string) #optional path string in SVG format.\r\n     * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:\r\n     | \"M10,20L30,40\"\r\n     * Here we can see two commands: “M”, with arguments `(10, 20)` and “L” with arguments `(30, 40)`. Upper case letter mean command is absolute, lower case—relative.\r\n     *\r\n     # <p>Here is short list of commands available, for more details see <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a path's data attribute's format are described in the SVG specification.\">SVG path string format</a>.</p>\r\n     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>\r\n     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>\r\n     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>\r\n     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>\r\n     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>\r\n     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>\r\n     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>\r\n     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>\r\n     # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>\r\n     # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>\r\n     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>\r\n     # <tr><td>R</td><td><a href=\"http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline\">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>\r\n     * * “Catmull-Rom curveto” is a not standard SVG command and added in 2.0 to make life easier.\r\n     * Note: there is a special case when path consist of just three commands: “M10,10R…z”. In this case path will smoothly connects to its beginning.\r\n     > Usage\r\n     | var c = paper.path(\"M10 10L90 90\");\r\n     | // draw a diagonal line:\r\n     | // move to 10,10, line to 90,90\r\n     * For example of path strings, check out these icons: http://raphaeljs.com/icons/\r\n    \\*/\r\n            paperproto.path = function (pathString) {\r\n              pathString &&\r\n                !R.is(pathString, string) &&\r\n                !R.is(pathString[0], array) &&\r\n                (pathString += E);\r\n              var out = R._engine.path(R.format[apply](R, arguments), this);\r\n              this.__set__ && this.__set__.push(out);\r\n              return out;\r\n            };\r\n            /*\\\r\n     * Paper.image\r\n     [ method ]\r\n     **\r\n     * Embeds an image into the surface.\r\n     **\r\n     > Parameters\r\n     **\r\n     - src (string) URI of the source image\r\n     - x (number) x coordinate position\r\n     - y (number) y coordinate position\r\n     - width (number) width of the image\r\n     - height (number) height of the image\r\n     = (object) Raphaël element object with type “image”\r\n     **\r\n     > Usage\r\n     | var c = paper.image(\"apple.png\", 10, 10, 80, 80);\r\n    \\*/\r\n            paperproto.image = function (src, x, y, w, h) {\r\n              var out = R._engine.image(\r\n                this,\r\n                src || 'about:blank',\r\n                x || 0,\r\n                y || 0,\r\n                w || 0,\r\n                h || 0\r\n              );\r\n              this.__set__ && this.__set__.push(out);\r\n              return out;\r\n            };\r\n            /*\\\r\n     * Paper.text\r\n     [ method ]\r\n     **\r\n     * Draws a text string. If you need line breaks, put “\\n” in the string.\r\n     **\r\n     > Parameters\r\n     **\r\n     - x (number) x coordinate position\r\n     - y (number) y coordinate position\r\n     - text (string) The text string to draw\r\n     = (object) Raphaël element object with type “text”\r\n     **\r\n     > Usage\r\n     | var t = paper.text(50, 50, \"Raphaël\\nkicks\\nbutt!\");\r\n    \\*/\r\n            paperproto.text = function (x, y, text) {\r\n              var out = R._engine.text(this, x || 0, y || 0, Str(text));\r\n              this.__set__ && this.__set__.push(out);\r\n              return out;\r\n            };\r\n            /*\\\r\n     * Paper.set\r\n     [ method ]\r\n     **\r\n     * Creates array-like object to keep and operate several elements at once.\r\n     * Warning: it doesn’t create any elements for itself in the page, it just groups existing elements.\r\n     * Sets act as pseudo elements — all methods available to an element can be used on a set.\r\n     = (object) array-like object that represents set of elements\r\n     **\r\n     > Usage\r\n     | var st = paper.set();\r\n     | st.push(\r\n     |     paper.circle(10, 10, 5),\r\n     |     paper.circle(30, 10, 5)\r\n     | );\r\n     | st.attr({fill: \"red\"}); // changes the fill of both circles\r\n    \\*/\r\n            paperproto.set = function (itemsArray) {\r\n              !R.is(itemsArray, 'array') &&\r\n                (itemsArray = Array.prototype.splice.call(\r\n                  arguments,\r\n                  0,\r\n                  arguments.length\r\n                ));\r\n              var out = new Set(itemsArray);\r\n              this.__set__ && this.__set__.push(out);\r\n              out['paper'] = this;\r\n              out['type'] = 'set';\r\n              return out;\r\n            };\r\n            /*\\\r\n     * Paper.setStart\r\n     [ method ]\r\n     **\r\n     * Creates @Paper.set. All elements that will be created after calling this method and before calling\r\n     * @Paper.setFinish will be added to the set.\r\n     **\r\n     > Usage\r\n     | paper.setStart();\r\n     | paper.circle(10, 10, 5),\r\n     | paper.circle(30, 10, 5)\r\n     | var st = paper.setFinish();\r\n     | st.attr({fill: \"red\"}); // changes the fill of both circles\r\n    \\*/\r\n            paperproto.setStart = function (set) {\r\n              this.__set__ = set || this.set();\r\n            };\r\n            /*\\\r\n     * Paper.setFinish\r\n     [ method ]\r\n     **\r\n     * See @Paper.setStart. This method finishes catching and returns resulting set.\r\n     **\r\n     = (object) set\r\n    \\*/\r\n            paperproto.setFinish = function (set) {\r\n              var out = this.__set__;\r\n              delete this.__set__;\r\n              return out;\r\n            };\r\n            /*\\\r\n     * Paper.getSize\r\n     [ method ]\r\n     **\r\n     * Obtains current paper actual size.\r\n     **\r\n     = (object)\r\n     \\*/\r\n            paperproto.getSize = function () {\r\n              var container = this.canvas.parentNode;\r\n              return {\r\n                width: container.offsetWidth,\r\n                height: container.offsetHeight,\r\n              };\r\n            };\r\n            /*\\\r\n     * Paper.setSize\r\n     [ method ]\r\n     **\r\n     * If you need to change dimensions of the canvas call this method\r\n     **\r\n     > Parameters\r\n     **\r\n     - width (number) new width of the canvas\r\n     - height (number) new height of the canvas\r\n    \\*/\r\n            paperproto.setSize = function (width, height) {\r\n              return R._engine.setSize.call(this, width, height);\r\n            };\r\n            /*\\\r\n     * Paper.setViewBox\r\n     [ method ]\r\n     **\r\n     * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by\r\n     * specifying new boundaries.\r\n     **\r\n     > Parameters\r\n     **\r\n     - x (number) new x position, default is `0`\r\n     - y (number) new y position, default is `0`\r\n     - w (number) new width of the canvas\r\n     - h (number) new height of the canvas\r\n     - fit (boolean) `true` if you want graphics to fit into new boundary box\r\n    \\*/\r\n            paperproto.setViewBox = function (x, y, w, h, fit) {\r\n              return R._engine.setViewBox.call(this, x, y, w, h, fit);\r\n            };\r\n            /*\\\r\n     * Paper.top\r\n     [ property ]\r\n     **\r\n     * Points to the topmost element on the paper\r\n    \\*/\r\n            /*\\\r\n     * Paper.bottom\r\n     [ property ]\r\n     **\r\n     * Points to the bottom element on the paper\r\n    \\*/\r\n            paperproto.top = paperproto.bottom = null;\r\n            /*\\\r\n     * Paper.raphael\r\n     [ property ]\r\n     **\r\n     * Points to the @Raphael object/function\r\n    \\*/\r\n            paperproto.raphael = R;\r\n            var getOffset = function (elem) {\r\n              var box = elem.getBoundingClientRect(),\r\n                doc = elem.ownerDocument,\r\n                body = doc.body,\r\n                docElem = doc.documentElement,\r\n                clientTop = docElem.clientTop || body.clientTop || 0,\r\n                clientLeft = docElem.clientLeft || body.clientLeft || 0,\r\n                top =\r\n                  box.top +\r\n                  (g.win.pageYOffset || docElem.scrollTop || body.scrollTop) -\r\n                  clientTop,\r\n                left =\r\n                  box.left +\r\n                  (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) -\r\n                  clientLeft;\r\n              return {\r\n                y: top,\r\n                x: left,\r\n              };\r\n            };\r\n            /*\\\r\n     * Paper.getElementByPoint\r\n     [ method ]\r\n     **\r\n     * Returns you topmost element under given point.\r\n     **\r\n     = (object) Raphaël element object\r\n     > Parameters\r\n     **\r\n     - x (number) x coordinate from the top left corner of the window\r\n     - y (number) y coordinate from the top left corner of the window\r\n     > Usage\r\n     | paper.getElementByPoint(mouseX, mouseY).attr({stroke: \"#f00\"});\r\n    \\*/\r\n            paperproto.getElementByPoint = function (x, y) {\r\n              var paper = this,\r\n                svg = paper.canvas,\r\n                target = g.doc.elementFromPoint(x, y);\r\n              if (g.win.opera && target.tagName == 'svg') {\r\n                var so = getOffset(svg),\r\n                  sr = svg.createSVGRect();\r\n                sr.x = x - so.x;\r\n                sr.y = y - so.y;\r\n                sr.width = sr.height = 1;\r\n                var hits = svg.getIntersectionList(sr, null);\r\n                if (hits.length) {\r\n                  target = hits[hits.length - 1];\r\n                }\r\n              }\r\n              if (!target) {\r\n                return null;\r\n              }\r\n              while (\r\n                target.parentNode &&\r\n                target != svg.parentNode &&\r\n                !target.raphael\r\n              ) {\r\n                target = target.parentNode;\r\n              }\r\n              target == paper.canvas.parentNode && (target = svg);\r\n              target =\r\n                target && target.raphael\r\n                  ? paper.getById(target.raphaelid)\r\n                  : null;\r\n              return target;\r\n            };\r\n\r\n            /*\\\r\n     * Paper.getElementsByBBox\r\n     [ method ]\r\n     **\r\n     * Returns set of elements that have an intersecting bounding box\r\n     **\r\n     > Parameters\r\n     **\r\n     - bbox (object) bbox to check with\r\n     = (object) @Set\r\n     \\*/\r\n            paperproto.getElementsByBBox = function (bbox) {\r\n              var set = this.set();\r\n              this.forEach(function (el) {\r\n                if (R.isBBoxIntersect(el.getBBox(), bbox)) {\r\n                  set.push(el);\r\n                }\r\n              });\r\n              return set;\r\n            };\r\n\r\n            /*\\\r\n     * Paper.getById\r\n     [ method ]\r\n     **\r\n     * Returns you element by its internal ID.\r\n     **\r\n     > Parameters\r\n     **\r\n     - id (number) id\r\n     = (object) Raphaël element object\r\n    \\*/\r\n            paperproto.getById = function (id) {\r\n              var bot = this.bottom;\r\n              while (bot) {\r\n                if (bot.id == id) {\r\n                  return bot;\r\n                }\r\n                bot = bot.next;\r\n              }\r\n              return null;\r\n            };\r\n            /*\\\r\n     * Paper.forEach\r\n     [ method ]\r\n     **\r\n     * Executes given function for each element on the paper\r\n     *\r\n     * If callback function returns `false` it will stop loop running.\r\n     **\r\n     > Parameters\r\n     **\r\n     - callback (function) function to run\r\n     - thisArg (object) context object for the callback\r\n     = (object) Paper object\r\n     > Usage\r\n     | paper.forEach(function (el) {\r\n     |     el.attr({ stroke: \"blue\" });\r\n     | });\r\n    \\*/\r\n            paperproto.forEach = function (callback, thisArg) {\r\n              var bot = this.bottom;\r\n              while (bot) {\r\n                if (callback.call(thisArg, bot) === false) {\r\n                  return this;\r\n                }\r\n                bot = bot.next;\r\n              }\r\n              return this;\r\n            };\r\n            /*\\\r\n     * Paper.getElementsByPoint\r\n     [ method ]\r\n     **\r\n     * Returns set of elements that have common point inside\r\n     **\r\n     > Parameters\r\n     **\r\n     - x (number) x coordinate of the point\r\n     - y (number) y coordinate of the point\r\n     = (object) @Set\r\n    \\*/\r\n            paperproto.getElementsByPoint = function (x, y) {\r\n              var set = this.set();\r\n              this.forEach(function (el) {\r\n                if (el.isPointInside(x, y)) {\r\n                  set.push(el);\r\n                }\r\n              });\r\n              return set;\r\n            };\r\n            function x_y() {\r\n              return this.x + S + this.y;\r\n            }\r\n            function x_y_w_h() {\r\n              return (\r\n                this.x + S + this.y + S + this.width + ' \\xd7 ' + this.height\r\n              );\r\n            }\r\n            /*\\\r\n     * Element.isPointInside\r\n     [ method ]\r\n     **\r\n     * Determine if given point is inside this element’s shape\r\n     **\r\n     > Parameters\r\n     **\r\n     - x (number) x coordinate of the point\r\n     - y (number) y coordinate of the point\r\n     = (boolean) `true` if point inside the shape\r\n    \\*/\r\n            elproto.isPointInside = function (x, y) {\r\n              var rp = (this.realPath = getPath[this.type](this));\r\n              if (this.attr('transform') && this.attr('transform').length) {\r\n                rp = R.transformPath(rp, this.attr('transform'));\r\n              }\r\n              return R.isPointInsidePath(rp, x, y);\r\n            };\r\n            /*\\\r\n     * Element.getBBox\r\n     [ method ]\r\n     **\r\n     * Return bounding box for a given element\r\n     **\r\n     > Parameters\r\n     **\r\n     - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.\r\n     = (object) Bounding box object:\r\n     o {\r\n     o     x: (number) top left corner x\r\n     o     y: (number) top left corner y\r\n     o     x2: (number) bottom right corner x\r\n     o     y2: (number) bottom right corner y\r\n     o     width: (number) width\r\n     o     height: (number) height\r\n     o }\r\n    \\*/\r\n            elproto.getBBox = function (isWithoutTransform) {\r\n              if (this.removed) {\r\n                return {};\r\n              }\r\n              var _ = this._;\r\n              if (isWithoutTransform) {\r\n                if (_.dirty || !_.bboxwt) {\r\n                  this.realPath = getPath[this.type](this);\r\n                  _.bboxwt = pathDimensions(this.realPath);\r\n                  _.bboxwt.toString = x_y_w_h;\r\n                  _.dirty = 0;\r\n                }\r\n                return _.bboxwt;\r\n              }\r\n              if (_.dirty || _.dirtyT || !_.bbox) {\r\n                if (_.dirty || !this.realPath) {\r\n                  _.bboxwt = 0;\r\n                  this.realPath = getPath[this.type](this);\r\n                }\r\n                _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));\r\n                _.bbox.toString = x_y_w_h;\r\n                _.dirty = _.dirtyT = 0;\r\n              }\r\n              return _.bbox;\r\n            };\r\n            /*\\\r\n     * Element.clone\r\n     [ method ]\r\n     **\r\n     = (object) clone of a given element\r\n     **\r\n    \\*/\r\n            elproto.clone = function () {\r\n              if (this.removed) {\r\n                return null;\r\n              }\r\n              var out = this.paper[this.type]().attr(this.attr());\r\n              this.__set__ && this.__set__.push(out);\r\n              return out;\r\n            };\r\n            /*\\\r\n     * Element.glow\r\n     [ method ]\r\n     **\r\n     * Return set of elements that create glow-like effect around given element. See @Paper.set.\r\n     *\r\n     * Note: Glow is not connected to the element. If you change element attributes it won’t adjust itself.\r\n     **\r\n     > Parameters\r\n     **\r\n     - glow (object) #optional parameters object with all properties optional:\r\n     o {\r\n     o     width (number) size of the glow, default is `10`\r\n     o     fill (boolean) will it be filled, default is `false`\r\n     o     opacity (number) opacity, default is `0.5`\r\n     o     offsetx (number) horizontal offset, default is `0`\r\n     o     offsety (number) vertical offset, default is `0`\r\n     o     color (string) glow colour, default is `black`\r\n     o }\r\n     = (object) @Paper.set of elements that represents glow\r\n    \\*/\r\n            elproto.glow = function (glow) {\r\n              if (this.type == 'text') {\r\n                return null;\r\n              }\r\n              glow = glow || {};\r\n              var s = {\r\n                  width: (glow.width || 10) + (+this.attr('stroke-width') || 1),\r\n                  fill: glow.fill || false,\r\n                  opacity: glow.opacity == null ? 0.5 : glow.opacity,\r\n                  offsetx: glow.offsetx || 0,\r\n                  offsety: glow.offsety || 0,\r\n                  color: glow.color || '#000',\r\n                },\r\n                c = s.width / 2,\r\n                r = this.paper,\r\n                out = r.set(),\r\n                path = this.realPath || getPath[this.type](this);\r\n              path = this.matrix ? mapPath(path, this.matrix) : path;\r\n              for (var i = 1; i < c + 1; i++) {\r\n                out.push(\r\n                  r.path(path).attr({\r\n                    stroke: s.color,\r\n                    fill: s.fill ? s.color : 'none',\r\n                    'stroke-linejoin': 'round',\r\n                    'stroke-linecap': 'round',\r\n                    'stroke-width': +((s.width / c) * i).toFixed(3),\r\n                    opacity: +(s.opacity / c).toFixed(3),\r\n                  })\r\n                );\r\n              }\r\n              return out.insertBefore(this).translate(s.offsetx, s.offsety);\r\n            };\r\n            var curveslengths = {},\r\n              getPointAtSegmentLength = function (\r\n                p1x,\r\n                p1y,\r\n                c1x,\r\n                c1y,\r\n                c2x,\r\n                c2y,\r\n                p2x,\r\n                p2y,\r\n                length\r\n              ) {\r\n                if (length == null) {\r\n                  return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);\r\n                } else {\r\n                  return R.findDotsAtSegment(\r\n                    p1x,\r\n                    p1y,\r\n                    c1x,\r\n                    c1y,\r\n                    c2x,\r\n                    c2y,\r\n                    p2x,\r\n                    p2y,\r\n                    getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length)\r\n                  );\r\n                }\r\n              },\r\n              getLengthFactory = function (istotal, subpath) {\r\n                return function (path, length, onlystart) {\r\n                  path = path2curve(path);\r\n                  var x,\r\n                    y,\r\n                    p,\r\n                    l,\r\n                    sp = '',\r\n                    subpaths = {},\r\n                    point,\r\n                    len = 0;\r\n                  for (var i = 0, ii = path.length; i < ii; i++) {\r\n                    p = path[i];\r\n                    if (p[0] == 'M') {\r\n                      x = +p[1];\r\n                      y = +p[2];\r\n                    } else {\r\n                      l = getPointAtSegmentLength(\r\n                        x,\r\n                        y,\r\n                        p[1],\r\n                        p[2],\r\n                        p[3],\r\n                        p[4],\r\n                        p[5],\r\n                        p[6]\r\n                      );\r\n                      if (len + l > length) {\r\n                        if (subpath && !subpaths.start) {\r\n                          point = getPointAtSegmentLength(\r\n                            x,\r\n                            y,\r\n                            p[1],\r\n                            p[2],\r\n                            p[3],\r\n                            p[4],\r\n                            p[5],\r\n                            p[6],\r\n                            length - len\r\n                          );\r\n                          sp += [\r\n                            'C' + point.start.x,\r\n                            point.start.y,\r\n                            point.m.x,\r\n                            point.m.y,\r\n                            point.x,\r\n                            point.y,\r\n                          ];\r\n                          if (onlystart) {\r\n                            return sp;\r\n                          }\r\n                          subpaths.start = sp;\r\n                          sp = [\r\n                            'M' + point.x,\r\n                            point.y + 'C' + point.n.x,\r\n                            point.n.y,\r\n                            point.end.x,\r\n                            point.end.y,\r\n                            p[5],\r\n                            p[6],\r\n                          ].join();\r\n                          len += l;\r\n                          x = +p[5];\r\n                          y = +p[6];\r\n                          continue;\r\n                        }\r\n                        if (!istotal && !subpath) {\r\n                          point = getPointAtSegmentLength(\r\n                            x,\r\n                            y,\r\n                            p[1],\r\n                            p[2],\r\n                            p[3],\r\n                            p[4],\r\n                            p[5],\r\n                            p[6],\r\n                            length - len\r\n                          );\r\n                          return { x: point.x, y: point.y, alpha: point.alpha };\r\n                        }\r\n                      }\r\n                      len += l;\r\n                      x = +p[5];\r\n                      y = +p[6];\r\n                    }\r\n                    sp += p.shift() + p;\r\n                  }\r\n                  subpaths.end = sp;\r\n                  point = istotal\r\n                    ? len\r\n                    : subpath\r\n                    ? subpaths\r\n                    : R.findDotsAtSegment(\r\n                        x,\r\n                        y,\r\n                        p[0],\r\n                        p[1],\r\n                        p[2],\r\n                        p[3],\r\n                        p[4],\r\n                        p[5],\r\n                        1\r\n                      );\r\n                  point.alpha &&\r\n                    (point = { x: point.x, y: point.y, alpha: point.alpha });\r\n                  return point;\r\n                };\r\n              };\r\n            var getTotalLength = getLengthFactory(1),\r\n              getPointAtLength = getLengthFactory(),\r\n              getSubpathsAtLength = getLengthFactory(0, 1);\r\n            /*\\\r\n     * Raphael.getTotalLength\r\n     [ method ]\r\n     **\r\n     * Returns length of the given path in pixels.\r\n     **\r\n     > Parameters\r\n     **\r\n     - path (string) SVG path string.\r\n     **\r\n     = (number) length.\r\n    \\*/\r\n            R.getTotalLength = getTotalLength;\r\n            /*\\\r\n     * Raphael.getPointAtLength\r\n     [ method ]\r\n     **\r\n     * Return coordinates of the point located at the given length on the given path.\r\n     **\r\n     > Parameters\r\n     **\r\n     - path (string) SVG path string\r\n     - length (number)\r\n     **\r\n     = (object) representation of the point:\r\n     o {\r\n     o     x: (number) x coordinate\r\n     o     y: (number) y coordinate\r\n     o     alpha: (number) angle of derivative\r\n     o }\r\n    \\*/\r\n            R.getPointAtLength = getPointAtLength;\r\n            /*\\\r\n     * Raphael.getSubpath\r\n     [ method ]\r\n     **\r\n     * Return subpath of a given path from given length to given length.\r\n     **\r\n     > Parameters\r\n     **\r\n     - path (string) SVG path string\r\n     - from (number) position of the start of the segment\r\n     - to (number) position of the end of the segment\r\n     **\r\n     = (string) pathstring for the segment\r\n    \\*/\r\n            R.getSubpath = function (path, from, to) {\r\n              if (this.getTotalLength(path) - to < 1e-6) {\r\n                return getSubpathsAtLength(path, from).end;\r\n              }\r\n              var a = getSubpathsAtLength(path, to, 1);\r\n              return from ? getSubpathsAtLength(a, from).end : a;\r\n            };\r\n            /*\\\r\n     * Element.getTotalLength\r\n     [ method ]\r\n     **\r\n     * Returns length of the path in pixels. Only works for element of “path” type.\r\n     = (number) length.\r\n    \\*/\r\n            elproto.getTotalLength = function () {\r\n              var path = this.getPath();\r\n              if (!path) {\r\n                return;\r\n              }\r\n\r\n              if (this.node.getTotalLength) {\r\n                return this.node.getTotalLength();\r\n              }\r\n\r\n              return getTotalLength(path);\r\n            };\r\n            /*\\\r\n     * Element.getPointAtLength\r\n     [ method ]\r\n     **\r\n     * Return coordinates of the point located at the given length on the given path. Only works for element of “path” type.\r\n     **\r\n     > Parameters\r\n     **\r\n     - length (number)\r\n     **\r\n     = (object) representation of the point:\r\n     o {\r\n     o     x: (number) x coordinate\r\n     o     y: (number) y coordinate\r\n     o     alpha: (number) angle of derivative\r\n     o }\r\n    \\*/\r\n            elproto.getPointAtLength = function (length) {\r\n              var path = this.getPath();\r\n              if (!path) {\r\n                return;\r\n              }\r\n\r\n              return getPointAtLength(path, length);\r\n            };\r\n            /*\\\r\n     * Element.getPath\r\n     [ method ]\r\n     **\r\n     * Returns path of the element. Only works for elements of “path” type and simple elements like circle.\r\n     = (object) path\r\n     **\r\n    \\*/\r\n            elproto.getPath = function () {\r\n              var path,\r\n                getPath = R._getPath[this.type];\r\n\r\n              if (this.type == 'text' || this.type == 'set') {\r\n                return;\r\n              }\r\n\r\n              if (getPath) {\r\n                path = getPath(this);\r\n              }\r\n\r\n              return path;\r\n            };\r\n            /*\\\r\n     * Element.getSubpath\r\n     [ method ]\r\n     **\r\n     * Return subpath of a given element from given length to given length. Only works for element of “path” type.\r\n     **\r\n     > Parameters\r\n     **\r\n     - from (number) position of the start of the segment\r\n     - to (number) position of the end of the segment\r\n     **\r\n     = (string) pathstring for the segment\r\n    \\*/\r\n            elproto.getSubpath = function (from, to) {\r\n              var path = this.getPath();\r\n              if (!path) {\r\n                return;\r\n              }\r\n\r\n              return R.getSubpath(path, from, to);\r\n            };\r\n            /*\\\r\n     * Raphael.easing_formulas\r\n     [ property ]\r\n     **\r\n     * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:\r\n     # <ul>\r\n     #     <li>“linear”</li>\r\n     #     <li>“&lt;” or “easeIn” or “ease-in”</li>\r\n     #     <li>“>” or “easeOut” or “ease-out”</li>\r\n     #     <li>“&lt;>” or “easeInOut” or “ease-in-out”</li>\r\n     #     <li>“backIn” or “back-in”</li>\r\n     #     <li>“backOut” or “back-out”</li>\r\n     #     <li>“elastic”</li>\r\n     #     <li>“bounce”</li>\r\n     # </ul>\r\n     # <p>See also <a href=\"http://raphaeljs.com/easing.html\">Easing demo</a>.</p>\r\n    \\*/\r\n            var ef = (R.easing_formulas = {\r\n              linear: function (n) {\r\n                return n;\r\n              },\r\n              '<': function (n) {\r\n                return pow(n, 1.7);\r\n              },\r\n              '>': function (n) {\r\n                return pow(n, 0.48);\r\n              },\r\n              '<>': function (n) {\r\n                var q = 0.48 - n / 1.04,\r\n                  Q = math.sqrt(0.1734 + q * q),\r\n                  x = Q - q,\r\n                  X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),\r\n                  y = -Q - q,\r\n                  Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),\r\n                  t = X + Y + 0.5;\r\n                return (1 - t) * 3 * t * t + t * t * t;\r\n              },\r\n              backIn: function (n) {\r\n                var s = 1.70158;\r\n                return n * n * ((s + 1) * n - s);\r\n              },\r\n              backOut: function (n) {\r\n                n = n - 1;\r\n                var s = 1.70158;\r\n                return n * n * ((s + 1) * n + s) + 1;\r\n              },\r\n              elastic: function (n) {\r\n                if (n == !!n) {\r\n                  return n;\r\n                }\r\n                return (\r\n                  pow(2, -10 * n) * math.sin(((n - 0.075) * (2 * PI)) / 0.3) + 1\r\n                );\r\n              },\r\n              bounce: function (n) {\r\n                var s = 7.5625,\r\n                  p = 2.75,\r\n                  l;\r\n                if (n < 1 / p) {\r\n                  l = s * n * n;\r\n                } else {\r\n                  if (n < 2 / p) {\r\n                    n -= 1.5 / p;\r\n                    l = s * n * n + 0.75;\r\n                  } else {\r\n                    if (n < 2.5 / p) {\r\n                      n -= 2.25 / p;\r\n                      l = s * n * n + 0.9375;\r\n                    } else {\r\n                      n -= 2.625 / p;\r\n                      l = s * n * n + 0.984375;\r\n                    }\r\n                  }\r\n                }\r\n                return l;\r\n              },\r\n            });\r\n            ef.easeIn = ef['ease-in'] = ef['<'];\r\n            ef.easeOut = ef['ease-out'] = ef['>'];\r\n            ef.easeInOut = ef['ease-in-out'] = ef['<>'];\r\n            ef['back-in'] = ef.backIn;\r\n            ef['back-out'] = ef.backOut;\r\n\r\n            var animationElements = [],\r\n              requestAnimFrame =\r\n                window.requestAnimationFrame ||\r\n                window.webkitRequestAnimationFrame ||\r\n                window.mozRequestAnimationFrame ||\r\n                window.oRequestAnimationFrame ||\r\n                window.msRequestAnimationFrame ||\r\n                function (callback) {\r\n                  setTimeout(callback, 16);\r\n                },\r\n              animation = function () {\r\n                var Now = +new Date(),\r\n                  l = 0;\r\n                for (; l < animationElements.length; l++) {\r\n                  var e = animationElements[l];\r\n                  if (e.el.removed || e.paused) {\r\n                    continue;\r\n                  }\r\n                  var time = Now - e.start,\r\n                    ms = e.ms,\r\n                    easing = e.easing,\r\n                    from = e.from,\r\n                    diff = e.diff,\r\n                    to = e.to,\r\n                    t = e.t,\r\n                    that = e.el,\r\n                    set = {},\r\n                    now,\r\n                    init = {},\r\n                    key;\r\n                  if (e.initstatus) {\r\n                    time =\r\n                      ((e.initstatus * e.anim.top - e.prev) /\r\n                        (e.percent - e.prev)) *\r\n                      ms;\r\n                    e.status = e.initstatus;\r\n                    delete e.initstatus;\r\n                    e.stop && animationElements.splice(l--, 1);\r\n                  } else {\r\n                    e.status =\r\n                      (e.prev + (e.percent - e.prev) * (time / ms)) /\r\n                      e.anim.top;\r\n                  }\r\n                  if (time < 0) {\r\n                    continue;\r\n                  }\r\n                  if (time < ms) {\r\n                    var pos = easing(time / ms);\r\n                    for (var attr in from)\r\n                      if (from[has](attr)) {\r\n                        switch (availableAnimAttrs[attr]) {\r\n                          case nu:\r\n                            now = +from[attr] + pos * ms * diff[attr];\r\n                            break;\r\n                          case 'colour':\r\n                            now =\r\n                              'rgb(' +\r\n                              [\r\n                                upto255(\r\n                                  round(from[attr].r + pos * ms * diff[attr].r)\r\n                                ),\r\n                                upto255(\r\n                                  round(from[attr].g + pos * ms * diff[attr].g)\r\n                                ),\r\n                                upto255(\r\n                                  round(from[attr].b + pos * ms * diff[attr].b)\r\n                                ),\r\n                              ].join(',') +\r\n                              ')';\r\n                            break;\r\n                          case 'path':\r\n                            now = [];\r\n                            for (\r\n                              var i = 0, ii = from[attr].length;\r\n                              i < ii;\r\n                              i++\r\n                            ) {\r\n                              now[i] = [from[attr][i][0]];\r\n                              for (\r\n                                var j = 1, jj = from[attr][i].length;\r\n                                j < jj;\r\n                                j++\r\n                              ) {\r\n                                now[i][j] =\r\n                                  +from[attr][i][j] +\r\n                                  pos * ms * diff[attr][i][j];\r\n                              }\r\n                              now[i] = now[i].join(S);\r\n                            }\r\n                            now = now.join(S);\r\n                            break;\r\n                          case 'transform':\r\n                            if (diff[attr].real) {\r\n                              now = [];\r\n                              for (i = 0, ii = from[attr].length; i < ii; i++) {\r\n                                now[i] = [from[attr][i][0]];\r\n                                for (\r\n                                  j = 1, jj = from[attr][i].length;\r\n                                  j < jj;\r\n                                  j++\r\n                                ) {\r\n                                  now[i][j] =\r\n                                    from[attr][i][j] +\r\n                                    pos * ms * diff[attr][i][j];\r\n                                }\r\n                              }\r\n                            } else {\r\n                              var get = function (i) {\r\n                                return (\r\n                                  +from[attr][i] + pos * ms * diff[attr][i]\r\n                                );\r\n                              };\r\n                              // now = [[\"r\", get(2), 0, 0], [\"t\", get(3), get(4)], [\"s\", get(0), get(1), 0, 0]];\r\n                              now = [\r\n                                [\r\n                                  'm',\r\n                                  get(0),\r\n                                  get(1),\r\n                                  get(2),\r\n                                  get(3),\r\n                                  get(4),\r\n                                  get(5),\r\n                                ],\r\n                              ];\r\n                            }\r\n                            break;\r\n                          case 'csv':\r\n                            if (attr == 'clip-rect') {\r\n                              now = [];\r\n                              i = 4;\r\n                              while (i--) {\r\n                                now[i] =\r\n                                  +from[attr][i] + pos * ms * diff[attr][i];\r\n                              }\r\n                            }\r\n                            break;\r\n                          default:\r\n                            var from2 = [][concat](from[attr]);\r\n                            now = [];\r\n                            i = that.paper.customAttributes[attr].length;\r\n                            while (i--) {\r\n                              now[i] = +from2[i] + pos * ms * diff[attr][i];\r\n                            }\r\n                            break;\r\n                        }\r\n                        set[attr] = now;\r\n                      }\r\n                    that.attr(set);\r\n                    (function (id, that, anim) {\r\n                      setTimeout(function () {\r\n                        eve('raphael.anim.frame.' + id, that, anim);\r\n                      });\r\n                    })(that.id, that, e.anim);\r\n                  } else {\r\n                    (function (f, el, a) {\r\n                      setTimeout(function () {\r\n                        eve('raphael.anim.frame.' + el.id, el, a);\r\n                        eve('raphael.anim.finish.' + el.id, el, a);\r\n                        R.is(f, 'function') && f.call(el);\r\n                      });\r\n                    })(e.callback, that, e.anim);\r\n                    that.attr(to);\r\n                    animationElements.splice(l--, 1);\r\n                    if (e.repeat > 1 && !e.next) {\r\n                      for (key in to)\r\n                        if (to[has](key)) {\r\n                          init[key] = e.totalOrigin[key];\r\n                        }\r\n                      e.el.attr(init);\r\n                      runAnimation(\r\n                        e.anim,\r\n                        e.el,\r\n                        e.anim.percents[0],\r\n                        null,\r\n                        e.totalOrigin,\r\n                        e.repeat - 1\r\n                      );\r\n                    }\r\n                    if (e.next && !e.stop) {\r\n                      runAnimation(\r\n                        e.anim,\r\n                        e.el,\r\n                        e.next,\r\n                        null,\r\n                        e.totalOrigin,\r\n                        e.repeat\r\n                      );\r\n                    }\r\n                  }\r\n                }\r\n                animationElements.length && requestAnimFrame(animation);\r\n              },\r\n              upto255 = function (color) {\r\n                return color > 255 ? 255 : color < 0 ? 0 : color;\r\n              };\r\n            /*\\\r\n     * Element.animateWith\r\n     [ method ]\r\n     **\r\n     * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.\r\n     **\r\n     > Parameters\r\n     **\r\n     - el (object) element to sync with\r\n     - anim (object) animation to sync with\r\n     - params (object) #optional final attributes for the element, see also @Element.attr\r\n     - ms (number) #optional number of milliseconds for animation to run\r\n     - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`\r\n     - callback (function) #optional callback function. Will be called at the end of animation.\r\n     * or\r\n     - element (object) element to sync with\r\n     - anim (object) animation to sync with\r\n     - animation (object) #optional animation object, see @Raphael.animation\r\n     **\r\n     = (object) original element\r\n    \\*/\r\n            elproto.animateWith = function (\r\n              el,\r\n              anim,\r\n              params,\r\n              ms,\r\n              easing,\r\n              callback\r\n            ) {\r\n              var element = this;\r\n              if (element.removed) {\r\n                callback && callback.call(element);\r\n                return element;\r\n              }\r\n              var a =\r\n                  params instanceof Animation\r\n                    ? params\r\n                    : R.animation(params, ms, easing, callback),\r\n                x,\r\n                y;\r\n              runAnimation(a, element, a.percents[0], null, element.attr());\r\n              for (var i = 0, ii = animationElements.length; i < ii; i++) {\r\n                if (\r\n                  animationElements[i].anim == anim &&\r\n                  animationElements[i].el == el\r\n                ) {\r\n                  animationElements[ii - 1].start = animationElements[i].start;\r\n                  break;\r\n                }\r\n              }\r\n              return element;\r\n              //\r\n              //\r\n              // var a = params ? R.animation(params, ms, easing, callback) : anim,\r\n              //     status = element.status(anim);\r\n              // return this.animate(a).status(a, status * anim.ms / a.ms);\r\n            };\r\n            function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {\r\n              var cx = 3 * p1x,\r\n                bx = 3 * (p2x - p1x) - cx,\r\n                ax = 1 - cx - bx,\r\n                cy = 3 * p1y,\r\n                by = 3 * (p2y - p1y) - cy,\r\n                ay = 1 - cy - by;\r\n              function sampleCurveX(t) {\r\n                return ((ax * t + bx) * t + cx) * t;\r\n              }\r\n              function solve(x, epsilon) {\r\n                var t = solveCurveX(x, epsilon);\r\n                return ((ay * t + by) * t + cy) * t;\r\n              }\r\n              function solveCurveX(x, epsilon) {\r\n                var t0, t1, t2, x2, d2, i;\r\n                for (t2 = x, i = 0; i < 8; i++) {\r\n                  x2 = sampleCurveX(t2) - x;\r\n                  if (abs(x2) < epsilon) {\r\n                    return t2;\r\n                  }\r\n                  d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;\r\n                  if (abs(d2) < 1e-6) {\r\n                    break;\r\n                  }\r\n                  t2 = t2 - x2 / d2;\r\n                }\r\n                t0 = 0;\r\n                t1 = 1;\r\n                t2 = x;\r\n                if (t2 < t0) {\r\n                  return t0;\r\n                }\r\n                if (t2 > t1) {\r\n                  return t1;\r\n                }\r\n                while (t0 < t1) {\r\n                  x2 = sampleCurveX(t2);\r\n                  if (abs(x2 - x) < epsilon) {\r\n                    return t2;\r\n                  }\r\n                  if (x > x2) {\r\n                    t0 = t2;\r\n                  } else {\r\n                    t1 = t2;\r\n                  }\r\n                  t2 = (t1 - t0) / 2 + t0;\r\n                }\r\n                return t2;\r\n              }\r\n              return solve(t, 1 / (200 * duration));\r\n            }\r\n            elproto.onAnimation = function (f) {\r\n              f\r\n                ? eve.on('raphael.anim.frame.' + this.id, f)\r\n                : eve.unbind('raphael.anim.frame.' + this.id);\r\n              return this;\r\n            };\r\n            function Animation(anim, ms) {\r\n              var percents = [],\r\n                newAnim = {};\r\n              this.ms = ms;\r\n              this.times = 1;\r\n              if (anim) {\r\n                for (var attr in anim)\r\n                  if (anim[has](attr)) {\r\n                    newAnim[toFloat(attr)] = anim[attr];\r\n                    percents.push(toFloat(attr));\r\n                  }\r\n                percents.sort(sortByNumber);\r\n              }\r\n              this.anim = newAnim;\r\n              this.top = percents[percents.length - 1];\r\n              this.percents = percents;\r\n            }\r\n            /*\\\r\n     * Animation.delay\r\n     [ method ]\r\n     **\r\n     * Creates a copy of existing animation object with given delay.\r\n     **\r\n     > Parameters\r\n     **\r\n     - delay (number) number of ms to pass between animation start and actual animation\r\n     **\r\n     = (object) new altered Animation object\r\n     | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);\r\n     | circle1.animate(anim); // run the given animation immediately\r\n     | circle2.animate(anim.delay(500)); // run the given animation after 500 ms\r\n    \\*/\r\n            Animation.prototype.delay = function (delay) {\r\n              var a = new Animation(this.anim, this.ms);\r\n              a.times = this.times;\r\n              a.del = +delay || 0;\r\n              return a;\r\n            };\r\n            /*\\\r\n     * Animation.repeat\r\n     [ method ]\r\n     **\r\n     * Creates a copy of existing animation object with given repetition.\r\n     **\r\n     > Parameters\r\n     **\r\n     - repeat (number) number iterations of animation. For infinite animation pass `Infinity`\r\n     **\r\n     = (object) new altered Animation object\r\n    \\*/\r\n            Animation.prototype.repeat = function (times) {\r\n              var a = new Animation(this.anim, this.ms);\r\n              a.del = this.del;\r\n              a.times = math.floor(mmax(times, 0)) || 1;\r\n              return a;\r\n            };\r\n            function runAnimation(\r\n              anim,\r\n              element,\r\n              percent,\r\n              status,\r\n              totalOrigin,\r\n              times\r\n            ) {\r\n              percent = toFloat(percent);\r\n              var params,\r\n                isInAnim,\r\n                isInAnimSet,\r\n                percents = [],\r\n                next,\r\n                prev,\r\n                timestamp,\r\n                ms = anim.ms,\r\n                from = {},\r\n                to = {},\r\n                diff = {};\r\n              if (status) {\r\n                for (i = 0, ii = animationElements.length; i < ii; i++) {\r\n                  var e = animationElements[i];\r\n                  if (e.el.id == element.id && e.anim == anim) {\r\n                    if (e.percent != percent) {\r\n                      animationElements.splice(i, 1);\r\n                      isInAnimSet = 1;\r\n                    } else {\r\n                      isInAnim = e;\r\n                    }\r\n                    element.attr(e.totalOrigin);\r\n                    break;\r\n                  }\r\n                }\r\n              } else {\r\n                status = +to; // NaN\r\n              }\r\n              for (var i = 0, ii = anim.percents.length; i < ii; i++) {\r\n                if (\r\n                  anim.percents[i] == percent ||\r\n                  anim.percents[i] > status * anim.top\r\n                ) {\r\n                  percent = anim.percents[i];\r\n                  prev = anim.percents[i - 1] || 0;\r\n                  ms = (ms / anim.top) * (percent - prev);\r\n                  next = anim.percents[i + 1];\r\n                  params = anim.anim[percent];\r\n                  break;\r\n                } else if (status) {\r\n                  element.attr(anim.anim[anim.percents[i]]);\r\n                }\r\n              }\r\n              if (!params) {\r\n                return;\r\n              }\r\n              if (!isInAnim) {\r\n                for (var attr in params)\r\n                  if (params[has](attr)) {\r\n                    if (\r\n                      availableAnimAttrs[has](attr) ||\r\n                      element.paper.customAttributes[has](attr)\r\n                    ) {\r\n                      from[attr] = element.attr(attr);\r\n                      from[attr] == null && (from[attr] = availableAttrs[attr]);\r\n                      to[attr] = params[attr];\r\n                      switch (availableAnimAttrs[attr]) {\r\n                        case nu:\r\n                          diff[attr] = (to[attr] - from[attr]) / ms;\r\n                          break;\r\n                        case 'colour':\r\n                          from[attr] = R.getRGB(from[attr]);\r\n                          var toColour = R.getRGB(to[attr]);\r\n                          diff[attr] = {\r\n                            r: (toColour.r - from[attr].r) / ms,\r\n                            g: (toColour.g - from[attr].g) / ms,\r\n                            b: (toColour.b - from[attr].b) / ms,\r\n                          };\r\n                          break;\r\n                        case 'path':\r\n                          var pathes = path2curve(from[attr], to[attr]),\r\n                            toPath = pathes[1];\r\n                          from[attr] = pathes[0];\r\n                          diff[attr] = [];\r\n                          for (i = 0, ii = from[attr].length; i < ii; i++) {\r\n                            diff[attr][i] = [0];\r\n                            for (\r\n                              var j = 1, jj = from[attr][i].length;\r\n                              j < jj;\r\n                              j++\r\n                            ) {\r\n                              diff[attr][i][j] =\r\n                                (toPath[i][j] - from[attr][i][j]) / ms;\r\n                            }\r\n                          }\r\n                          break;\r\n                        case 'transform':\r\n                          var _ = element._,\r\n                            eq = equaliseTransform(_[attr], to[attr]);\r\n                          if (eq) {\r\n                            from[attr] = eq.from;\r\n                            to[attr] = eq.to;\r\n                            diff[attr] = [];\r\n                            diff[attr].real = true;\r\n                            for (i = 0, ii = from[attr].length; i < ii; i++) {\r\n                              diff[attr][i] = [from[attr][i][0]];\r\n                              for (\r\n                                j = 1, jj = from[attr][i].length;\r\n                                j < jj;\r\n                                j++\r\n                              ) {\r\n                                diff[attr][i][j] =\r\n                                  (to[attr][i][j] - from[attr][i][j]) / ms;\r\n                              }\r\n                            }\r\n                          } else {\r\n                            var m = element.matrix || new Matrix(),\r\n                              to2 = {\r\n                                _: { transform: _.transform },\r\n                                getBBox: function () {\r\n                                  return element.getBBox(1);\r\n                                },\r\n                              };\r\n                            from[attr] = [m.a, m.b, m.c, m.d, m.e, m.f];\r\n                            extractTransform(to2, to[attr]);\r\n                            to[attr] = to2._.transform;\r\n                            diff[attr] = [\r\n                              (to2.matrix.a - m.a) / ms,\r\n                              (to2.matrix.b - m.b) / ms,\r\n                              (to2.matrix.c - m.c) / ms,\r\n                              (to2.matrix.d - m.d) / ms,\r\n                              (to2.matrix.e - m.e) / ms,\r\n                              (to2.matrix.f - m.f) / ms,\r\n                            ];\r\n                            // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];\r\n                            // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};\r\n                            // extractTransform(to2, to[attr]);\r\n                            // diff[attr] = [\r\n                            //     (to2._.sx - _.sx) / ms,\r\n                            //     (to2._.sy - _.sy) / ms,\r\n                            //     (to2._.deg - _.deg) / ms,\r\n                            //     (to2._.dx - _.dx) / ms,\r\n                            //     (to2._.dy - _.dy) / ms\r\n                            // ];\r\n                          }\r\n                          break;\r\n                        case 'csv':\r\n                          var values = Str(params[attr])[split](separator),\r\n                            from2 = Str(from[attr])[split](separator);\r\n                          if (attr == 'clip-rect') {\r\n                            from[attr] = from2;\r\n                            diff[attr] = [];\r\n                            i = from2.length;\r\n                            while (i--) {\r\n                              diff[attr][i] = (values[i] - from[attr][i]) / ms;\r\n                            }\r\n                          }\r\n                          to[attr] = values;\r\n                          break;\r\n                        default:\r\n                          values = [][concat](params[attr]);\r\n                          from2 = [][concat](from[attr]);\r\n                          diff[attr] = [];\r\n                          i = element.paper.customAttributes[attr].length;\r\n                          while (i--) {\r\n                            diff[attr][i] =\r\n                              ((values[i] || 0) - (from2[i] || 0)) / ms;\r\n                          }\r\n                          break;\r\n                      }\r\n                    }\r\n                  }\r\n                var easing = params.easing,\r\n                  easyeasy = R.easing_formulas[easing];\r\n                if (!easyeasy) {\r\n                  easyeasy = Str(easing).match(bezierrg);\r\n                  if (easyeasy && easyeasy.length == 5) {\r\n                    var curve = easyeasy;\r\n                    easyeasy = function (t) {\r\n                      return CubicBezierAtTime(\r\n                        t,\r\n                        +curve[1],\r\n                        +curve[2],\r\n                        +curve[3],\r\n                        +curve[4],\r\n                        ms\r\n                      );\r\n                    };\r\n                  } else {\r\n                    easyeasy = pipe;\r\n                  }\r\n                }\r\n                timestamp = params.start || anim.start || +new Date();\r\n                e = {\r\n                  anim: anim,\r\n                  percent: percent,\r\n                  timestamp: timestamp,\r\n                  start: timestamp + (anim.del || 0),\r\n                  status: 0,\r\n                  initstatus: status || 0,\r\n                  stop: false,\r\n                  ms: ms,\r\n                  easing: easyeasy,\r\n                  from: from,\r\n                  diff: diff,\r\n                  to: to,\r\n                  el: element,\r\n                  callback: params.callback,\r\n                  prev: prev,\r\n                  next: next,\r\n                  repeat: times || anim.times,\r\n                  origin: element.attr(),\r\n                  totalOrigin: totalOrigin,\r\n                };\r\n                animationElements.push(e);\r\n                if (status && !isInAnim && !isInAnimSet) {\r\n                  e.stop = true;\r\n                  e.start = new Date() - ms * status;\r\n                  if (animationElements.length == 1) {\r\n                    return animation();\r\n                  }\r\n                }\r\n                if (isInAnimSet) {\r\n                  e.start = new Date() - e.ms * status;\r\n                }\r\n                animationElements.length == 1 && requestAnimFrame(animation);\r\n              } else {\r\n                isInAnim.initstatus = status;\r\n                isInAnim.start = new Date() - isInAnim.ms * status;\r\n              }\r\n              eve('raphael.anim.start.' + element.id, element, anim);\r\n            }\r\n            /*\\\r\n     * Raphael.animation\r\n     [ method ]\r\n     **\r\n     * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.\r\n     * See also @Animation.delay and @Animation.repeat methods.\r\n     **\r\n     > Parameters\r\n     **\r\n     - params (object) final attributes for the element, see also @Element.attr\r\n     - ms (number) number of milliseconds for animation to run\r\n     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`\r\n     - callback (function) #optional callback function. Will be called at the end of animation.\r\n     **\r\n     = (object) @Animation\r\n    \\*/\r\n            R.animation = function (params, ms, easing, callback) {\r\n              if (params instanceof Animation) {\r\n                return params;\r\n              }\r\n              if (R.is(easing, 'function') || !easing) {\r\n                callback = callback || easing || null;\r\n                easing = null;\r\n              }\r\n              params = Object(params);\r\n              ms = +ms || 0;\r\n              var p = {},\r\n                json,\r\n                attr;\r\n              for (attr in params)\r\n                if (\r\n                  params[has](attr) &&\r\n                  toFloat(attr) != attr &&\r\n                  toFloat(attr) + '%' != attr\r\n                ) {\r\n                  json = true;\r\n                  p[attr] = params[attr];\r\n                }\r\n              if (!json) {\r\n                // if percent-like syntax is used and end-of-all animation callback used\r\n                if (callback) {\r\n                  // find the last one\r\n                  var lastKey = 0;\r\n                  for (var i in params) {\r\n                    var percent = toInt(i);\r\n                    if (params[has](i) && percent > lastKey) {\r\n                      lastKey = percent;\r\n                    }\r\n                  }\r\n                  lastKey += '%';\r\n                  // if already defined callback in the last keyframe, skip\r\n                  !params[lastKey].callback &&\r\n                    (params[lastKey].callback = callback);\r\n                }\r\n                return new Animation(params, ms);\r\n              } else {\r\n                easing && (p.easing = easing);\r\n                callback && (p.callback = callback);\r\n                return new Animation({ 100: p }, ms);\r\n              }\r\n            };\r\n            /*\\\r\n     * Element.animate\r\n     [ method ]\r\n     **\r\n     * Creates and starts animation for given element.\r\n     **\r\n     > Parameters\r\n     **\r\n     - params (object) final attributes for the element, see also @Element.attr\r\n     - ms (number) number of milliseconds for animation to run\r\n     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`\r\n     - callback (function) #optional callback function. Will be called at the end of animation.\r\n     * or\r\n     - animation (object) animation object, see @Raphael.animation\r\n     **\r\n     = (object) original element\r\n    \\*/\r\n            elproto.animate = function (params, ms, easing, callback) {\r\n              var element = this;\r\n              if (element.removed) {\r\n                callback && callback.call(element);\r\n                return element;\r\n              }\r\n              var anim =\r\n                params instanceof Animation\r\n                  ? params\r\n                  : R.animation(params, ms, easing, callback);\r\n              runAnimation(\r\n                anim,\r\n                element,\r\n                anim.percents[0],\r\n                null,\r\n                element.attr()\r\n              );\r\n              return element;\r\n            };\r\n            /*\\\r\n     * Element.setTime\r\n     [ method ]\r\n     **\r\n     * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.\r\n     **\r\n     > Parameters\r\n     **\r\n     - anim (object) animation object\r\n     - value (number) number of milliseconds from the beginning of the animation\r\n     **\r\n     = (object) original element if `value` is specified\r\n     * Note, that during animation following events are triggered:\r\n     *\r\n     * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.\r\n    \\*/\r\n            elproto.setTime = function (anim, value) {\r\n              if (anim && value != null) {\r\n                this.status(anim, mmin(value, anim.ms) / anim.ms);\r\n              }\r\n              return this;\r\n            };\r\n            /*\\\r\n     * Element.status\r\n     [ method ]\r\n     **\r\n     * Gets or sets the status of animation of the element.\r\n     **\r\n     > Parameters\r\n     **\r\n     - anim (object) #optional animation object\r\n     - value (number) #optional 0 – 1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.\r\n     **\r\n     = (number) status\r\n     * or\r\n     = (array) status if `anim` is not specified. Array of objects in format:\r\n     o {\r\n     o     anim: (object) animation object\r\n     o     status: (number) status\r\n     o }\r\n     * or\r\n     = (object) original element if `value` is specified\r\n    \\*/\r\n            elproto.status = function (anim, value) {\r\n              var out = [],\r\n                i = 0,\r\n                len,\r\n                e;\r\n              if (value != null) {\r\n                runAnimation(anim, this, -1, mmin(value, 1));\r\n                return this;\r\n              } else {\r\n                len = animationElements.length;\r\n                for (; i < len; i++) {\r\n                  e = animationElements[i];\r\n                  if (e.el.id == this.id && (!anim || e.anim == anim)) {\r\n                    if (anim) {\r\n                      return e.status;\r\n                    }\r\n                    out.push({\r\n                      anim: e.anim,\r\n                      status: e.status,\r\n                    });\r\n                  }\r\n                }\r\n                if (anim) {\r\n                  return 0;\r\n                }\r\n                return out;\r\n              }\r\n            };\r\n            /*\\\r\n     * Element.pause\r\n     [ method ]\r\n     **\r\n     * Stops animation of the element with ability to resume it later on.\r\n     **\r\n     > Parameters\r\n     **\r\n     - anim (object) #optional animation object\r\n     **\r\n     = (object) original element\r\n    \\*/\r\n            elproto.pause = function (anim) {\r\n              for (var i = 0; i < animationElements.length; i++)\r\n                if (\r\n                  animationElements[i].el.id == this.id &&\r\n                  (!anim || animationElements[i].anim == anim)\r\n                ) {\r\n                  if (\r\n                    eve(\r\n                      'raphael.anim.pause.' + this.id,\r\n                      this,\r\n                      animationElements[i].anim\r\n                    ) !== false\r\n                  ) {\r\n                    animationElements[i].paused = true;\r\n                  }\r\n                }\r\n              return this;\r\n            };\r\n            /*\\\r\n     * Element.resume\r\n     [ method ]\r\n     **\r\n     * Resumes animation if it was paused with @Element.pause method.\r\n     **\r\n     > Parameters\r\n     **\r\n     - anim (object) #optional animation object\r\n     **\r\n     = (object) original element\r\n    \\*/\r\n            elproto.resume = function (anim) {\r\n              for (var i = 0; i < animationElements.length; i++)\r\n                if (\r\n                  animationElements[i].el.id == this.id &&\r\n                  (!anim || animationElements[i].anim == anim)\r\n                ) {\r\n                  var e = animationElements[i];\r\n                  if (\r\n                    eve('raphael.anim.resume.' + this.id, this, e.anim) !==\r\n                    false\r\n                  ) {\r\n                    delete e.paused;\r\n                    this.status(e.anim, e.status);\r\n                  }\r\n                }\r\n              return this;\r\n            };\r\n            /*\\\r\n     * Element.stop\r\n     [ method ]\r\n     **\r\n     * Stops animation of the element.\r\n     **\r\n     > Parameters\r\n     **\r\n     - anim (object) #optional animation object\r\n     **\r\n     = (object) original element\r\n    \\*/\r\n            elproto.stop = function (anim) {\r\n              for (var i = 0; i < animationElements.length; i++)\r\n                if (\r\n                  animationElements[i].el.id == this.id &&\r\n                  (!anim || animationElements[i].anim == anim)\r\n                ) {\r\n                  if (\r\n                    eve(\r\n                      'raphael.anim.stop.' + this.id,\r\n                      this,\r\n                      animationElements[i].anim\r\n                    ) !== false\r\n                  ) {\r\n                    animationElements.splice(i--, 1);\r\n                  }\r\n                }\r\n              return this;\r\n            };\r\n            function stopAnimation(paper) {\r\n              for (var i = 0; i < animationElements.length; i++)\r\n                if (animationElements[i].el.paper == paper) {\r\n                  animationElements.splice(i--, 1);\r\n                }\r\n            }\r\n            eve.on('raphael.remove', stopAnimation);\r\n            eve.on('raphael.clear', stopAnimation);\r\n            elproto.toString = function () {\r\n              return 'Rapha\\xebl\\u2019s object';\r\n            };\r\n\r\n            // Set\r\n            var Set = function (items) {\r\n                this.items = [];\r\n                this.length = 0;\r\n                this.type = 'set';\r\n                if (items) {\r\n                  for (var i = 0, ii = items.length; i < ii; i++) {\r\n                    if (\r\n                      items[i] &&\r\n                      (items[i].constructor == elproto.constructor ||\r\n                        items[i].constructor == Set)\r\n                    ) {\r\n                      this[this.items.length] = this.items[this.items.length] =\r\n                        items[i];\r\n                      this.length++;\r\n                    }\r\n                  }\r\n                }\r\n              },\r\n              setproto = Set.prototype;\r\n            /*\\\r\n     * Set.push\r\n     [ method ]\r\n     **\r\n     * Adds each argument to the current set.\r\n     = (object) original element\r\n    \\*/\r\n            setproto.push = function () {\r\n              var item, len;\r\n              for (var i = 0, ii = arguments.length; i < ii; i++) {\r\n                item = arguments[i];\r\n                if (\r\n                  item &&\r\n                  (item.constructor == elproto.constructor ||\r\n                    item.constructor == Set)\r\n                ) {\r\n                  len = this.items.length;\r\n                  this[len] = this.items[len] = item;\r\n                  this.length++;\r\n                }\r\n              }\r\n              return this;\r\n            };\r\n            /*\\\r\n     * Set.pop\r\n     [ method ]\r\n     **\r\n     * Removes last element and returns it.\r\n     = (object) element\r\n    \\*/\r\n            setproto.pop = function () {\r\n              this.length && delete this[this.length--];\r\n              return this.items.pop();\r\n            };\r\n            /*\\\r\n     * Set.forEach\r\n     [ method ]\r\n     **\r\n     * Executes given function for each element in the set.\r\n     *\r\n     * If function returns `false` it will stop loop running.\r\n     **\r\n     > Parameters\r\n     **\r\n     - callback (function) function to run\r\n     - thisArg (object) context object for the callback\r\n     = (object) Set object\r\n    \\*/\r\n            setproto.forEach = function (callback, thisArg) {\r\n              for (var i = 0, ii = this.items.length; i < ii; i++) {\r\n                if (callback.call(thisArg, this.items[i], i) === false) {\r\n                  return this;\r\n                }\r\n              }\r\n              return this;\r\n            };\r\n            for (var method in elproto)\r\n              if (elproto[has](method)) {\r\n                setproto[method] = (function (methodname) {\r\n                  return function () {\r\n                    var arg = arguments;\r\n                    return this.forEach(function (el) {\r\n                      el[methodname][apply](el, arg);\r\n                    });\r\n                  };\r\n                })(method);\r\n              }\r\n            setproto.attr = function (name, value) {\r\n              if (name && R.is(name, array) && R.is(name[0], 'object')) {\r\n                for (var j = 0, jj = name.length; j < jj; j++) {\r\n                  this.items[j].attr(name[j]);\r\n                }\r\n              } else {\r\n                for (var i = 0, ii = this.items.length; i < ii; i++) {\r\n                  this.items[i].attr(name, value);\r\n                }\r\n              }\r\n              return this;\r\n            };\r\n            /*\\\r\n     * Set.clear\r\n     [ method ]\r\n     **\r\n     * Removes all elements from the set\r\n    \\*/\r\n            setproto.clear = function () {\r\n              while (this.length) {\r\n                this.pop();\r\n              }\r\n            };\r\n            /*\\\r\n     * Set.splice\r\n     [ method ]\r\n     **\r\n     * Removes given element from the set\r\n     **\r\n     > Parameters\r\n     **\r\n     - index (number) position of the deletion\r\n     - count (number) number of element to remove\r\n     - insertion… (object) #optional elements to insert\r\n     = (object) set elements that were deleted\r\n    \\*/\r\n            setproto.splice = function (index, count, insertion) {\r\n              index = index < 0 ? mmax(this.length + index, 0) : index;\r\n              count = mmax(0, mmin(this.length - index, count));\r\n              var tail = [],\r\n                todel = [],\r\n                args = [],\r\n                i;\r\n              for (i = 2; i < arguments.length; i++) {\r\n                args.push(arguments[i]);\r\n              }\r\n              for (i = 0; i < count; i++) {\r\n                todel.push(this[index + i]);\r\n              }\r\n              for (; i < this.length - index; i++) {\r\n                tail.push(this[index + i]);\r\n              }\r\n              var arglen = args.length;\r\n              for (i = 0; i < arglen + tail.length; i++) {\r\n                this.items[index + i] = this[index + i] =\r\n                  i < arglen ? args[i] : tail[i - arglen];\r\n              }\r\n              i = this.items.length = this.length -= count - arglen;\r\n              while (this[i]) {\r\n                delete this[i++];\r\n              }\r\n              return new Set(todel);\r\n            };\r\n            /*\\\r\n     * Set.exclude\r\n     [ method ]\r\n     **\r\n     * Removes given element from the set\r\n     **\r\n     > Parameters\r\n     **\r\n     - element (object) element to remove\r\n     = (boolean) `true` if object was found & removed from the set\r\n    \\*/\r\n            setproto.exclude = function (el) {\r\n              for (var i = 0, ii = this.length; i < ii; i++)\r\n                if (this[i] == el) {\r\n                  this.splice(i, 1);\r\n                  return true;\r\n                }\r\n            };\r\n            setproto.animate = function (params, ms, easing, callback) {\r\n              (R.is(easing, 'function') || !easing) &&\r\n                (callback = easing || null);\r\n              var len = this.items.length,\r\n                i = len,\r\n                item,\r\n                set = this,\r\n                collector;\r\n              if (!len) {\r\n                return this;\r\n              }\r\n              callback &&\r\n                (collector = function () {\r\n                  !--len && callback.call(set);\r\n                });\r\n              easing = R.is(easing, string) ? easing : collector;\r\n              var anim = R.animation(params, ms, easing, collector);\r\n              item = this.items[--i].animate(anim);\r\n              while (i--) {\r\n                this.items[i] &&\r\n                  !this.items[i].removed &&\r\n                  this.items[i].animateWith(item, anim, anim);\r\n                (this.items[i] && !this.items[i].removed) || len--;\r\n              }\r\n              return this;\r\n            };\r\n            setproto.insertAfter = function (el) {\r\n              var i = this.items.length;\r\n              while (i--) {\r\n                this.items[i].insertAfter(el);\r\n              }\r\n              return this;\r\n            };\r\n            setproto.getBBox = function () {\r\n              var x = [],\r\n                y = [],\r\n                x2 = [],\r\n                y2 = [];\r\n              for (var i = this.items.length; i--; )\r\n                if (!this.items[i].removed) {\r\n                  var box = this.items[i].getBBox();\r\n                  x.push(box.x);\r\n                  y.push(box.y);\r\n                  x2.push(box.x + box.width);\r\n                  y2.push(box.y + box.height);\r\n                }\r\n              x = mmin[apply](0, x);\r\n              y = mmin[apply](0, y);\r\n              x2 = mmax[apply](0, x2);\r\n              y2 = mmax[apply](0, y2);\r\n              return {\r\n                x: x,\r\n                y: y,\r\n                x2: x2,\r\n                y2: y2,\r\n                width: x2 - x,\r\n                height: y2 - y,\r\n              };\r\n            };\r\n            setproto.clone = function (s) {\r\n              s = this.paper.set();\r\n              for (var i = 0, ii = this.items.length; i < ii; i++) {\r\n                s.push(this.items[i].clone());\r\n              }\r\n              return s;\r\n            };\r\n            setproto.toString = function () {\r\n              return 'Rapha\\xebl\\u2018s set';\r\n            };\r\n\r\n            setproto.glow = function (glowConfig) {\r\n              var ret = this.paper.set();\r\n              this.forEach(function (shape, index) {\r\n                var g = shape.glow(glowConfig);\r\n                if (g != null) {\r\n                  g.forEach(function (shape2, index2) {\r\n                    ret.push(shape2);\r\n                  });\r\n                }\r\n              });\r\n              return ret;\r\n            };\r\n\r\n            /*\\\r\n     * Set.isPointInside\r\n     [ method ]\r\n     **\r\n     * Determine if given point is inside this set’s elements\r\n     **\r\n     > Parameters\r\n     **\r\n     - x (number) x coordinate of the point\r\n     - y (number) y coordinate of the point\r\n     = (boolean) `true` if point is inside any of the set's elements\r\n     \\*/\r\n            setproto.isPointInside = function (x, y) {\r\n              var isPointInside = false;\r\n              this.forEach(function (el) {\r\n                if (el.isPointInside(x, y)) {\r\n                  isPointInside = true;\r\n                  return false; // stop loop\r\n                }\r\n              });\r\n              return isPointInside;\r\n            };\r\n\r\n            /*\\\r\n     * Raphael.registerFont\r\n     [ method ]\r\n     **\r\n     * Adds given font to the registered set of fonts for Raphaël. Should be used as an internal call from within Cufón’s font file.\r\n     * Returns original parameter, so it could be used with chaining.\r\n     # <a href=\"http://wiki.github.com/sorccu/cufon/about\">More about Cufón and how to convert your font form TTF, OTF, etc to JavaScript file.</a>\r\n     **\r\n     > Parameters\r\n     **\r\n     - font (object) the font to register\r\n     = (object) the font you passed in\r\n     > Usage\r\n     | Cufon.registerFont(Raphael.registerFont({…}));\r\n    \\*/\r\n            R.registerFont = function (font) {\r\n              if (!font.face) {\r\n                return font;\r\n              }\r\n              this.fonts = this.fonts || {};\r\n              var fontcopy = {\r\n                  w: font.w,\r\n                  face: {},\r\n                  glyphs: {},\r\n                },\r\n                family = font.face['font-family'];\r\n              for (var prop in font.face)\r\n                if (font.face[has](prop)) {\r\n                  fontcopy.face[prop] = font.face[prop];\r\n                }\r\n              if (this.fonts[family]) {\r\n                this.fonts[family].push(fontcopy);\r\n              } else {\r\n                this.fonts[family] = [fontcopy];\r\n              }\r\n              if (!font.svg) {\r\n                fontcopy.face['units-per-em'] = toInt(\r\n                  font.face['units-per-em'],\r\n                  10\r\n                );\r\n                for (var glyph in font.glyphs)\r\n                  if (font.glyphs[has](glyph)) {\r\n                    var path = font.glyphs[glyph];\r\n                    fontcopy.glyphs[glyph] = {\r\n                      w: path.w,\r\n                      k: {},\r\n                      d:\r\n                        path.d &&\r\n                        'M' +\r\n                          path.d.replace(/[mlcxtrv]/g, function (command) {\r\n                            return (\r\n                              {\r\n                                l: 'L',\r\n                                c: 'C',\r\n                                x: 'z',\r\n                                t: 'm',\r\n                                r: 'l',\r\n                                v: 'c',\r\n                              }[command] || 'M'\r\n                            );\r\n                          }) +\r\n                          'z',\r\n                    };\r\n                    if (path.k) {\r\n                      for (var k in path.k)\r\n                        if (path[has](k)) {\r\n                          fontcopy.glyphs[glyph].k[k] = path.k[k];\r\n                        }\r\n                    }\r\n                  }\r\n              }\r\n              return font;\r\n            };\r\n            /*\\\r\n     * Paper.getFont\r\n     [ method ]\r\n     **\r\n     * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like “Myriad” for “Myriad Pro”.\r\n     **\r\n     > Parameters\r\n     **\r\n     - family (string) font family name or any word from it\r\n     - weight (string) #optional font weight\r\n     - style (string) #optional font style\r\n     - stretch (string) #optional font stretch\r\n     = (object) the font object\r\n     > Usage\r\n     | paper.print(100, 100, \"Test string\", paper.getFont(\"Times\", 800), 30);\r\n    \\*/\r\n            paperproto.getFont = function (family, weight, style, stretch) {\r\n              stretch = stretch || 'normal';\r\n              style = style || 'normal';\r\n              weight =\r\n                +weight ||\r\n                { normal: 400, bold: 700, lighter: 300, bolder: 800 }[weight] ||\r\n                400;\r\n              if (!R.fonts) {\r\n                return;\r\n              }\r\n              var font = R.fonts[family];\r\n              if (!font) {\r\n                var name = new RegExp(\r\n                  '(^|\\\\s)' +\r\n                    family.replace(/[^\\w\\d\\s+!~.:_-]/g, E) +\r\n                    '(\\\\s|$)',\r\n                  'i'\r\n                );\r\n                for (var fontName in R.fonts)\r\n                  if (R.fonts[has](fontName)) {\r\n                    if (name.test(fontName)) {\r\n                      font = R.fonts[fontName];\r\n                      break;\r\n                    }\r\n                  }\r\n              }\r\n              var thefont;\r\n              if (font) {\r\n                for (var i = 0, ii = font.length; i < ii; i++) {\r\n                  thefont = font[i];\r\n                  if (\r\n                    thefont.face['font-weight'] == weight &&\r\n                    (thefont.face['font-style'] == style ||\r\n                      !thefont.face['font-style']) &&\r\n                    thefont.face['font-stretch'] == stretch\r\n                  ) {\r\n                    break;\r\n                  }\r\n                }\r\n              }\r\n              return thefont;\r\n            };\r\n            /*\\\r\n     * Paper.print\r\n     [ method ]\r\n     **\r\n     * Creates path that represent given text written using given font at given position with given size.\r\n     * Result of the method is path element that contains whole text as a separate path.\r\n     **\r\n     > Parameters\r\n     **\r\n     - x (number) x position of the text\r\n     - y (number) y position of the text\r\n     - string (string) text to print\r\n     - font (object) font object, see @Paper.getFont\r\n     - size (number) #optional size of the font, default is `16`\r\n     - origin (string) #optional could be `\"baseline\"` or `\"middle\"`, default is `\"middle\"`\r\n     - letter_spacing (number) #optional number in range `-1..1`, default is `0`\r\n     - line_spacing (number) #optional number in range `1..3`, default is `1`\r\n     = (object) resulting path element, which consist of all letters\r\n     > Usage\r\n     | var txt = r.print(10, 50, \"print\", r.getFont(\"Museo\"), 30).attr({fill: \"#fff\"});\r\n    \\*/\r\n            paperproto.print = function (\r\n              x,\r\n              y,\r\n              string,\r\n              font,\r\n              size,\r\n              origin,\r\n              letter_spacing,\r\n              line_spacing\r\n            ) {\r\n              origin = origin || 'middle'; // baseline|middle\r\n              letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);\r\n              line_spacing = mmax(mmin(line_spacing || 1, 3), 1);\r\n              var letters = Str(string)[split](E),\r\n                shift = 0,\r\n                notfirst = 0,\r\n                path = E,\r\n                scale;\r\n              R.is(font, 'string') && (font = this.getFont(font));\r\n              if (font) {\r\n                scale = (size || 16) / font.face['units-per-em'];\r\n                var bb = font.face.bbox[split](separator),\r\n                  top = +bb[0],\r\n                  lineHeight = bb[3] - bb[1],\r\n                  shifty = 0,\r\n                  height =\r\n                    +bb[1] +\r\n                    (origin == 'baseline'\r\n                      ? lineHeight + +font.face.descent\r\n                      : lineHeight / 2);\r\n                for (var i = 0, ii = letters.length; i < ii; i++) {\r\n                  if (letters[i] == '\\n') {\r\n                    shift = 0;\r\n                    curr = 0;\r\n                    notfirst = 0;\r\n                    shifty += lineHeight * line_spacing;\r\n                  } else {\r\n                    var prev = (notfirst && font.glyphs[letters[i - 1]]) || {},\r\n                      curr = font.glyphs[letters[i]];\r\n                    shift += notfirst\r\n                      ? (prev.w || font.w) +\r\n                        ((prev.k && prev.k[letters[i]]) || 0) +\r\n                        font.w * letter_spacing\r\n                      : 0;\r\n                    notfirst = 1;\r\n                  }\r\n                  if (curr && curr.d) {\r\n                    path += R.transformPath(curr.d, [\r\n                      't',\r\n                      shift * scale,\r\n                      shifty * scale,\r\n                      's',\r\n                      scale,\r\n                      scale,\r\n                      top,\r\n                      height,\r\n                      't',\r\n                      (x - top) / scale,\r\n                      (y - height) / scale,\r\n                    ]);\r\n                  }\r\n                }\r\n              }\r\n              return this.path(path).attr({\r\n                fill: '#000',\r\n                stroke: 'none',\r\n              });\r\n            };\r\n\r\n            /*\\\r\n     * Paper.add\r\n     [ method ]\r\n     **\r\n     * Imports elements in JSON array in format `{type: type, <attributes>}`\r\n     **\r\n     > Parameters\r\n     **\r\n     - json (array)\r\n     = (object) resulting set of imported elements\r\n     > Usage\r\n     | paper.add([\r\n     |     {\r\n     |         type: \"circle\",\r\n     |         cx: 10,\r\n     |         cy: 10,\r\n     |         r: 5\r\n     |     },\r\n     |     {\r\n     |         type: \"rect\",\r\n     |         x: 10,\r\n     |         y: 10,\r\n     |         width: 10,\r\n     |         height: 10,\r\n     |         fill: \"#fc0\"\r\n     |     }\r\n     | ]);\r\n    \\*/\r\n            paperproto.add = function (json) {\r\n              if (R.is(json, 'array')) {\r\n                var res = this.set(),\r\n                  i = 0,\r\n                  ii = json.length,\r\n                  j;\r\n                for (; i < ii; i++) {\r\n                  j = json[i] || {};\r\n                  elements[has](j.type) && res.push(this[j.type]().attr(j));\r\n                }\r\n              }\r\n              return res;\r\n            };\r\n\r\n            /*\\\r\n     * Raphael.format\r\n     [ method ]\r\n     **\r\n     * Simple format function. Replaces construction of type “`{<number>}`” to the corresponding argument.\r\n     **\r\n     > Parameters\r\n     **\r\n     - token (string) string to format\r\n     - … (string) rest of arguments will be treated as parameters for replacement\r\n     = (string) formated string\r\n     > Usage\r\n     | var x = 10,\r\n     |     y = 20,\r\n     |     width = 40,\r\n     |     height = 50;\r\n     | // this will draw a rectangular shape equivalent to \"M10,20h40v50h-40z\"\r\n     | paper.path(Raphael.format(\"M{0},{1}h{2}v{3}h{4}z\", x, y, width, height, -width));\r\n    \\*/\r\n            R.format = function (token, params) {\r\n              var args = R.is(params, array) ? [0][concat](params) : arguments;\r\n              token &&\r\n                R.is(token, string) &&\r\n                args.length - 1 &&\r\n                (token = token.replace(formatrg, function (str, i) {\r\n                  return args[++i] == null ? E : args[i];\r\n                }));\r\n              return token || E;\r\n            };\r\n            /*\\\r\n     * Raphael.fullfill\r\n     [ method ]\r\n     **\r\n     * A little bit more advanced format function than @Raphael.format. Replaces construction of type “`{<name>}`” to the corresponding argument.\r\n     **\r\n     > Parameters\r\n     **\r\n     - token (string) string to format\r\n     - json (object) object which properties will be used as a replacement\r\n     = (string) formated string\r\n     > Usage\r\n     | // this will draw a rectangular shape equivalent to \"M10,20h40v50h-40z\"\r\n     | paper.path(Raphael.fullfill(\"M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z\", {\r\n     |     x: 10,\r\n     |     y: 20,\r\n     |     dim: {\r\n     |         width: 40,\r\n     |         height: 50,\r\n     |         \"negative width\": -40\r\n     |     }\r\n     | }));\r\n    \\*/\r\n            R.fullfill = (function () {\r\n              var tokenRegex = /\\{([^\\}]+)\\}/g,\r\n                objNotationRegex =\r\n                  /(?:(?:^|\\.)(.+?)(?=\\[|\\.|$|\\()|\\[('|\")(.+?)\\2\\])(\\(\\))?/g, // matches .xxxxx or [\"xxxxx\"] to run over object properties\r\n                replacer = function (all, key, obj) {\r\n                  var res = obj;\r\n                  key.replace(\r\n                    objNotationRegex,\r\n                    function (all, name, quote, quotedName, isFunc) {\r\n                      name = name || quotedName;\r\n                      if (res) {\r\n                        if (name in res) {\r\n                          res = res[name];\r\n                        }\r\n                        typeof res == 'function' && isFunc && (res = res());\r\n                      }\r\n                    }\r\n                  );\r\n                  res = (res == null || res == obj ? all : res) + '';\r\n                  return res;\r\n                };\r\n              return function (str, obj) {\r\n                return String(str).replace(tokenRegex, function (all, key) {\r\n                  return replacer(all, key, obj);\r\n                });\r\n              };\r\n            })();\r\n            /*\\\r\n     * Raphael.ninja\r\n     [ method ]\r\n     **\r\n     * If you want to leave no trace of Raphaël (Well, Raphaël creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.\r\n     * Beware, that in this case plugins could stop working, because they are depending on global variable existence.\r\n     **\r\n     = (object) Raphael object\r\n     > Usage\r\n     | (function (local_raphael) {\r\n     |     var paper = local_raphael(10, 10, 320, 200);\r\n     |     …\r\n     | })(Raphael.ninja());\r\n    \\*/\r\n            R.ninja = function () {\r\n              if (oldRaphael.was) {\r\n                g.win.Raphael = oldRaphael.is;\r\n              } else {\r\n                // IE8 raises an error when deleting window property\r\n                window.Raphael = undefined;\r\n                try {\r\n                  delete window.Raphael;\r\n                } catch (e) {}\r\n              }\r\n              return R;\r\n            };\r\n            /*\\\r\n     * Raphael.st\r\n     [ property (object) ]\r\n     **\r\n     * You can add your own method to elements and sets. It is wise to add a set method for each element method\r\n     * you added, so you will be able to call the same method on sets too.\r\n     **\r\n     * See also @Raphael.el.\r\n     > Usage\r\n     | Raphael.el.red = function () {\r\n     |     this.attr({fill: \"#f00\"});\r\n     | };\r\n     | Raphael.st.red = function () {\r\n     |     this.forEach(function (el) {\r\n     |         el.red();\r\n     |     });\r\n     | };\r\n     | // then use it\r\n     | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();\r\n    \\*/\r\n            R.st = setproto;\r\n\r\n            eve.on('raphael.DOMload', function () {\r\n              loaded = true;\r\n            });\r\n\r\n            // Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html\r\n            (function (doc, loaded, f) {\r\n              if (doc.readyState == null && doc.addEventListener) {\r\n                doc.addEventListener(\r\n                  loaded,\r\n                  (f = function () {\r\n                    doc.removeEventListener(loaded, f, false);\r\n                    doc.readyState = 'complete';\r\n                  }),\r\n                  false\r\n                );\r\n                doc.readyState = 'loading';\r\n              }\r\n              function isLoaded() {\r\n                /in/.test(doc.readyState)\r\n                  ? setTimeout(isLoaded, 9)\r\n                  : R.eve('raphael.DOMload');\r\n              }\r\n              isLoaded();\r\n            })(document, 'DOMContentLoaded');\r\n\r\n            return R;\r\n          }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)),\r\n          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&\r\n            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n          /***/\r\n        },\r\n\r\n      /***/ './dev/raphael.svg.js':\r\n        /*!****************************!*\\\r\n  !*** ./dev/raphael.svg.js ***!\r\n  \\****************************/\r\n        /*! no static exports found */\r\n        /***/ function (module, exports, __nested_webpack_require_239900__) {\r\n          var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\r\n          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n            __nested_webpack_require_239900__(/*! ./raphael.core */ './dev/raphael.core.js'),\r\n          ]),\r\n          (__WEBPACK_AMD_DEFINE_RESULT__ = function (R) {\r\n            if (R && !R.svg) {\r\n              return;\r\n            }\r\n\r\n            var has = 'hasOwnProperty',\r\n              Str = String,\r\n              toFloat = parseFloat,\r\n              toInt = parseInt,\r\n              math = Math,\r\n              mmax = math.max,\r\n              abs = math.abs,\r\n              pow = math.pow,\r\n              separator = /[, ]+/,\r\n              eve = R.eve,\r\n              E = '',\r\n              S = ' ';\r\n            var xlink = 'http://www.w3.org/1999/xlink',\r\n              markers = {\r\n                block: 'M5,0 0,2.5 5,5z',\r\n                classic: 'M5,0 0,2.5 5,5 3.5,3 3.5,2z',\r\n                diamond: 'M2.5,0 5,2.5 2.5,5 0,2.5z',\r\n                open: 'M6,1 1,3.5 6,6',\r\n                oval: 'M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z',\r\n              },\r\n              markerCounter = {};\r\n            R.toString = function () {\r\n              return (\r\n                'Your browser supports SVG.\\nYou are running Rapha\\xebl ' +\r\n                this.version\r\n              );\r\n            };\r\n            var $ = function (el, attr) {\r\n                if (attr) {\r\n                  if (typeof el == 'string') {\r\n                    el = $(el);\r\n                  }\r\n                  for (var key in attr)\r\n                    if (attr[has](key)) {\r\n                      if (key.substring(0, 6) == 'xlink:') {\r\n                        el.setAttributeNS(\r\n                          xlink,\r\n                          key.substring(6),\r\n                          Str(attr[key])\r\n                        );\r\n                      } else {\r\n                        el.setAttribute(key, Str(attr[key]));\r\n                      }\r\n                    }\r\n                } else {\r\n                  el = R._g.doc.createElementNS(\r\n                    'http://www.w3.org/2000/svg',\r\n                    el\r\n                  );\r\n                  el.style &&\r\n                    (el.style.webkitTapHighlightColor = 'rgba(0,0,0,0)');\r\n                }\r\n                return el;\r\n              },\r\n              addGradientFill = function (element, gradient) {\r\n                var type = 'linear',\r\n                  id = element.id + gradient,\r\n                  fx = 0.5,\r\n                  fy = 0.5,\r\n                  o = element.node,\r\n                  SVG = element.paper,\r\n                  s = o.style,\r\n                  el = R._g.doc.getElementById(id);\r\n                if (!el) {\r\n                  gradient = Str(gradient).replace(\r\n                    R._radial_gradient,\r\n                    function (all, _fx, _fy) {\r\n                      type = 'radial';\r\n                      if (_fx && _fy) {\r\n                        fx = toFloat(_fx);\r\n                        fy = toFloat(_fy);\r\n                        var dir = (fy > 0.5) * 2 - 1;\r\n                        pow(fx - 0.5, 2) + pow(fy - 0.5, 2) > 0.25 &&\r\n                          (fy =\r\n                            math.sqrt(0.25 - pow(fx - 0.5, 2)) * dir + 0.5) &&\r\n                          fy != 0.5 &&\r\n                          (fy = fy.toFixed(5) - 1e-5 * dir);\r\n                      }\r\n                      return E;\r\n                    }\r\n                  );\r\n                  gradient = gradient.split(/\\s*\\-\\s*/);\r\n                  if (type == 'linear') {\r\n                    var angle = gradient.shift();\r\n                    angle = -toFloat(angle);\r\n                    if (isNaN(angle)) {\r\n                      return null;\r\n                    }\r\n                    var vector = [\r\n                        0,\r\n                        0,\r\n                        math.cos(R.rad(angle)),\r\n                        math.sin(R.rad(angle)),\r\n                      ],\r\n                      max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);\r\n                    vector[2] *= max;\r\n                    vector[3] *= max;\r\n                    if (vector[2] < 0) {\r\n                      vector[0] = -vector[2];\r\n                      vector[2] = 0;\r\n                    }\r\n                    if (vector[3] < 0) {\r\n                      vector[1] = -vector[3];\r\n                      vector[3] = 0;\r\n                    }\r\n                  }\r\n                  var dots = R._parseDots(gradient);\r\n                  if (!dots) {\r\n                    return null;\r\n                  }\r\n                  id = id.replace(/[\\(\\)\\s,\\xb0#]/g, '_');\r\n\r\n                  if (element.gradient && id != element.gradient.id) {\r\n                    SVG.defs.removeChild(element.gradient);\r\n                    delete element.gradient;\r\n                  }\r\n\r\n                  if (!element.gradient) {\r\n                    el = $(type + 'Gradient', { id: id });\r\n                    element.gradient = el;\r\n                    $(\r\n                      el,\r\n                      type == 'radial'\r\n                        ? {\r\n                            fx: fx,\r\n                            fy: fy,\r\n                          }\r\n                        : {\r\n                            x1: vector[0],\r\n                            y1: vector[1],\r\n                            x2: vector[2],\r\n                            y2: vector[3],\r\n                            gradientTransform: element.matrix.invert(),\r\n                          }\r\n                    );\r\n                    SVG.defs.appendChild(el);\r\n                    for (var i = 0, ii = dots.length; i < ii; i++) {\r\n                      el.appendChild(\r\n                        $('stop', {\r\n                          offset: dots[i].offset\r\n                            ? dots[i].offset\r\n                            : i\r\n                            ? '100%'\r\n                            : '0%',\r\n                          'stop-color': dots[i].color || '#fff',\r\n                          'stop-opacity': isFinite(dots[i].opacity)\r\n                            ? dots[i].opacity\r\n                            : 1,\r\n                        })\r\n                      );\r\n                    }\r\n                  }\r\n                }\r\n                $(o, {\r\n                  fill: fillurl(id),\r\n                  opacity: 1,\r\n                  'fill-opacity': 1,\r\n                });\r\n                s.fill = E;\r\n                s.opacity = 1;\r\n                s.fillOpacity = 1;\r\n                return 1;\r\n              },\r\n              isIE9or10 = function () {\r\n                var mode = document.documentMode;\r\n                return mode && (mode === 9 || mode === 10);\r\n              },\r\n              fillurl = function (id) {\r\n                if (isIE9or10()) {\r\n                  return \"url('#\" + id + \"')\";\r\n                }\r\n                var location = document.location;\r\n                var locationString =\r\n                  location.protocol +\r\n                  '//' +\r\n                  location.host +\r\n                  location.pathname +\r\n                  location.search;\r\n                return \"url('\" + locationString + '#' + id + \"')\";\r\n              },\r\n              updatePosition = function (o) {\r\n                var bbox = o.getBBox(1);\r\n                $(o.pattern, {\r\n                  patternTransform:\r\n                    o.matrix.invert() +\r\n                    ' translate(' +\r\n                    bbox.x +\r\n                    ',' +\r\n                    bbox.y +\r\n                    ')',\r\n                });\r\n              },\r\n              addArrow = function (o, value, isEnd) {\r\n                if (o.type == 'path') {\r\n                  var values = Str(value).toLowerCase().split('-'),\r\n                    p = o.paper,\r\n                    se = isEnd ? 'end' : 'start',\r\n                    node = o.node,\r\n                    attrs = o.attrs,\r\n                    stroke = attrs['stroke-width'],\r\n                    i = values.length,\r\n                    type = 'classic',\r\n                    from,\r\n                    to,\r\n                    dx,\r\n                    refX,\r\n                    attr,\r\n                    w = 3,\r\n                    h = 3,\r\n                    t = 5;\r\n                  while (i--) {\r\n                    switch (values[i]) {\r\n                      case 'block':\r\n                      case 'classic':\r\n                      case 'oval':\r\n                      case 'diamond':\r\n                      case 'open':\r\n                      case 'none':\r\n                        type = values[i];\r\n                        break;\r\n                      case 'wide':\r\n                        h = 5;\r\n                        break;\r\n                      case 'narrow':\r\n                        h = 2;\r\n                        break;\r\n                      case 'long':\r\n                        w = 5;\r\n                        break;\r\n                      case 'short':\r\n                        w = 2;\r\n                        break;\r\n                    }\r\n                  }\r\n                  if (type == 'open') {\r\n                    w += 2;\r\n                    h += 2;\r\n                    t += 2;\r\n                    dx = 1;\r\n                    refX = isEnd ? 4 : 1;\r\n                    attr = {\r\n                      fill: 'none',\r\n                      stroke: attrs.stroke,\r\n                    };\r\n                  } else {\r\n                    refX = dx = w / 2;\r\n                    attr = {\r\n                      fill: attrs.stroke,\r\n                      stroke: 'none',\r\n                    };\r\n                  }\r\n                  if (o._.arrows) {\r\n                    if (isEnd) {\r\n                      o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;\r\n                      o._.arrows.endMarker &&\r\n                        markerCounter[o._.arrows.endMarker]--;\r\n                    } else {\r\n                      o._.arrows.startPath &&\r\n                        markerCounter[o._.arrows.startPath]--;\r\n                      o._.arrows.startMarker &&\r\n                        markerCounter[o._.arrows.startMarker]--;\r\n                    }\r\n                  } else {\r\n                    o._.arrows = {};\r\n                  }\r\n                  if (type != 'none') {\r\n                    var pathId = 'raphael-marker-' + type,\r\n                      markerId =\r\n                        'raphael-marker-' + se + type + w + h + '-obj' + o.id;\r\n                    if (!R._g.doc.getElementById(pathId)) {\r\n                      p.defs.appendChild(\r\n                        $($('path'), {\r\n                          'stroke-linecap': 'round',\r\n                          d: markers[type],\r\n                          id: pathId,\r\n                        })\r\n                      );\r\n                      markerCounter[pathId] = 1;\r\n                    } else {\r\n                      markerCounter[pathId]++;\r\n                    }\r\n                    var marker = R._g.doc.getElementById(markerId),\r\n                      use;\r\n                    if (!marker) {\r\n                      marker = $($('marker'), {\r\n                        id: markerId,\r\n                        markerHeight: h,\r\n                        markerWidth: w,\r\n                        orient: 'auto',\r\n                        refX: refX,\r\n                        refY: h / 2,\r\n                      });\r\n                      use = $($('use'), {\r\n                        'xlink:href': '#' + pathId,\r\n                        transform:\r\n                          (isEnd\r\n                            ? 'rotate(180 ' + w / 2 + ' ' + h / 2 + ') '\r\n                            : E) +\r\n                          'scale(' +\r\n                          w / t +\r\n                          ',' +\r\n                          h / t +\r\n                          ')',\r\n                        'stroke-width': (1 / ((w / t + h / t) / 2)).toFixed(4),\r\n                      });\r\n                      marker.appendChild(use);\r\n                      p.defs.appendChild(marker);\r\n                      markerCounter[markerId] = 1;\r\n                    } else {\r\n                      markerCounter[markerId]++;\r\n                      use = marker.getElementsByTagName('use')[0];\r\n                    }\r\n                    $(use, attr);\r\n                    var delta = dx * (type != 'diamond' && type != 'oval');\r\n                    if (isEnd) {\r\n                      from = o._.arrows.startdx * stroke || 0;\r\n                      to = R.getTotalLength(attrs.path) - delta * stroke;\r\n                    } else {\r\n                      from = delta * stroke;\r\n                      to =\r\n                        R.getTotalLength(attrs.path) -\r\n                        (o._.arrows.enddx * stroke || 0);\r\n                    }\r\n                    attr = {};\r\n                    attr['marker-' + se] = 'url(#' + markerId + ')';\r\n                    if (to || from) {\r\n                      attr.d = R.getSubpath(attrs.path, from, to);\r\n                    }\r\n                    $(node, attr);\r\n                    o._.arrows[se + 'Path'] = pathId;\r\n                    o._.arrows[se + 'Marker'] = markerId;\r\n                    o._.arrows[se + 'dx'] = delta;\r\n                    o._.arrows[se + 'Type'] = type;\r\n                    o._.arrows[se + 'String'] = value;\r\n                  } else {\r\n                    if (isEnd) {\r\n                      from = o._.arrows.startdx * stroke || 0;\r\n                      to = R.getTotalLength(attrs.path) - from;\r\n                    } else {\r\n                      from = 0;\r\n                      to =\r\n                        R.getTotalLength(attrs.path) -\r\n                        (o._.arrows.enddx * stroke || 0);\r\n                    }\r\n                    o._.arrows[se + 'Path'] &&\r\n                      $(node, { d: R.getSubpath(attrs.path, from, to) });\r\n                    delete o._.arrows[se + 'Path'];\r\n                    delete o._.arrows[se + 'Marker'];\r\n                    delete o._.arrows[se + 'dx'];\r\n                    delete o._.arrows[se + 'Type'];\r\n                    delete o._.arrows[se + 'String'];\r\n                  }\r\n                  for (attr in markerCounter)\r\n                    if (markerCounter[has](attr) && !markerCounter[attr]) {\r\n                      var item = R._g.doc.getElementById(attr);\r\n                      item && item.parentNode.removeChild(item);\r\n                    }\r\n                }\r\n              },\r\n              dasharray = {\r\n                '-': [3, 1],\r\n                '.': [1, 1],\r\n                '-.': [3, 1, 1, 1],\r\n                '-..': [3, 1, 1, 1, 1, 1],\r\n                '. ': [1, 3],\r\n                '- ': [4, 3],\r\n                '--': [8, 3],\r\n                '- .': [4, 3, 1, 3],\r\n                '--.': [8, 3, 1, 3],\r\n                '--..': [8, 3, 1, 3, 1, 3],\r\n              },\r\n              addDashes = function (o, value, params) {\r\n                value = dasharray[Str(value).toLowerCase()];\r\n                if (value) {\r\n                  var width = o.attrs['stroke-width'] || '1',\r\n                    butt =\r\n                      { round: width, square: width, butt: 0 }[\r\n                        o.attrs['stroke-linecap'] || params['stroke-linecap']\r\n                      ] || 0,\r\n                    dashes = [],\r\n                    i = value.length;\r\n                  while (i--) {\r\n                    dashes[i] = value[i] * width + (i % 2 ? 1 : -1) * butt;\r\n                  }\r\n                  $(o.node, { 'stroke-dasharray': dashes.join(',') });\r\n                } else {\r\n                  $(o.node, { 'stroke-dasharray': 'none' });\r\n                }\r\n              },\r\n              setFillAndStroke = function (o, params) {\r\n                var node = o.node,\r\n                  attrs = o.attrs,\r\n                  vis = node.style.visibility;\r\n                node.style.visibility = 'hidden';\r\n                for (var att in params) {\r\n                  if (params[has](att)) {\r\n                    if (!R._availableAttrs[has](att)) {\r\n                      continue;\r\n                    }\r\n                    var value = params[att];\r\n                    attrs[att] = value;\r\n                    switch (att) {\r\n                      case 'blur':\r\n                        o.blur(value);\r\n                        break;\r\n                      case 'title':\r\n                        var title = node.getElementsByTagName('title');\r\n\r\n                        // Use the existing <title>.\r\n                        if (title.length && (title = title[0])) {\r\n                          title.firstChild.nodeValue = value;\r\n                        } else {\r\n                          title = $('title');\r\n                          var val = R._g.doc.createTextNode(value);\r\n                          title.appendChild(val);\r\n                          node.appendChild(title);\r\n                        }\r\n                        break;\r\n                      case 'href':\r\n                      case 'target':\r\n                        var pn = node.parentNode;\r\n                        if (pn.tagName.toLowerCase() != 'a') {\r\n                          var hl = $('a');\r\n                          pn.insertBefore(hl, node);\r\n                          hl.appendChild(node);\r\n                          pn = hl;\r\n                        }\r\n                        if (att == 'target') {\r\n                          pn.setAttributeNS(\r\n                            xlink,\r\n                            'show',\r\n                            value == 'blank' ? 'new' : value\r\n                          );\r\n                        } else {\r\n                          pn.setAttributeNS(xlink, att, value);\r\n                        }\r\n                        break;\r\n                      case 'cursor':\r\n                        node.style.cursor = value;\r\n                        break;\r\n                      case 'transform':\r\n                        o.transform(value);\r\n                        break;\r\n                      case 'arrow-start':\r\n                        addArrow(o, value);\r\n                        break;\r\n                      case 'arrow-end':\r\n                        addArrow(o, value, 1);\r\n                        break;\r\n                      case 'clip-rect':\r\n                        var rect = Str(value).split(separator);\r\n                        if (rect.length == 4) {\r\n                          o.clip &&\r\n                            o.clip.parentNode.parentNode.removeChild(\r\n                              o.clip.parentNode\r\n                            );\r\n                          var el = $('clipPath'),\r\n                            rc = $('rect');\r\n                          el.id = R.createUUID();\r\n                          $(rc, {\r\n                            x: rect[0],\r\n                            y: rect[1],\r\n                            width: rect[2],\r\n                            height: rect[3],\r\n                          });\r\n                          el.appendChild(rc);\r\n                          o.paper.defs.appendChild(el);\r\n                          $(node, { 'clip-path': 'url(#' + el.id + ')' });\r\n                          o.clip = rc;\r\n                        }\r\n                        if (!value) {\r\n                          var path = node.getAttribute('clip-path');\r\n                          if (path) {\r\n                            var clip = R._g.doc.getElementById(\r\n                              path.replace(/(^url\\(#|\\)$)/g, E)\r\n                            );\r\n                            clip && clip.parentNode.removeChild(clip);\r\n                            $(node, { 'clip-path': E });\r\n                            delete o.clip;\r\n                          }\r\n                        }\r\n                        break;\r\n                      case 'path':\r\n                        if (o.type == 'path') {\r\n                          $(node, {\r\n                            d: value\r\n                              ? (attrs.path = R._pathToAbsolute(value))\r\n                              : 'M0,0',\r\n                          });\r\n                          o._.dirty = 1;\r\n                          if (o._.arrows) {\r\n                            'startString' in o._.arrows &&\r\n                              addArrow(o, o._.arrows.startString);\r\n                            'endString' in o._.arrows &&\r\n                              addArrow(o, o._.arrows.endString, 1);\r\n                          }\r\n                        }\r\n                        break;\r\n                      case 'width':\r\n                        node.setAttribute(att, value);\r\n                        o._.dirty = 1;\r\n                        if (attrs.fx) {\r\n                          att = 'x';\r\n                          value = attrs.x;\r\n                        } else {\r\n                          break;\r\n                        }\r\n                      case 'x':\r\n                        if (attrs.fx) {\r\n                          value = -attrs.x - (attrs.width || 0);\r\n                        }\r\n                      case 'rx':\r\n                        if (att == 'rx' && o.type == 'rect') {\r\n                          break;\r\n                        }\r\n                      case 'cx':\r\n                        node.setAttribute(att, value);\r\n                        o.pattern && updatePosition(o);\r\n                        o._.dirty = 1;\r\n                        break;\r\n                      case 'height':\r\n                        node.setAttribute(att, value);\r\n                        o._.dirty = 1;\r\n                        if (attrs.fy) {\r\n                          att = 'y';\r\n                          value = attrs.y;\r\n                        } else {\r\n                          break;\r\n                        }\r\n                      case 'y':\r\n                        if (attrs.fy) {\r\n                          value = -attrs.y - (attrs.height || 0);\r\n                        }\r\n                      case 'ry':\r\n                        if (att == 'ry' && o.type == 'rect') {\r\n                          break;\r\n                        }\r\n                      case 'cy':\r\n                        node.setAttribute(att, value);\r\n                        o.pattern && updatePosition(o);\r\n                        o._.dirty = 1;\r\n                        break;\r\n                      case 'r':\r\n                        if (o.type == 'rect') {\r\n                          $(node, { rx: value, ry: value });\r\n                        } else {\r\n                          node.setAttribute(att, value);\r\n                        }\r\n                        o._.dirty = 1;\r\n                        break;\r\n                      case 'src':\r\n                        if (o.type == 'image') {\r\n                          node.setAttributeNS(xlink, 'href', value);\r\n                        }\r\n                        break;\r\n                      case 'stroke-width':\r\n                        if (o._.sx != 1 || o._.sy != 1) {\r\n                          value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;\r\n                        }\r\n                        node.setAttribute(att, value);\r\n                        if (attrs['stroke-dasharray']) {\r\n                          addDashes(o, attrs['stroke-dasharray'], params);\r\n                        }\r\n                        if (o._.arrows) {\r\n                          'startString' in o._.arrows &&\r\n                            addArrow(o, o._.arrows.startString);\r\n                          'endString' in o._.arrows &&\r\n                            addArrow(o, o._.arrows.endString, 1);\r\n                        }\r\n                        break;\r\n                      case 'stroke-dasharray':\r\n                        addDashes(o, value, params);\r\n                        break;\r\n                      case 'fill':\r\n                        var isURL = Str(value).match(R._ISURL);\r\n                        if (isURL) {\r\n                          el = $('pattern');\r\n                          var ig = $('image');\r\n                          el.id = R.createUUID();\r\n                          $(el, {\r\n                            x: 0,\r\n                            y: 0,\r\n                            patternUnits: 'userSpaceOnUse',\r\n                            height: 1,\r\n                            width: 1,\r\n                          });\r\n                          $(ig, { x: 0, y: 0, 'xlink:href': isURL[1] });\r\n                          el.appendChild(ig);\r\n\r\n                          (function (el) {\r\n                            R._preload(isURL[1], function () {\r\n                              var w = this.offsetWidth,\r\n                                h = this.offsetHeight;\r\n                              $(el, { width: w, height: h });\r\n                              $(ig, { width: w, height: h });\r\n                            });\r\n                          })(el);\r\n                          o.paper.defs.appendChild(el);\r\n                          $(node, { fill: 'url(#' + el.id + ')' });\r\n                          o.pattern = el;\r\n                          o.pattern && updatePosition(o);\r\n                          break;\r\n                        }\r\n                        var clr = R.getRGB(value);\r\n                        if (!clr.error) {\r\n                          delete params.gradient;\r\n                          delete attrs.gradient;\r\n                          !R.is(attrs.opacity, 'undefined') &&\r\n                            R.is(params.opacity, 'undefined') &&\r\n                            $(node, { opacity: attrs.opacity });\r\n                          !R.is(attrs['fill-opacity'], 'undefined') &&\r\n                            R.is(params['fill-opacity'], 'undefined') &&\r\n                            $(node, { 'fill-opacity': attrs['fill-opacity'] });\r\n                        } else if (\r\n                          (o.type == 'circle' ||\r\n                            o.type == 'ellipse' ||\r\n                            Str(value).charAt() != 'r') &&\r\n                          addGradientFill(o, value)\r\n                        ) {\r\n                          if ('opacity' in attrs || 'fill-opacity' in attrs) {\r\n                            var gradient = R._g.doc.getElementById(\r\n                              node\r\n                                .getAttribute('fill')\r\n                                .replace(/^url\\(#|\\)$/g, E)\r\n                            );\r\n                            if (gradient) {\r\n                              var stops = gradient.getElementsByTagName('stop');\r\n                              $(stops[stops.length - 1], {\r\n                                'stop-opacity':\r\n                                  ('opacity' in attrs ? attrs.opacity : 1) *\r\n                                  ('fill-opacity' in attrs\r\n                                    ? attrs['fill-opacity']\r\n                                    : 1),\r\n                              });\r\n                            }\r\n                          }\r\n                          attrs.gradient = value;\r\n                          attrs.fill = 'none';\r\n                          break;\r\n                        }\r\n                        clr[has]('opacity') &&\r\n                          $(node, {\r\n                            'fill-opacity':\r\n                              clr.opacity > 1 ? clr.opacity / 100 : clr.opacity,\r\n                          });\r\n                      case 'stroke':\r\n                        clr = R.getRGB(value);\r\n                        node.setAttribute(att, clr.hex);\r\n                        att == 'stroke' &&\r\n                          clr[has]('opacity') &&\r\n                          $(node, {\r\n                            'stroke-opacity':\r\n                              clr.opacity > 1 ? clr.opacity / 100 : clr.opacity,\r\n                          });\r\n                        if (att == 'stroke' && o._.arrows) {\r\n                          'startString' in o._.arrows &&\r\n                            addArrow(o, o._.arrows.startString);\r\n                          'endString' in o._.arrows &&\r\n                            addArrow(o, o._.arrows.endString, 1);\r\n                        }\r\n                        break;\r\n                      case 'gradient':\r\n                        (o.type == 'circle' ||\r\n                          o.type == 'ellipse' ||\r\n                          Str(value).charAt() != 'r') &&\r\n                          addGradientFill(o, value);\r\n                        break;\r\n                      case 'opacity':\r\n                        if (attrs.gradient && !attrs[has]('stroke-opacity')) {\r\n                          $(node, {\r\n                            'stroke-opacity': value > 1 ? value / 100 : value,\r\n                          });\r\n                        }\r\n                      // fall\r\n                      case 'fill-opacity':\r\n                        if (attrs.gradient) {\r\n                          gradient = R._g.doc.getElementById(\r\n                            node.getAttribute('fill').replace(/^url\\(#|\\)$/g, E)\r\n                          );\r\n                          if (gradient) {\r\n                            stops = gradient.getElementsByTagName('stop');\r\n                            $(stops[stops.length - 1], {\r\n                              'stop-opacity': value,\r\n                            });\r\n                          }\r\n                          break;\r\n                        }\r\n                      default:\r\n                        att == 'font-size' && (value = toInt(value, 10) + 'px');\r\n                        var cssrule = att.replace(/(\\-.)/g, function (w) {\r\n                          return w.substring(1).toUpperCase();\r\n                        });\r\n                        node.style[cssrule] = value;\r\n                        o._.dirty = 1;\r\n                        node.setAttribute(att, value);\r\n                        break;\r\n                    }\r\n                  }\r\n                }\r\n\r\n                tuneText(o, params);\r\n                node.style.visibility = vis;\r\n              },\r\n              leading = 1.2,\r\n              tuneText = function (el, params) {\r\n                if (\r\n                  el.type != 'text' ||\r\n                  !(\r\n                    params[has]('text') ||\r\n                    params[has]('font') ||\r\n                    params[has]('font-size') ||\r\n                    params[has]('x') ||\r\n                    params[has]('y')\r\n                  )\r\n                ) {\r\n                  return;\r\n                }\r\n                var a = el.attrs,\r\n                  node = el.node,\r\n                  fontSize = node.firstChild\r\n                    ? toInt(\r\n                        R._g.doc.defaultView\r\n                          .getComputedStyle(node.firstChild, E)\r\n                          .getPropertyValue('font-size'),\r\n                        10\r\n                      )\r\n                    : 10;\r\n\r\n                if (params[has]('text')) {\r\n                  a.text = params.text;\r\n                  while (node.firstChild) {\r\n                    node.removeChild(node.firstChild);\r\n                  }\r\n                  var texts = Str(params.text).split('\\n'),\r\n                    tspans = [],\r\n                    tspan;\r\n                  for (var i = 0, ii = texts.length; i < ii; i++) {\r\n                    tspan = $('tspan');\r\n                    i && $(tspan, { dy: fontSize * leading, x: a.x });\r\n                    tspan.appendChild(R._g.doc.createTextNode(texts[i]));\r\n                    node.appendChild(tspan);\r\n                    tspans[i] = tspan;\r\n                  }\r\n                } else {\r\n                  tspans = node.getElementsByTagName('tspan');\r\n                  for (i = 0, ii = tspans.length; i < ii; i++)\r\n                    if (i) {\r\n                      $(tspans[i], { dy: fontSize * leading, x: a.x });\r\n                    } else {\r\n                      $(tspans[0], { dy: 0 });\r\n                    }\r\n                }\r\n                $(node, { x: a.x, y: a.y });\r\n                el._.dirty = 1;\r\n                var bb = el._getBBox(),\r\n                  dif = a.y - (bb.y + bb.height / 2);\r\n                dif && R.is(dif, 'finite') && $(tspans[0], { dy: dif });\r\n              },\r\n              getRealNode = function (node) {\r\n                if (\r\n                  node.parentNode &&\r\n                  node.parentNode.tagName.toLowerCase() === 'a'\r\n                ) {\r\n                  return node.parentNode;\r\n                } else {\r\n                  return node;\r\n                }\r\n              },\r\n              Element = function (node, svg) {\r\n                var X = 0,\r\n                  Y = 0;\r\n                /*\\\r\n         * Element.node\r\n         [ property (object) ]\r\n         **\r\n         * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.\r\n         **\r\n         * Note: Don’t mess with it.\r\n         > Usage\r\n         | // draw a circle at coordinate 10,10 with radius of 10\r\n         | var c = paper.circle(10, 10, 10);\r\n         | c.node.onclick = function () {\r\n         |     c.attr(\"fill\", \"red\");\r\n         | };\r\n        \\*/\r\n                this[0] = this.node = node;\r\n                /*\\\r\n         * Element.raphael\r\n         [ property (object) ]\r\n         **\r\n         * Internal reference to @Raphael object. In case it is not available.\r\n         > Usage\r\n         | Raphael.el.red = function () {\r\n         |     var hsb = this.paper.raphael.rgb2hsb(this.attr(\"fill\"));\r\n         |     hsb.h = 1;\r\n         |     this.attr({fill: this.paper.raphael.hsb2rgb(hsb).hex});\r\n         | }\r\n        \\*/\r\n                node.raphael = true;\r\n                /*\\\r\n         * Element.id\r\n         [ property (number) ]\r\n         **\r\n         * Unique id of the element. Especially useful when you want to listen to events of the element,\r\n         * because all events are fired in format `<module>.<action>.<id>`. Also useful for @Paper.getById method.\r\n        \\*/\r\n                this.id = guid();\r\n                node.raphaelid = this.id;\r\n\r\n                /**\r\n                 * Method that returns a 5 letter/digit id, enough for 36^5 = 60466176 elements\r\n                 * @returns {string} id\r\n                 */\r\n                function guid() {\r\n                  return (\r\n                    '0000' +\r\n                    ((Math.random() * Math.pow(36, 5)) << 0).toString(36)\r\n                  ).slice(-5);\r\n                }\r\n\r\n                this.matrix = R.matrix();\r\n                this.realPath = null;\r\n                /*\\\r\n         * Element.paper\r\n         [ property (object) ]\r\n         **\r\n         * Internal reference to “paper” where object drawn. Mainly for use in plugins and element extensions.\r\n         > Usage\r\n         | Raphael.el.cross = function () {\r\n         |     this.attr({fill: \"red\"});\r\n         |     this.paper.path(\"M10,10L50,50M50,10L10,50\")\r\n         |         .attr({stroke: \"red\"});\r\n         | }\r\n        \\*/\r\n                this.paper = svg;\r\n                this.attrs = this.attrs || {};\r\n                this._ = {\r\n                  transform: [],\r\n                  sx: 1,\r\n                  sy: 1,\r\n                  deg: 0,\r\n                  dx: 0,\r\n                  dy: 0,\r\n                  dirty: 1,\r\n                };\r\n                !svg.bottom && (svg.bottom = this);\r\n                /*\\\r\n         * Element.prev\r\n         [ property (object) ]\r\n         **\r\n         * Reference to the previous element in the hierarchy.\r\n        \\*/\r\n                this.prev = svg.top;\r\n                svg.top && (svg.top.next = this);\r\n                svg.top = this;\r\n                /*\\\r\n         * Element.next\r\n         [ property (object) ]\r\n         **\r\n         * Reference to the next element in the hierarchy.\r\n        \\*/\r\n                this.next = null;\r\n              },\r\n              elproto = R.el;\r\n\r\n            Element.prototype = elproto;\r\n            elproto.constructor = Element;\r\n\r\n            R._engine.path = function (pathString, SVG) {\r\n              var el = $('path');\r\n              SVG.canvas && SVG.canvas.appendChild(el);\r\n              var p = new Element(el, SVG);\r\n              p.type = 'path';\r\n              setFillAndStroke(p, {\r\n                fill: 'none',\r\n                stroke: '#000',\r\n                path: pathString,\r\n              });\r\n              return p;\r\n            };\r\n            /*\\\r\n     * Element.rotate\r\n     [ method ]\r\n     **\r\n     * Deprecated! Use @Element.transform instead.\r\n     * Adds rotation by given angle around given point to the list of\r\n     * transformations of the element.\r\n     > Parameters\r\n     - deg (number) angle in degrees\r\n     - cx (number) #optional x coordinate of the centre of rotation\r\n     - cy (number) #optional y coordinate of the centre of rotation\r\n     * If cx & cy aren’t specified centre of the shape is used as a point of rotation.\r\n     = (object) @Element\r\n    \\*/\r\n            elproto.rotate = function (deg, cx, cy) {\r\n              if (this.removed) {\r\n                return this;\r\n              }\r\n              deg = Str(deg).split(separator);\r\n              if (deg.length - 1) {\r\n                cx = toFloat(deg[1]);\r\n                cy = toFloat(deg[2]);\r\n              }\r\n              deg = toFloat(deg[0]);\r\n              cy == null && (cx = cy);\r\n              if (cx == null || cy == null) {\r\n                var bbox = this.getBBox(1);\r\n                cx = bbox.x + bbox.width / 2;\r\n                cy = bbox.y + bbox.height / 2;\r\n              }\r\n              this.transform(this._.transform.concat([['r', deg, cx, cy]]));\r\n              return this;\r\n            };\r\n            /*\\\r\n     * Element.scale\r\n     [ method ]\r\n     **\r\n     * Deprecated! Use @Element.transform instead.\r\n     * Adds scale by given amount relative to given point to the list of\r\n     * transformations of the element.\r\n     > Parameters\r\n     - sx (number) horizontal scale amount\r\n     - sy (number) vertical scale amount\r\n     - cx (number) #optional x coordinate of the centre of scale\r\n     - cy (number) #optional y coordinate of the centre of scale\r\n     * If cx & cy aren’t specified centre of the shape is used instead.\r\n     = (object) @Element\r\n    \\*/\r\n            elproto.scale = function (sx, sy, cx, cy) {\r\n              if (this.removed) {\r\n                return this;\r\n              }\r\n              sx = Str(sx).split(separator);\r\n              if (sx.length - 1) {\r\n                sy = toFloat(sx[1]);\r\n                cx = toFloat(sx[2]);\r\n                cy = toFloat(sx[3]);\r\n              }\r\n              sx = toFloat(sx[0]);\r\n              sy == null && (sy = sx);\r\n              cy == null && (cx = cy);\r\n              if (cx == null || cy == null) {\r\n                var bbox = this.getBBox(1);\r\n              }\r\n              cx = cx == null ? bbox.x + bbox.width / 2 : cx;\r\n              cy = cy == null ? bbox.y + bbox.height / 2 : cy;\r\n              this.transform(this._.transform.concat([['s', sx, sy, cx, cy]]));\r\n              return this;\r\n            };\r\n            /*\\\r\n     * Element.translate\r\n     [ method ]\r\n     **\r\n     * Deprecated! Use @Element.transform instead.\r\n     * Adds translation by given amount to the list of transformations of the element.\r\n     > Parameters\r\n     - dx (number) horizontal shift\r\n     - dy (number) vertical shift\r\n     = (object) @Element\r\n    \\*/\r\n            elproto.translate = function (dx, dy) {\r\n              if (this.removed) {\r\n                return this;\r\n              }\r\n              dx = Str(dx).split(separator);\r\n              if (dx.length - 1) {\r\n                dy = toFloat(dx[1]);\r\n              }\r\n              dx = toFloat(dx[0]) || 0;\r\n              dy = +dy || 0;\r\n              this.transform(this._.transform.concat([['t', dx, dy]]));\r\n              return this;\r\n            };\r\n            /*\\\r\n     * Element.transform\r\n     [ method ]\r\n     **\r\n     * Adds transformation to the element which is separate to other attributes,\r\n     * i.e. translation doesn’t change `x` or `y` of the rectange. The format\r\n     * of transformation string is similar to the path string syntax:\r\n     | \"t100,100r30,100,100s2,2,100,100r45s1.5\"\r\n     * Each letter is a command. There are four commands: `t` is for translate, `r` is for rotate, `s` is for\r\n     * scale and `m` is for matrix.\r\n     *\r\n     * There are also alternative “absolute” translation, rotation and scale: `T`, `R` and `S`. They will not take previous transformation into account. For example, `...T100,0` will always move element 100 px horisontally, while `...t100,0` could move it vertically if there is `r90` before. Just compare results of `r90t100,0` and `r90T100,0`.\r\n     *\r\n     * So, the example line above could be read like “translate by 100, 100; rotate 30° around 100, 100; scale twice around 100, 100;\r\n     * rotate 45° around centre; scale 1.5 times relative to centre”. As you can see rotate and scale commands have origin\r\n     * coordinates as optional parameters, the default is the centre point of the element.\r\n     * Matrix accepts six parameters.\r\n     > Usage\r\n     | var el = paper.rect(10, 20, 300, 200);\r\n     | // translate 100, 100, rotate 45°, translate -100, 0\r\n     | el.transform(\"t100,100r45t-100,0\");\r\n     | // if you want you can append or prepend transformations\r\n     | el.transform(\"...t50,50\");\r\n     | el.transform(\"s2...\");\r\n     | // or even wrap\r\n     | el.transform(\"t50,50...t-50-50\");\r\n     | // to reset transformation call method with empty string\r\n     | el.transform(\"\");\r\n     | // to get current value call it without parameters\r\n     | console.log(el.transform());\r\n     > Parameters\r\n     - tstr (string) #optional transformation string\r\n     * If tstr isn’t specified\r\n     = (string) current transformation string\r\n     * else\r\n     = (object) @Element\r\n    \\*/\r\n            elproto.transform = function (tstr) {\r\n              var _ = this._;\r\n              if (tstr == null) {\r\n                return _.transform;\r\n              }\r\n              R._extractTransform(this, tstr);\r\n\r\n              this.clip && $(this.clip, { transform: this.matrix.invert() });\r\n              this.pattern && updatePosition(this);\r\n              this.node && $(this.node, { transform: this.matrix });\r\n\r\n              if (_.sx != 1 || _.sy != 1) {\r\n                var sw = this.attrs[has]('stroke-width')\r\n                  ? this.attrs['stroke-width']\r\n                  : 1;\r\n                this.attr({ 'stroke-width': sw });\r\n              }\r\n\r\n              return this;\r\n            };\r\n            /*\\\r\n     * Element.hide\r\n     [ method ]\r\n     **\r\n     * Makes element invisible. See @Element.show.\r\n     = (object) @Element\r\n    \\*/\r\n            elproto.hide = function () {\r\n              if (!this.removed) this.node.style.display = 'none';\r\n              return this;\r\n            };\r\n            /*\\\r\n     * Element.show\r\n     [ method ]\r\n     **\r\n     * Makes element visible. See @Element.hide.\r\n     = (object) @Element\r\n    \\*/\r\n            elproto.show = function () {\r\n              if (!this.removed) this.node.style.display = '';\r\n              return this;\r\n            };\r\n            /*\\\r\n     * Element.remove\r\n     [ method ]\r\n     **\r\n     * Removes element from the paper.\r\n    \\*/\r\n            elproto.remove = function () {\r\n              var node = getRealNode(this.node);\r\n              if (this.removed || !node.parentNode) {\r\n                return;\r\n              }\r\n              var paper = this.paper;\r\n              paper.__set__ && paper.__set__.exclude(this);\r\n              eve.unbind('raphael.*.*.' + this.id);\r\n              if (this.gradient) {\r\n                paper.defs.removeChild(this.gradient);\r\n              }\r\n              R._tear(this, paper);\r\n\r\n              node.parentNode.removeChild(node);\r\n\r\n              // Remove custom data for element\r\n              this.removeData();\r\n\r\n              for (var i in this) {\r\n                this[i] =\r\n                  typeof this[i] == 'function' ? R._removedFactory(i) : null;\r\n              }\r\n              this.removed = true;\r\n            };\r\n            elproto._getBBox = function () {\r\n              if (this.node.style.display == 'none') {\r\n                this.show();\r\n                var hide = true;\r\n              }\r\n              var canvasHidden = false,\r\n                containerStyle;\r\n              if (this.paper.canvas.parentElement) {\r\n                containerStyle = this.paper.canvas.parentElement.style;\r\n              } //IE10+ can't find parentElement\r\n              else if (this.paper.canvas.parentNode) {\r\n                containerStyle = this.paper.canvas.parentNode.style;\r\n              }\r\n\r\n              if (containerStyle && containerStyle.display == 'none') {\r\n                canvasHidden = true;\r\n                containerStyle.display = '';\r\n              }\r\n              var bbox = {};\r\n              try {\r\n                bbox = this.node.getBBox();\r\n              } catch (e) {\r\n                // Firefox 3.0.x, 25.0.1 (probably more versions affected) play badly here - possible fix\r\n                bbox = {\r\n                  x: this.node.clientLeft,\r\n                  y: this.node.clientTop,\r\n                  width: this.node.clientWidth,\r\n                  height: this.node.clientHeight,\r\n                };\r\n              } finally {\r\n                bbox = bbox || {};\r\n                if (canvasHidden) {\r\n                  containerStyle.display = 'none';\r\n                }\r\n              }\r\n              hide && this.hide();\r\n              return bbox;\r\n            };\r\n            /*\\\r\n     * Element.attr\r\n     [ method ]\r\n     **\r\n     * Sets the attributes of the element.\r\n     > Parameters\r\n     - attrName (string) attribute’s name\r\n     - value (string) value\r\n     * or\r\n     - params (object) object of name/value pairs\r\n     * or\r\n     - attrName (string) attribute’s name\r\n     * or\r\n     - attrNames (array) in this case method returns array of current values for given attribute names\r\n     = (object) @Element if attrsName & value or params are passed in.\r\n     = (...) value of the attribute if only attrsName is passed in.\r\n     = (array) array of values of the attribute if attrsNames is passed in.\r\n     = (object) object of attributes if nothing is passed in.\r\n     > Possible parameters\r\n     # <p>Please refer to the <a href=\"http://www.w3.org/TR/SVG/\" title=\"The W3C Recommendation for the SVG language describes these properties in detail.\">SVG specification</a> for an explanation of these parameters.</p>\r\n     o arrow-end (string) arrowhead on the end of the path. The format for string is `<type>[-<width>[-<length>]]`. Possible types: `classic`, `block`, `open`, `oval`, `diamond`, `none`, width: `wide`, `narrow`, `medium`, length: `long`, `short`, `midium`.\r\n     o clip-rect (string) comma or space separated values: x, y, width and height\r\n     o cursor (string) CSS type of the cursor\r\n     o cx (number) the x-axis coordinate of the center of the circle, or ellipse\r\n     o cy (number) the y-axis coordinate of the center of the circle, or ellipse\r\n     o fill (string) colour, gradient or image\r\n     o fill-opacity (number)\r\n     o font (string)\r\n     o font-family (string)\r\n     o font-size (number) font size in pixels\r\n     o font-weight (string)\r\n     o height (number)\r\n     o href (string) URL, if specified element behaves as hyperlink\r\n     o opacity (number)\r\n     o path (string) SVG path string format\r\n     o r (number) radius of the circle, ellipse or rounded corner on the rect\r\n     o rx (number) horizontal radius of the ellipse\r\n     o ry (number) vertical radius of the ellipse\r\n     o src (string) image URL, only works for @Element.image element\r\n     o stroke (string) stroke colour\r\n     o stroke-dasharray (string) [“”, “none”, “`-`”, “`.`”, “`-.`”, “`-..`”, “`. `”, “`- `”, “`--`”, “`- .`”, “`--.`”, “`--..`”]\r\n     o stroke-linecap (string) [“`butt`”, “`square`”, “`round`”]\r\n     o stroke-linejoin (string) [“`bevel`”, “`round`”, “`miter`”]\r\n     o stroke-miterlimit (number)\r\n     o stroke-opacity (number)\r\n     o stroke-width (number) stroke width in pixels, default is '1'\r\n     o target (string) used with href\r\n     o text (string) contents of the text element. Use `\\n` for multiline text\r\n     o text-anchor (string) [“`start`”, “`middle`”, “`end`”], default is “`middle`”\r\n     o title (string) will create tooltip with a given text\r\n     o transform (string) see @Element.transform\r\n     o width (number)\r\n     o x (number)\r\n     o y (number)\r\n     > Gradients\r\n     * Linear gradient format: “`‹angle›-‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`90-#fff-#000`” – 90°\r\n     * gradient from white to black or “`0-#fff-#f00:20-#000`” – 0° gradient from white via red (at 20%) to black.\r\n     *\r\n     * radial gradient: “`r[(‹fx›, ‹fy›)]‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`r#fff-#000`” –\r\n     * gradient from white to black or “`r(0.25, 0.75)#fff-#000`” – gradient from white to black with focus point\r\n     * at 0.25, 0.75. Focus point coordinates are in 0..1 range. Radial gradients can only be applied to circles and ellipses.\r\n     > Path String\r\n     # <p>Please refer to <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a path’s data attribute’s format are described in the SVG specification.\">SVG documentation regarding path string</a>. Raphaël fully supports it.</p>\r\n     > Colour Parsing\r\n     # <ul>\r\n     #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>\r\n     #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>\r\n     #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>\r\n     #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>\r\n     #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>\r\n     #     <li>rgba(•••, •••, •••, •••) — red, green and blue channels’ values: (“<code>rgba(200,&nbsp;100,&nbsp;0, .5)</code>”)</li>\r\n     #     <li>rgba(•••%, •••%, •••%, •••%) — same as above, but in %: (“<code>rgba(100%,&nbsp;175%,&nbsp;0%, 50%)</code>”)</li>\r\n     #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>\r\n     #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>\r\n     #     <li>hsba(•••, •••, •••, •••) — same as above, but with opacity</li>\r\n     #     <li>hsl(•••, •••, •••) — almost the same as hsb, see <a href=\"http://en.wikipedia.org/wiki/HSL_and_HSV\" title=\"HSL and HSV - Wikipedia, the free encyclopedia\">Wikipedia page</a></li>\r\n     #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>\r\n     #     <li>hsla(•••, •••, •••, •••) — same as above, but with opacity</li>\r\n     #     <li>Optionally for hsb and hsl you could specify hue as a degree: “<code>hsl(240deg,&nbsp;1,&nbsp;.5)</code>” or, if you want to go fancy, “<code>hsl(240°,&nbsp;1,&nbsp;.5)</code>”</li>\r\n     # </ul>\r\n    \\*/\r\n            elproto.attr = function (name, value) {\r\n              if (this.removed) {\r\n                return this;\r\n              }\r\n              if (name == null) {\r\n                var res = {};\r\n                for (var a in this.attrs)\r\n                  if (this.attrs[has](a)) {\r\n                    res[a] = this.attrs[a];\r\n                  }\r\n                res.gradient &&\r\n                  res.fill == 'none' &&\r\n                  (res.fill = res.gradient) &&\r\n                  delete res.gradient;\r\n                res.transform = this._.transform;\r\n                return res;\r\n              }\r\n              if (value == null && R.is(name, 'string')) {\r\n                if (\r\n                  name == 'fill' &&\r\n                  this.attrs.fill == 'none' &&\r\n                  this.attrs.gradient\r\n                ) {\r\n                  return this.attrs.gradient;\r\n                }\r\n                if (name == 'transform') {\r\n                  return this._.transform;\r\n                }\r\n                var names = name.split(separator),\r\n                  out = {};\r\n                for (var i = 0, ii = names.length; i < ii; i++) {\r\n                  name = names[i];\r\n                  if (name in this.attrs) {\r\n                    out[name] = this.attrs[name];\r\n                  } else if (\r\n                    R.is(this.paper.customAttributes[name], 'function')\r\n                  ) {\r\n                    out[name] = this.paper.customAttributes[name].def;\r\n                  } else {\r\n                    out[name] = R._availableAttrs[name];\r\n                  }\r\n                }\r\n                return ii - 1 ? out : out[names[0]];\r\n              }\r\n              if (value == null && R.is(name, 'array')) {\r\n                out = {};\r\n                for (i = 0, ii = name.length; i < ii; i++) {\r\n                  out[name[i]] = this.attr(name[i]);\r\n                }\r\n                return out;\r\n              }\r\n              if (value != null) {\r\n                var params = {};\r\n                params[name] = value;\r\n              } else if (name != null && R.is(name, 'object')) {\r\n                params = name;\r\n              }\r\n              for (var key in params) {\r\n                eve('raphael.attr.' + key + '.' + this.id, this, params[key]);\r\n              }\r\n              for (key in this.paper.customAttributes)\r\n                if (\r\n                  this.paper.customAttributes[has](key) &&\r\n                  params[has](key) &&\r\n                  R.is(this.paper.customAttributes[key], 'function')\r\n                ) {\r\n                  var par = this.paper.customAttributes[key].apply(\r\n                    this,\r\n                    [].concat(params[key])\r\n                  );\r\n                  this.attrs[key] = params[key];\r\n                  for (var subkey in par)\r\n                    if (par[has](subkey)) {\r\n                      params[subkey] = par[subkey];\r\n                    }\r\n                }\r\n              setFillAndStroke(this, params);\r\n              return this;\r\n            };\r\n            /*\\\r\n     * Element.toFront\r\n     [ method ]\r\n     **\r\n     * Moves the element so it is the closest to the viewer’s eyes, on top of other elements.\r\n     = (object) @Element\r\n    \\*/\r\n            elproto.toFront = function () {\r\n              if (this.removed) {\r\n                return this;\r\n              }\r\n              var node = getRealNode(this.node);\r\n              node.parentNode.appendChild(node);\r\n              var svg = this.paper;\r\n              svg.top != this && R._tofront(this, svg);\r\n              return this;\r\n            };\r\n            /*\\\r\n     * Element.toBack\r\n     [ method ]\r\n     **\r\n     * Moves the element so it is the furthest from the viewer’s eyes, behind other elements.\r\n     = (object) @Element\r\n    \\*/\r\n            elproto.toBack = function () {\r\n              if (this.removed) {\r\n                return this;\r\n              }\r\n              var node = getRealNode(this.node);\r\n              var parentNode = node.parentNode;\r\n              parentNode.insertBefore(node, parentNode.firstChild);\r\n              R._toback(this, this.paper);\r\n              var svg = this.paper;\r\n              return this;\r\n            };\r\n            /*\\\r\n     * Element.insertAfter\r\n     [ method ]\r\n     **\r\n     * Inserts current object after the given one.\r\n     = (object) @Element\r\n    \\*/\r\n            elproto.insertAfter = function (element) {\r\n              if (this.removed || !element) {\r\n                return this;\r\n              }\r\n\r\n              var node = getRealNode(this.node);\r\n              var afterNode = getRealNode(\r\n                element.node || element[element.length - 1].node\r\n              );\r\n              if (afterNode.nextSibling) {\r\n                afterNode.parentNode.insertBefore(node, afterNode.nextSibling);\r\n              } else {\r\n                afterNode.parentNode.appendChild(node);\r\n              }\r\n              R._insertafter(this, element, this.paper);\r\n              return this;\r\n            };\r\n            /*\\\r\n     * Element.insertBefore\r\n     [ method ]\r\n     **\r\n     * Inserts current object before the given one.\r\n     = (object) @Element\r\n    \\*/\r\n            elproto.insertBefore = function (element) {\r\n              if (this.removed || !element) {\r\n                return this;\r\n              }\r\n\r\n              var node = getRealNode(this.node);\r\n              var beforeNode = getRealNode(element.node || element[0].node);\r\n              beforeNode.parentNode.insertBefore(node, beforeNode);\r\n              R._insertbefore(this, element, this.paper);\r\n              return this;\r\n            };\r\n            elproto.blur = function (size) {\r\n              // Experimental. No Safari support. Use it on your own risk.\r\n              var t = this;\r\n              if (+size !== 0) {\r\n                var fltr = $('filter'),\r\n                  blur = $('feGaussianBlur');\r\n                t.attrs.blur = size;\r\n                fltr.id = R.createUUID();\r\n                $(blur, { stdDeviation: +size || 1.5 });\r\n                fltr.appendChild(blur);\r\n                t.paper.defs.appendChild(fltr);\r\n                t._blur = fltr;\r\n                $(t.node, { filter: 'url(#' + fltr.id + ')' });\r\n              } else {\r\n                if (t._blur) {\r\n                  t._blur.parentNode.removeChild(t._blur);\r\n                  delete t._blur;\r\n                  delete t.attrs.blur;\r\n                }\r\n                t.node.removeAttribute('filter');\r\n              }\r\n              return t;\r\n            };\r\n            R._engine.circle = function (svg, x, y, r) {\r\n              var el = $('circle');\r\n              svg.canvas && svg.canvas.appendChild(el);\r\n              var res = new Element(el, svg);\r\n              res.attrs = { cx: x, cy: y, r: r, fill: 'none', stroke: '#000' };\r\n              res.type = 'circle';\r\n              $(el, res.attrs);\r\n              return res;\r\n            };\r\n            R._engine.rect = function (svg, x, y, w, h, r) {\r\n              var el = $('rect');\r\n              svg.canvas && svg.canvas.appendChild(el);\r\n              var res = new Element(el, svg);\r\n              res.attrs = {\r\n                x: x,\r\n                y: y,\r\n                width: w,\r\n                height: h,\r\n                rx: r || 0,\r\n                ry: r || 0,\r\n                fill: 'none',\r\n                stroke: '#000',\r\n              };\r\n              res.type = 'rect';\r\n              $(el, res.attrs);\r\n              return res;\r\n            };\r\n            R._engine.ellipse = function (svg, x, y, rx, ry) {\r\n              var el = $('ellipse');\r\n              svg.canvas && svg.canvas.appendChild(el);\r\n              var res = new Element(el, svg);\r\n              res.attrs = {\r\n                cx: x,\r\n                cy: y,\r\n                rx: rx,\r\n                ry: ry,\r\n                fill: 'none',\r\n                stroke: '#000',\r\n              };\r\n              res.type = 'ellipse';\r\n              $(el, res.attrs);\r\n              return res;\r\n            };\r\n            R._engine.image = function (svg, src, x, y, w, h) {\r\n              var el = $('image');\r\n              $(el, {\r\n                x: x,\r\n                y: y,\r\n                width: w,\r\n                height: h,\r\n                preserveAspectRatio: 'none',\r\n              });\r\n              el.setAttributeNS(xlink, 'href', src);\r\n              svg.canvas && svg.canvas.appendChild(el);\r\n              var res = new Element(el, svg);\r\n              res.attrs = { x: x, y: y, width: w, height: h, src: src };\r\n              res.type = 'image';\r\n              return res;\r\n            };\r\n            R._engine.text = function (svg, x, y, text) {\r\n              var el = $('text');\r\n              svg.canvas && svg.canvas.appendChild(el);\r\n              var res = new Element(el, svg);\r\n              res.attrs = {\r\n                x: x,\r\n                y: y,\r\n                'text-anchor': 'middle',\r\n                text: text,\r\n                'font-family': R._availableAttrs['font-family'],\r\n                'font-size': R._availableAttrs['font-size'],\r\n                stroke: 'none',\r\n                fill: '#000',\r\n              };\r\n              res.type = 'text';\r\n              setFillAndStroke(res, res.attrs);\r\n              return res;\r\n            };\r\n            R._engine.setSize = function (width, height) {\r\n              this.width = width || this.width;\r\n              this.height = height || this.height;\r\n              this.canvas.setAttribute('width', this.width);\r\n              this.canvas.setAttribute('height', this.height);\r\n              if (this._viewBox) {\r\n                this.setViewBox.apply(this, this._viewBox);\r\n              }\r\n              return this;\r\n            };\r\n            R._engine.create = function () {\r\n              var con = R._getContainer.apply(0, arguments),\r\n                container = con && con.container;\r\n              if (!container) {\r\n                throw new Error('SVG container not found.');\r\n              }\r\n              var x = con.x,\r\n                y = con.y,\r\n                width = con.width,\r\n                height = con.height,\r\n                cnvs = $('svg'),\r\n                css = 'overflow:hidden;',\r\n                isFloating;\r\n              x = x || 0;\r\n              y = y || 0;\r\n              width = width || 512;\r\n              height = height || 342;\r\n              $(cnvs, {\r\n                height: height,\r\n                version: 1.1,\r\n                width: width,\r\n                xmlns: 'http://www.w3.org/2000/svg',\r\n                'xmlns:xlink': 'http://www.w3.org/1999/xlink',\r\n              });\r\n              if (container == 1) {\r\n                cnvs.style.cssText =\r\n                  css + 'position:absolute;left:' + x + 'px;top:' + y + 'px';\r\n                R._g.doc.body.appendChild(cnvs);\r\n                isFloating = 1;\r\n              } else {\r\n                cnvs.style.cssText = css + 'position:relative';\r\n                if (container.firstChild) {\r\n                  container.insertBefore(cnvs, container.firstChild);\r\n                } else {\r\n                  container.appendChild(cnvs);\r\n                }\r\n              }\r\n              container = new R._Paper();\r\n              container.width = width;\r\n              container.height = height;\r\n              container.canvas = cnvs;\r\n              container.clear();\r\n              container._left = container._top = 0;\r\n              isFloating && (container.renderfix = function () {});\r\n              container.renderfix();\r\n              return container;\r\n            };\r\n            R._engine.setViewBox = function (x, y, w, h, fit) {\r\n              eve('raphael.setViewBox', this, this._viewBox, [x, y, w, h, fit]);\r\n              var paperSize = this.getSize(),\r\n                size = mmax(w / paperSize.width, h / paperSize.height),\r\n                top = this.top,\r\n                aspectRatio = fit ? 'xMidYMid meet' : 'xMinYMin',\r\n                vb,\r\n                sw;\r\n              if (x == null) {\r\n                if (this._vbSize) {\r\n                  size = 1;\r\n                }\r\n                delete this._vbSize;\r\n                vb = '0 0 ' + this.width + S + this.height;\r\n              } else {\r\n                this._vbSize = size;\r\n                vb = x + S + y + S + w + S + h;\r\n              }\r\n              $(this.canvas, {\r\n                viewBox: vb,\r\n                preserveAspectRatio: aspectRatio,\r\n              });\r\n              while (size && top) {\r\n                sw =\r\n                  'stroke-width' in top.attrs ? top.attrs['stroke-width'] : 1;\r\n                top.attr({ 'stroke-width': sw });\r\n                top._.dirty = 1;\r\n                top._.dirtyT = 1;\r\n                top = top.prev;\r\n              }\r\n              this._viewBox = [x, y, w, h, !!fit];\r\n              return this;\r\n            };\r\n            /*\\\r\n     * Paper.renderfix\r\n     [ method ]\r\n     **\r\n     * Fixes the issue of Firefox and IE9 regarding subpixel rendering. If paper is dependent\r\n     * on other elements after reflow it could shift half pixel which cause for lines to lost their crispness.\r\n     * This method fixes the issue.\r\n     **\r\n       Special thanks to Mariusz Nowak (http://www.medikoo.com/) for this method.\r\n    \\*/\r\n            R.prototype.renderfix = function () {\r\n              var cnvs = this.canvas,\r\n                s = cnvs.style,\r\n                pos;\r\n              try {\r\n                pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();\r\n              } catch (e) {\r\n                pos = cnvs.createSVGMatrix();\r\n              }\r\n              var left = -pos.e % 1,\r\n                top = -pos.f % 1;\r\n              if (left || top) {\r\n                if (left) {\r\n                  this._left = (this._left + left) % 1;\r\n                  s.left = this._left + 'px';\r\n                }\r\n                if (top) {\r\n                  this._top = (this._top + top) % 1;\r\n                  s.top = this._top + 'px';\r\n                }\r\n              }\r\n            };\r\n            /*\\\r\n     * Paper.clear\r\n     [ method ]\r\n     **\r\n     * Clears the paper, i.e. removes all the elements.\r\n    \\*/\r\n            R.prototype.clear = function () {\r\n              R.eve('raphael.clear', this);\r\n              var c = this.canvas;\r\n              while (c.firstChild) {\r\n                c.removeChild(c.firstChild);\r\n              }\r\n              this.bottom = this.top = null;\r\n              (this.desc = $('desc')).appendChild(\r\n                R._g.doc.createTextNode('Created with Rapha\\xebl ' + R.version)\r\n              );\r\n              c.appendChild(this.desc);\r\n              c.appendChild((this.defs = $('defs')));\r\n            };\r\n            /*\\\r\n     * Paper.remove\r\n     [ method ]\r\n     **\r\n     * Removes the paper from the DOM.\r\n    \\*/\r\n            R.prototype.remove = function () {\r\n              eve('raphael.remove', this);\r\n              this.canvas.parentNode &&\r\n                this.canvas.parentNode.removeChild(this.canvas);\r\n              for (var i in this) {\r\n                this[i] =\r\n                  typeof this[i] == 'function' ? R._removedFactory(i) : null;\r\n              }\r\n            };\r\n            var setproto = R.st;\r\n            for (var method in elproto)\r\n              if (elproto[has](method) && !setproto[has](method)) {\r\n                setproto[method] = (function (methodname) {\r\n                  return function () {\r\n                    var arg = arguments;\r\n                    return this.forEach(function (el) {\r\n                      el[methodname].apply(el, arg);\r\n                    });\r\n                  };\r\n                })(method);\r\n              }\r\n          }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)),\r\n          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&\r\n            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n          /***/\r\n        },\r\n\r\n      /***/ './dev/raphael.vml.js':\r\n        /*!****************************!*\\\r\n  !*** ./dev/raphael.vml.js ***!\r\n  \\****************************/\r\n        /*! no static exports found */\r\n        /***/ function (module, exports, __nested_webpack_require_307480__) {\r\n          var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\r\n          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n            __nested_webpack_require_307480__(/*! ./raphael.core */ './dev/raphael.core.js'),\r\n          ]),\r\n          (__WEBPACK_AMD_DEFINE_RESULT__ = function (R) {\r\n            if (R && !R.vml) {\r\n              return;\r\n            }\r\n\r\n            var has = 'hasOwnProperty',\r\n              Str = String,\r\n              toFloat = parseFloat,\r\n              math = Math,\r\n              round = math.round,\r\n              mmax = math.max,\r\n              mmin = math.min,\r\n              abs = math.abs,\r\n              fillString = 'fill',\r\n              separator = /[, ]+/,\r\n              eve = R.eve,\r\n              ms = ' progid:DXImageTransform.Microsoft',\r\n              S = ' ',\r\n              E = '',\r\n              map = {\r\n                M: 'm',\r\n                L: 'l',\r\n                C: 'c',\r\n                Z: 'x',\r\n                m: 't',\r\n                l: 'r',\r\n                c: 'v',\r\n                z: 'x',\r\n              },\r\n              bites = /([clmz]),?([^clmz]*)/gi,\r\n              blurregexp = / progid:\\S+Blur\\([^\\)]+\\)/g,\r\n              val = /-?[^,\\s-]+/g,\r\n              cssDot =\r\n                'position:absolute;left:0;top:0;width:1px;height:1px;behavior:url(#default#VML)',\r\n              zoom = 21600,\r\n              pathTypes = { path: 1, rect: 1, image: 1 },\r\n              ovalTypes = { circle: 1, ellipse: 1 },\r\n              path2vml = function (path) {\r\n                var total = /[ahqstv]/gi,\r\n                  command = R._pathToAbsolute;\r\n                Str(path).match(total) && (command = R._path2curve);\r\n                total = /[clmz]/g;\r\n                if (command == R._pathToAbsolute && !Str(path).match(total)) {\r\n                  var res = Str(path).replace(\r\n                    bites,\r\n                    function (all, command, args) {\r\n                      var vals = [],\r\n                        isMove = command.toLowerCase() == 'm',\r\n                        res = map[command];\r\n                      args.replace(val, function (value) {\r\n                        if (isMove && vals.length == 2) {\r\n                          res += vals + map[command == 'm' ? 'l' : 'L'];\r\n                          vals = [];\r\n                        }\r\n                        vals.push(round(value * zoom));\r\n                      });\r\n                      return res + vals;\r\n                    }\r\n                  );\r\n                  return res;\r\n                }\r\n                var pa = command(path),\r\n                  p,\r\n                  r;\r\n                res = [];\r\n                for (var i = 0, ii = pa.length; i < ii; i++) {\r\n                  p = pa[i];\r\n                  r = pa[i][0].toLowerCase();\r\n                  r == 'z' && (r = 'x');\r\n                  for (var j = 1, jj = p.length; j < jj; j++) {\r\n                    r += round(p[j] * zoom) + (j != jj - 1 ? ',' : E);\r\n                  }\r\n                  res.push(r);\r\n                }\r\n                return res.join(S);\r\n              },\r\n              compensation = function (deg, dx, dy) {\r\n                var m = R.matrix();\r\n                m.rotate(-deg, 0.5, 0.5);\r\n                return {\r\n                  dx: m.x(dx, dy),\r\n                  dy: m.y(dx, dy),\r\n                };\r\n              },\r\n              setCoords = function (p, sx, sy, dx, dy, deg) {\r\n                var _ = p._,\r\n                  m = p.matrix,\r\n                  fillpos = _.fillpos,\r\n                  o = p.node,\r\n                  s = o.style,\r\n                  y = 1,\r\n                  flip = '',\r\n                  dxdy,\r\n                  kx = zoom / sx,\r\n                  ky = zoom / sy;\r\n                s.visibility = 'hidden';\r\n                if (!sx || !sy) {\r\n                  return;\r\n                }\r\n                o.coordsize = abs(kx) + S + abs(ky);\r\n                s.rotation = deg * (sx * sy < 0 ? -1 : 1);\r\n                if (deg) {\r\n                  var c = compensation(deg, dx, dy);\r\n                  dx = c.dx;\r\n                  dy = c.dy;\r\n                }\r\n                sx < 0 && (flip += 'x');\r\n                sy < 0 && (flip += ' y') && (y = -1);\r\n                s.flip = flip;\r\n                o.coordorigin = dx * -kx + S + dy * -ky;\r\n                if (fillpos || _.fillsize) {\r\n                  var fill = o.getElementsByTagName(fillString);\r\n                  fill = fill && fill[0];\r\n                  o.removeChild(fill);\r\n                  if (fillpos) {\r\n                    c = compensation(\r\n                      deg,\r\n                      m.x(fillpos[0], fillpos[1]),\r\n                      m.y(fillpos[0], fillpos[1])\r\n                    );\r\n                    fill.position = c.dx * y + S + c.dy * y;\r\n                  }\r\n                  if (_.fillsize) {\r\n                    fill.size =\r\n                      _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);\r\n                  }\r\n                  o.appendChild(fill);\r\n                }\r\n                s.visibility = 'visible';\r\n              };\r\n            R.toString = function () {\r\n              return (\r\n                'Your browser doesn\\u2019t support SVG. Falling down to VML.\\nYou are running Rapha\\xebl ' +\r\n                this.version\r\n              );\r\n            };\r\n            var addArrow = function (o, value, isEnd) {\r\n                var values = Str(value).toLowerCase().split('-'),\r\n                  se = isEnd ? 'end' : 'start',\r\n                  i = values.length,\r\n                  type = 'classic',\r\n                  w = 'medium',\r\n                  h = 'medium';\r\n                while (i--) {\r\n                  switch (values[i]) {\r\n                    case 'block':\r\n                    case 'classic':\r\n                    case 'oval':\r\n                    case 'diamond':\r\n                    case 'open':\r\n                    case 'none':\r\n                      type = values[i];\r\n                      break;\r\n                    case 'wide':\r\n                    case 'narrow':\r\n                      h = values[i];\r\n                      break;\r\n                    case 'long':\r\n                    case 'short':\r\n                      w = values[i];\r\n                      break;\r\n                  }\r\n                }\r\n                var stroke = o.node.getElementsByTagName('stroke')[0];\r\n                stroke[se + 'arrow'] = type;\r\n                stroke[se + 'arrowlength'] = w;\r\n                stroke[se + 'arrowwidth'] = h;\r\n              },\r\n              setFillAndStroke = function (o, params) {\r\n                // o.paper.canvas.style.display = \"none\";\r\n                o.attrs = o.attrs || {};\r\n                var node = o.node,\r\n                  a = o.attrs,\r\n                  s = node.style,\r\n                  xy,\r\n                  newpath =\r\n                    pathTypes[o.type] &&\r\n                    (params.x != a.x ||\r\n                      params.y != a.y ||\r\n                      params.width != a.width ||\r\n                      params.height != a.height ||\r\n                      params.cx != a.cx ||\r\n                      params.cy != a.cy ||\r\n                      params.rx != a.rx ||\r\n                      params.ry != a.ry ||\r\n                      params.r != a.r),\r\n                  isOval =\r\n                    ovalTypes[o.type] &&\r\n                    (a.cx != params.cx ||\r\n                      a.cy != params.cy ||\r\n                      a.r != params.r ||\r\n                      a.rx != params.rx ||\r\n                      a.ry != params.ry),\r\n                  res = o;\r\n\r\n                for (var par in params)\r\n                  if (params[has](par)) {\r\n                    a[par] = params[par];\r\n                  }\r\n                if (newpath) {\r\n                  a.path = R._getPath[o.type](o);\r\n                  o._.dirty = 1;\r\n                }\r\n                params.href && (node.href = params.href);\r\n                params.title && (node.title = params.title);\r\n                params.target && (node.target = params.target);\r\n                params.cursor && (s.cursor = params.cursor);\r\n                'blur' in params && o.blur(params.blur);\r\n                if ((params.path && o.type == 'path') || newpath) {\r\n                  node.path = path2vml(\r\n                    ~Str(a.path).toLowerCase().indexOf('r')\r\n                      ? R._pathToAbsolute(a.path)\r\n                      : a.path\r\n                  );\r\n                  o._.dirty = 1;\r\n                  if (o.type == 'image') {\r\n                    o._.fillpos = [a.x, a.y];\r\n                    o._.fillsize = [a.width, a.height];\r\n                    setCoords(o, 1, 1, 0, 0, 0);\r\n                  }\r\n                }\r\n                'transform' in params && o.transform(params.transform);\r\n                if (isOval) {\r\n                  var cx = +a.cx,\r\n                    cy = +a.cy,\r\n                    rx = +a.rx || +a.r || 0,\r\n                    ry = +a.ry || +a.r || 0;\r\n                  node.path = R.format(\r\n                    'ar{0},{1},{2},{3},{4},{1},{4},{1}x',\r\n                    round((cx - rx) * zoom),\r\n                    round((cy - ry) * zoom),\r\n                    round((cx + rx) * zoom),\r\n                    round((cy + ry) * zoom),\r\n                    round(cx * zoom)\r\n                  );\r\n                  o._.dirty = 1;\r\n                }\r\n                if ('clip-rect' in params) {\r\n                  var rect = Str(params['clip-rect']).split(separator);\r\n                  if (rect.length == 4) {\r\n                    rect[2] = +rect[2] + +rect[0];\r\n                    rect[3] = +rect[3] + +rect[1];\r\n                    var div = node.clipRect || R._g.doc.createElement('div'),\r\n                      dstyle = div.style;\r\n                    dstyle.clip = R.format(\r\n                      'rect({1}px {2}px {3}px {0}px)',\r\n                      rect\r\n                    );\r\n                    if (!node.clipRect) {\r\n                      dstyle.position = 'absolute';\r\n                      dstyle.top = 0;\r\n                      dstyle.left = 0;\r\n                      dstyle.width = o.paper.width + 'px';\r\n                      dstyle.height = o.paper.height + 'px';\r\n                      node.parentNode.insertBefore(div, node);\r\n                      div.appendChild(node);\r\n                      node.clipRect = div;\r\n                    }\r\n                  }\r\n                  if (!params['clip-rect']) {\r\n                    node.clipRect && (node.clipRect.style.clip = 'auto');\r\n                  }\r\n                }\r\n                if (o.textpath) {\r\n                  var textpathStyle = o.textpath.style;\r\n                  params.font && (textpathStyle.font = params.font);\r\n                  params['font-family'] &&\r\n                    (textpathStyle.fontFamily =\r\n                      '\"' +\r\n                      params['font-family']\r\n                        .split(',')[0]\r\n                        .replace(/^['\"]+|['\"]+$/g, E) +\r\n                      '\"');\r\n                  params['font-size'] &&\r\n                    (textpathStyle.fontSize = params['font-size']);\r\n                  params['font-weight'] &&\r\n                    (textpathStyle.fontWeight = params['font-weight']);\r\n                  params['font-style'] &&\r\n                    (textpathStyle.fontStyle = params['font-style']);\r\n                }\r\n                if ('arrow-start' in params) {\r\n                  addArrow(res, params['arrow-start']);\r\n                }\r\n                if ('arrow-end' in params) {\r\n                  addArrow(res, params['arrow-end'], 1);\r\n                }\r\n                if (\r\n                  params.opacity != null ||\r\n                  params.fill != null ||\r\n                  params.src != null ||\r\n                  params.stroke != null ||\r\n                  params['stroke-width'] != null ||\r\n                  params['stroke-opacity'] != null ||\r\n                  params['fill-opacity'] != null ||\r\n                  params['stroke-dasharray'] != null ||\r\n                  params['stroke-miterlimit'] != null ||\r\n                  params['stroke-linejoin'] != null ||\r\n                  params['stroke-linecap'] != null\r\n                ) {\r\n                  var fill = node.getElementsByTagName(fillString),\r\n                    newfill = false;\r\n                  fill = fill && fill[0];\r\n                  !fill && (newfill = fill = createNode(fillString));\r\n                  if (o.type == 'image' && params.src) {\r\n                    fill.src = params.src;\r\n                  }\r\n                  params.fill && (fill.on = true);\r\n                  if (\r\n                    fill.on == null ||\r\n                    params.fill == 'none' ||\r\n                    params.fill === null\r\n                  ) {\r\n                    fill.on = false;\r\n                  }\r\n                  if (fill.on && params.fill) {\r\n                    var isURL = Str(params.fill).match(R._ISURL);\r\n                    if (isURL) {\r\n                      fill.parentNode == node && node.removeChild(fill);\r\n                      fill.rotate = true;\r\n                      fill.src = isURL[1];\r\n                      fill.type = 'tile';\r\n                      var bbox = o.getBBox(1);\r\n                      fill.position = bbox.x + S + bbox.y;\r\n                      o._.fillpos = [bbox.x, bbox.y];\r\n\r\n                      R._preload(isURL[1], function () {\r\n                        o._.fillsize = [this.offsetWidth, this.offsetHeight];\r\n                      });\r\n                    } else {\r\n                      fill.color = R.getRGB(params.fill).hex;\r\n                      fill.src = E;\r\n                      fill.type = 'solid';\r\n                      if (\r\n                        R.getRGB(params.fill).error &&\r\n                        (res.type in { circle: 1, ellipse: 1 } ||\r\n                          Str(params.fill).charAt() != 'r') &&\r\n                        addGradientFill(res, params.fill, fill)\r\n                      ) {\r\n                        a.fill = 'none';\r\n                        a.gradient = params.fill;\r\n                        fill.rotate = false;\r\n                      }\r\n                    }\r\n                  }\r\n                  if ('fill-opacity' in params || 'opacity' in params) {\r\n                    var opacity =\r\n                      ((+a['fill-opacity'] + 1 || 2) - 1) *\r\n                      ((+a.opacity + 1 || 2) - 1) *\r\n                      ((+R.getRGB(params.fill).o + 1 || 2) - 1);\r\n                    opacity = mmin(mmax(opacity, 0), 1);\r\n                    fill.opacity = opacity;\r\n                    if (fill.src) {\r\n                      fill.color = 'none';\r\n                    }\r\n                  }\r\n                  node.appendChild(fill);\r\n                  var stroke =\r\n                      node.getElementsByTagName('stroke') &&\r\n                      node.getElementsByTagName('stroke')[0],\r\n                    newstroke = false;\r\n                  !stroke && (newstroke = stroke = createNode('stroke'));\r\n                  if (\r\n                    (params.stroke && params.stroke != 'none') ||\r\n                    params['stroke-width'] ||\r\n                    params['stroke-opacity'] != null ||\r\n                    params['stroke-dasharray'] ||\r\n                    params['stroke-miterlimit'] ||\r\n                    params['stroke-linejoin'] ||\r\n                    params['stroke-linecap']\r\n                  ) {\r\n                    stroke.on = true;\r\n                  }\r\n                  (params.stroke == 'none' ||\r\n                    params.stroke === null ||\r\n                    stroke.on == null ||\r\n                    params.stroke == 0 ||\r\n                    params['stroke-width'] == 0) &&\r\n                    (stroke.on = false);\r\n                  var strokeColor = R.getRGB(params.stroke);\r\n                  stroke.on &&\r\n                    params.stroke &&\r\n                    (stroke.color = strokeColor.hex);\r\n                  opacity =\r\n                    ((+a['stroke-opacity'] + 1 || 2) - 1) *\r\n                    ((+a.opacity + 1 || 2) - 1) *\r\n                    ((+strokeColor.o + 1 || 2) - 1);\r\n                  var width = (toFloat(params['stroke-width']) || 1) * 0.75;\r\n                  opacity = mmin(mmax(opacity, 0), 1);\r\n                  params['stroke-width'] == null && (width = a['stroke-width']);\r\n                  params['stroke-width'] && (stroke.weight = width);\r\n                  width &&\r\n                    width < 1 &&\r\n                    (opacity *= width) &&\r\n                    (stroke.weight = 1);\r\n                  stroke.opacity = opacity;\r\n\r\n                  params['stroke-linejoin'] &&\r\n                    (stroke.joinstyle = params['stroke-linejoin'] || 'miter');\r\n                  stroke.miterlimit = params['stroke-miterlimit'] || 8;\r\n                  params['stroke-linecap'] &&\r\n                    (stroke.endcap =\r\n                      params['stroke-linecap'] == 'butt'\r\n                        ? 'flat'\r\n                        : params['stroke-linecap'] == 'square'\r\n                        ? 'square'\r\n                        : 'round');\r\n                  if ('stroke-dasharray' in params) {\r\n                    var dasharray = {\r\n                      '-': 'shortdash',\r\n                      '.': 'shortdot',\r\n                      '-.': 'shortdashdot',\r\n                      '-..': 'shortdashdotdot',\r\n                      '. ': 'dot',\r\n                      '- ': 'dash',\r\n                      '--': 'longdash',\r\n                      '- .': 'dashdot',\r\n                      '--.': 'longdashdot',\r\n                      '--..': 'longdashdotdot',\r\n                    };\r\n                    stroke.dashstyle = dasharray[has](\r\n                      params['stroke-dasharray']\r\n                    )\r\n                      ? dasharray[params['stroke-dasharray']]\r\n                      : E;\r\n                  }\r\n                  newstroke && node.appendChild(stroke);\r\n                }\r\n                if (res.type == 'text') {\r\n                  res.paper.canvas.style.display = E;\r\n                  var span = res.paper.span,\r\n                    m = 100,\r\n                    fontSize = a.font && a.font.match(/\\d+(?:\\.\\d*)?(?=px)/);\r\n                  s = span.style;\r\n                  a.font && (s.font = a.font);\r\n                  a['font-family'] && (s.fontFamily = a['font-family']);\r\n                  a['font-weight'] && (s.fontWeight = a['font-weight']);\r\n                  a['font-style'] && (s.fontStyle = a['font-style']);\r\n                  fontSize =\r\n                    toFloat(a['font-size'] || (fontSize && fontSize[0])) || 10;\r\n                  s.fontSize = fontSize * m + 'px';\r\n                  res.textpath.string &&\r\n                    (span.innerHTML = Str(res.textpath.string)\r\n                      .replace(/&/g, '&#38;')\r\n                      .replace(/</g, '&#60;')\r\n                      .replace(/\\n/g, '<br>'));\r\n                  var brect = span.getBoundingClientRect();\r\n                  res.W = a.w = (brect.right - brect.left) / m;\r\n                  res.H = a.h = (brect.bottom - brect.top) / m;\r\n                  // res.paper.canvas.style.display = \"none\";\r\n                  res.X = a.x;\r\n                  res.Y = a.y + res.H / 2;\r\n\r\n                  ('x' in params || 'y' in params) &&\r\n                    (res.path.v = R.format(\r\n                      'm{0},{1}l{2},{1}',\r\n                      round(a.x * zoom),\r\n                      round(a.y * zoom),\r\n                      round(a.x * zoom) + 1\r\n                    ));\r\n                  var dirtyattrs = [\r\n                    'x',\r\n                    'y',\r\n                    'text',\r\n                    'font',\r\n                    'font-family',\r\n                    'font-weight',\r\n                    'font-style',\r\n                    'font-size',\r\n                  ];\r\n                  for (var d = 0, dd = dirtyattrs.length; d < dd; d++)\r\n                    if (dirtyattrs[d] in params) {\r\n                      res._.dirty = 1;\r\n                      break;\r\n                    }\r\n\r\n                  // text-anchor emulation\r\n                  switch (a['text-anchor']) {\r\n                    case 'start':\r\n                      res.textpath.style['v-text-align'] = 'left';\r\n                      res.bbx = res.W / 2;\r\n                      break;\r\n                    case 'end':\r\n                      res.textpath.style['v-text-align'] = 'right';\r\n                      res.bbx = -res.W / 2;\r\n                      break;\r\n                    default:\r\n                      res.textpath.style['v-text-align'] = 'center';\r\n                      res.bbx = 0;\r\n                      break;\r\n                  }\r\n                  res.textpath.style['v-text-kern'] = true;\r\n                }\r\n                // res.paper.canvas.style.display = E;\r\n              },\r\n              addGradientFill = function (o, gradient, fill) {\r\n                o.attrs = o.attrs || {};\r\n                var attrs = o.attrs,\r\n                  pow = Math.pow,\r\n                  opacity,\r\n                  oindex,\r\n                  type = 'linear',\r\n                  fxfy = '.5 .5';\r\n                o.attrs.gradient = gradient;\r\n                gradient = Str(gradient).replace(\r\n                  R._radial_gradient,\r\n                  function (all, fx, fy) {\r\n                    type = 'radial';\r\n                    if (fx && fy) {\r\n                      fx = toFloat(fx);\r\n                      fy = toFloat(fy);\r\n                      pow(fx - 0.5, 2) + pow(fy - 0.5, 2) > 0.25 &&\r\n                        (fy =\r\n                          math.sqrt(0.25 - pow(fx - 0.5, 2)) *\r\n                            ((fy > 0.5) * 2 - 1) +\r\n                          0.5);\r\n                      fxfy = fx + S + fy;\r\n                    }\r\n                    return E;\r\n                  }\r\n                );\r\n                gradient = gradient.split(/\\s*\\-\\s*/);\r\n                if (type == 'linear') {\r\n                  var angle = gradient.shift();\r\n                  angle = -toFloat(angle);\r\n                  if (isNaN(angle)) {\r\n                    return null;\r\n                  }\r\n                }\r\n                var dots = R._parseDots(gradient);\r\n                if (!dots) {\r\n                  return null;\r\n                }\r\n                o = o.shape || o.node;\r\n                if (dots.length) {\r\n                  o.removeChild(fill);\r\n                  fill.on = true;\r\n                  fill.method = 'none';\r\n                  fill.color = dots[0].color;\r\n                  fill.color2 = dots[dots.length - 1].color;\r\n                  var clrs = [];\r\n                  for (var i = 0, ii = dots.length; i < ii; i++) {\r\n                    dots[i].offset &&\r\n                      clrs.push(dots[i].offset + S + dots[i].color);\r\n                  }\r\n                  fill.colors = clrs.length ? clrs.join() : '0% ' + fill.color;\r\n                  if (type == 'radial') {\r\n                    fill.type = 'gradientTitle';\r\n                    fill.focus = '100%';\r\n                    fill.focussize = '0 0';\r\n                    fill.focusposition = fxfy;\r\n                    fill.angle = 0;\r\n                  } else {\r\n                    // fill.rotate= true;\r\n                    fill.type = 'gradient';\r\n                    fill.angle = (270 - angle) % 360;\r\n                  }\r\n                  o.appendChild(fill);\r\n                }\r\n                return 1;\r\n              },\r\n              Element = function (node, vml) {\r\n                this[0] = this.node = node;\r\n                node.raphael = true;\r\n                this.id = R._oid++;\r\n                node.raphaelid = this.id;\r\n                this.X = 0;\r\n                this.Y = 0;\r\n                this.attrs = {};\r\n                this.paper = vml;\r\n                this.matrix = R.matrix();\r\n                this._ = {\r\n                  transform: [],\r\n                  sx: 1,\r\n                  sy: 1,\r\n                  dx: 0,\r\n                  dy: 0,\r\n                  deg: 0,\r\n                  dirty: 1,\r\n                  dirtyT: 1,\r\n                };\r\n                !vml.bottom && (vml.bottom = this);\r\n                this.prev = vml.top;\r\n                vml.top && (vml.top.next = this);\r\n                vml.top = this;\r\n                this.next = null;\r\n              };\r\n            var elproto = R.el;\r\n\r\n            Element.prototype = elproto;\r\n            elproto.constructor = Element;\r\n            elproto.transform = function (tstr) {\r\n              if (tstr == null) {\r\n                return this._.transform;\r\n              }\r\n              var vbs = this.paper._viewBoxShift,\r\n                vbt = vbs\r\n                  ? 's' + [vbs.scale, vbs.scale] + '-1-1t' + [vbs.dx, vbs.dy]\r\n                  : E,\r\n                oldt;\r\n              if (vbs) {\r\n                oldt = tstr = Str(tstr).replace(\r\n                  /\\.{3}|\\u2026/g,\r\n                  this._.transform || E\r\n                );\r\n              }\r\n              R._extractTransform(this, vbt + tstr);\r\n              var matrix = this.matrix.clone(),\r\n                skew = this.skew,\r\n                o = this.node,\r\n                split,\r\n                isGrad = ~Str(this.attrs.fill).indexOf('-'),\r\n                isPatt = !Str(this.attrs.fill).indexOf('url(');\r\n              matrix.translate(1, 1);\r\n              if (isPatt || isGrad || this.type == 'image') {\r\n                skew.matrix = '1 0 0 1';\r\n                skew.offset = '0 0';\r\n                split = matrix.split();\r\n                if ((isGrad && split.noRotation) || !split.isSimple) {\r\n                  o.style.filter = matrix.toFilter();\r\n                  var bb = this.getBBox(),\r\n                    bbt = this.getBBox(1),\r\n                    dx = bb.x - bbt.x,\r\n                    dy = bb.y - bbt.y;\r\n                  o.coordorigin = dx * -zoom + S + dy * -zoom;\r\n                  setCoords(this, 1, 1, dx, dy, 0);\r\n                } else {\r\n                  o.style.filter = E;\r\n                  setCoords(\r\n                    this,\r\n                    split.scalex,\r\n                    split.scaley,\r\n                    split.dx,\r\n                    split.dy,\r\n                    split.rotate\r\n                  );\r\n                }\r\n              } else {\r\n                o.style.filter = E;\r\n                skew.matrix = Str(matrix);\r\n                skew.offset = matrix.offset();\r\n              }\r\n              if (oldt !== null) {\r\n                // empty string value is true as well\r\n                this._.transform = oldt;\r\n                R._extractTransform(this, oldt);\r\n              }\r\n              return this;\r\n            };\r\n            elproto.rotate = function (deg, cx, cy) {\r\n              if (this.removed) {\r\n                return this;\r\n              }\r\n              if (deg == null) {\r\n                return;\r\n              }\r\n              deg = Str(deg).split(separator);\r\n              if (deg.length - 1) {\r\n                cx = toFloat(deg[1]);\r\n                cy = toFloat(deg[2]);\r\n              }\r\n              deg = toFloat(deg[0]);\r\n              cy == null && (cx = cy);\r\n              if (cx == null || cy == null) {\r\n                var bbox = this.getBBox(1);\r\n                cx = bbox.x + bbox.width / 2;\r\n                cy = bbox.y + bbox.height / 2;\r\n              }\r\n              this._.dirtyT = 1;\r\n              this.transform(this._.transform.concat([['r', deg, cx, cy]]));\r\n              return this;\r\n            };\r\n            elproto.translate = function (dx, dy) {\r\n              if (this.removed) {\r\n                return this;\r\n              }\r\n              dx = Str(dx).split(separator);\r\n              if (dx.length - 1) {\r\n                dy = toFloat(dx[1]);\r\n              }\r\n              dx = toFloat(dx[0]) || 0;\r\n              dy = +dy || 0;\r\n              if (this._.bbox) {\r\n                this._.bbox.x += dx;\r\n                this._.bbox.y += dy;\r\n              }\r\n              this.transform(this._.transform.concat([['t', dx, dy]]));\r\n              return this;\r\n            };\r\n            elproto.scale = function (sx, sy, cx, cy) {\r\n              if (this.removed) {\r\n                return this;\r\n              }\r\n              sx = Str(sx).split(separator);\r\n              if (sx.length - 1) {\r\n                sy = toFloat(sx[1]);\r\n                cx = toFloat(sx[2]);\r\n                cy = toFloat(sx[3]);\r\n                isNaN(cx) && (cx = null);\r\n                isNaN(cy) && (cy = null);\r\n              }\r\n              sx = toFloat(sx[0]);\r\n              sy == null && (sy = sx);\r\n              cy == null && (cx = cy);\r\n              if (cx == null || cy == null) {\r\n                var bbox = this.getBBox(1);\r\n              }\r\n              cx = cx == null ? bbox.x + bbox.width / 2 : cx;\r\n              cy = cy == null ? bbox.y + bbox.height / 2 : cy;\r\n\r\n              this.transform(this._.transform.concat([['s', sx, sy, cx, cy]]));\r\n              this._.dirtyT = 1;\r\n              return this;\r\n            };\r\n            elproto.hide = function () {\r\n              !this.removed && (this.node.style.display = 'none');\r\n              return this;\r\n            };\r\n            elproto.show = function () {\r\n              !this.removed && (this.node.style.display = E);\r\n              return this;\r\n            };\r\n            // Needed to fix the vml setViewBox issues\r\n            elproto.auxGetBBox = R.el.getBBox;\r\n            elproto.getBBox = function () {\r\n              var b = this.auxGetBBox();\r\n              if (this.paper && this.paper._viewBoxShift) {\r\n                var c = {};\r\n                var z = 1 / this.paper._viewBoxShift.scale;\r\n                c.x = b.x - this.paper._viewBoxShift.dx;\r\n                c.x *= z;\r\n                c.y = b.y - this.paper._viewBoxShift.dy;\r\n                c.y *= z;\r\n                c.width = b.width * z;\r\n                c.height = b.height * z;\r\n                c.x2 = c.x + c.width;\r\n                c.y2 = c.y + c.height;\r\n                return c;\r\n              }\r\n              return b;\r\n            };\r\n            elproto._getBBox = function () {\r\n              if (this.removed) {\r\n                return {};\r\n              }\r\n              return {\r\n                x: this.X + (this.bbx || 0) - this.W / 2,\r\n                y: this.Y - this.H,\r\n                width: this.W,\r\n                height: this.H,\r\n              };\r\n            };\r\n            elproto.remove = function () {\r\n              if (this.removed || !this.node.parentNode) {\r\n                return;\r\n              }\r\n              this.paper.__set__ && this.paper.__set__.exclude(this);\r\n              R.eve.unbind('raphael.*.*.' + this.id);\r\n              R._tear(this, this.paper);\r\n              this.node.parentNode.removeChild(this.node);\r\n              this.shape && this.shape.parentNode.removeChild(this.shape);\r\n              for (var i in this) {\r\n                this[i] =\r\n                  typeof this[i] == 'function' ? R._removedFactory(i) : null;\r\n              }\r\n              this.removed = true;\r\n            };\r\n            elproto.attr = function (name, value) {\r\n              if (this.removed) {\r\n                return this;\r\n              }\r\n              if (name == null) {\r\n                var res = {};\r\n                for (var a in this.attrs)\r\n                  if (this.attrs[has](a)) {\r\n                    res[a] = this.attrs[a];\r\n                  }\r\n                res.gradient &&\r\n                  res.fill == 'none' &&\r\n                  (res.fill = res.gradient) &&\r\n                  delete res.gradient;\r\n                res.transform = this._.transform;\r\n                return res;\r\n              }\r\n              if (value == null && R.is(name, 'string')) {\r\n                if (\r\n                  name == fillString &&\r\n                  this.attrs.fill == 'none' &&\r\n                  this.attrs.gradient\r\n                ) {\r\n                  return this.attrs.gradient;\r\n                }\r\n                var names = name.split(separator),\r\n                  out = {};\r\n                for (var i = 0, ii = names.length; i < ii; i++) {\r\n                  name = names[i];\r\n                  if (name in this.attrs) {\r\n                    out[name] = this.attrs[name];\r\n                  } else if (\r\n                    R.is(this.paper.customAttributes[name], 'function')\r\n                  ) {\r\n                    out[name] = this.paper.customAttributes[name].def;\r\n                  } else {\r\n                    out[name] = R._availableAttrs[name];\r\n                  }\r\n                }\r\n                return ii - 1 ? out : out[names[0]];\r\n              }\r\n              if (this.attrs && value == null && R.is(name, 'array')) {\r\n                out = {};\r\n                for (i = 0, ii = name.length; i < ii; i++) {\r\n                  out[name[i]] = this.attr(name[i]);\r\n                }\r\n                return out;\r\n              }\r\n              var params;\r\n              if (value != null) {\r\n                params = {};\r\n                params[name] = value;\r\n              }\r\n              value == null && R.is(name, 'object') && (params = name);\r\n              for (var key in params) {\r\n                eve('raphael.attr.' + key + '.' + this.id, this, params[key]);\r\n              }\r\n              if (params) {\r\n                for (key in this.paper.customAttributes)\r\n                  if (\r\n                    this.paper.customAttributes[has](key) &&\r\n                    params[has](key) &&\r\n                    R.is(this.paper.customAttributes[key], 'function')\r\n                  ) {\r\n                    var par = this.paper.customAttributes[key].apply(\r\n                      this,\r\n                      [].concat(params[key])\r\n                    );\r\n                    this.attrs[key] = params[key];\r\n                    for (var subkey in par)\r\n                      if (par[has](subkey)) {\r\n                        params[subkey] = par[subkey];\r\n                      }\r\n                  }\r\n                // this.paper.canvas.style.display = \"none\";\r\n                if (params.text && this.type == 'text') {\r\n                  this.textpath.string = params.text;\r\n                }\r\n                setFillAndStroke(this, params);\r\n                // this.paper.canvas.style.display = E;\r\n              }\r\n              return this;\r\n            };\r\n            elproto.toFront = function () {\r\n              !this.removed && this.node.parentNode.appendChild(this.node);\r\n              this.paper &&\r\n                this.paper.top != this &&\r\n                R._tofront(this, this.paper);\r\n              return this;\r\n            };\r\n            elproto.toBack = function () {\r\n              if (this.removed) {\r\n                return this;\r\n              }\r\n              if (this.node.parentNode.firstChild != this.node) {\r\n                this.node.parentNode.insertBefore(\r\n                  this.node,\r\n                  this.node.parentNode.firstChild\r\n                );\r\n                R._toback(this, this.paper);\r\n              }\r\n              return this;\r\n            };\r\n            elproto.insertAfter = function (element) {\r\n              if (this.removed) {\r\n                return this;\r\n              }\r\n              if (element.constructor == R.st.constructor) {\r\n                element = element[element.length - 1];\r\n              }\r\n              if (element.node.nextSibling) {\r\n                element.node.parentNode.insertBefore(\r\n                  this.node,\r\n                  element.node.nextSibling\r\n                );\r\n              } else {\r\n                element.node.parentNode.appendChild(this.node);\r\n              }\r\n              R._insertafter(this, element, this.paper);\r\n              return this;\r\n            };\r\n            elproto.insertBefore = function (element) {\r\n              if (this.removed) {\r\n                return this;\r\n              }\r\n              if (element.constructor == R.st.constructor) {\r\n                element = element[0];\r\n              }\r\n              element.node.parentNode.insertBefore(this.node, element.node);\r\n              R._insertbefore(this, element, this.paper);\r\n              return this;\r\n            };\r\n            elproto.blur = function (size) {\r\n              var s = this.node.runtimeStyle,\r\n                f = s.filter;\r\n              f = f.replace(blurregexp, E);\r\n              if (+size !== 0) {\r\n                this.attrs.blur = size;\r\n                s.filter =\r\n                  f + S + ms + '.Blur(pixelradius=' + (+size || 1.5) + ')';\r\n                s.margin = R.format('-{0}px 0 0 -{0}px', round(+size || 1.5));\r\n              } else {\r\n                s.filter = f;\r\n                s.margin = 0;\r\n                delete this.attrs.blur;\r\n              }\r\n              return this;\r\n            };\r\n\r\n            R._engine.path = function (pathString, vml) {\r\n              var el = createNode('shape');\r\n              el.style.cssText = cssDot;\r\n              el.coordsize = zoom + S + zoom;\r\n              el.coordorigin = vml.coordorigin;\r\n              var p = new Element(el, vml),\r\n                attr = { fill: 'none', stroke: '#000' };\r\n              pathString && (attr.path = pathString);\r\n              p.type = 'path';\r\n              p.path = [];\r\n              p.Path = E;\r\n              setFillAndStroke(p, attr);\r\n              vml.canvas && vml.canvas.appendChild(el);\r\n              var skew = createNode('skew');\r\n              skew.on = true;\r\n              el.appendChild(skew);\r\n              p.skew = skew;\r\n              p.transform(E);\r\n              return p;\r\n            };\r\n            R._engine.rect = function (vml, x, y, w, h, r) {\r\n              var path = R._rectPath(x, y, w, h, r),\r\n                res = vml.path(path),\r\n                a = res.attrs;\r\n              res.X = a.x = x;\r\n              res.Y = a.y = y;\r\n              res.W = a.width = w;\r\n              res.H = a.height = h;\r\n              a.r = r;\r\n              a.path = path;\r\n              res.type = 'rect';\r\n              return res;\r\n            };\r\n            R._engine.ellipse = function (vml, x, y, rx, ry) {\r\n              var res = vml.path(),\r\n                a = res.attrs;\r\n              res.X = x - rx;\r\n              res.Y = y - ry;\r\n              res.W = rx * 2;\r\n              res.H = ry * 2;\r\n              res.type = 'ellipse';\r\n              setFillAndStroke(res, {\r\n                cx: x,\r\n                cy: y,\r\n                rx: rx,\r\n                ry: ry,\r\n              });\r\n              return res;\r\n            };\r\n            R._engine.circle = function (vml, x, y, r) {\r\n              var res = vml.path(),\r\n                a = res.attrs;\r\n              res.X = x - r;\r\n              res.Y = y - r;\r\n              res.W = res.H = r * 2;\r\n              res.type = 'circle';\r\n              setFillAndStroke(res, {\r\n                cx: x,\r\n                cy: y,\r\n                r: r,\r\n              });\r\n              return res;\r\n            };\r\n            R._engine.image = function (vml, src, x, y, w, h) {\r\n              var path = R._rectPath(x, y, w, h),\r\n                res = vml.path(path).attr({ stroke: 'none' }),\r\n                a = res.attrs,\r\n                node = res.node,\r\n                fill = node.getElementsByTagName(fillString)[0];\r\n              a.src = src;\r\n              res.X = a.x = x;\r\n              res.Y = a.y = y;\r\n              res.W = a.width = w;\r\n              res.H = a.height = h;\r\n              a.path = path;\r\n              res.type = 'image';\r\n              fill.parentNode == node && node.removeChild(fill);\r\n              fill.rotate = true;\r\n              fill.src = src;\r\n              fill.type = 'tile';\r\n              res._.fillpos = [x, y];\r\n              res._.fillsize = [w, h];\r\n              node.appendChild(fill);\r\n              setCoords(res, 1, 1, 0, 0, 0);\r\n              return res;\r\n            };\r\n            R._engine.text = function (vml, x, y, text) {\r\n              var el = createNode('shape'),\r\n                path = createNode('path'),\r\n                o = createNode('textpath');\r\n              x = x || 0;\r\n              y = y || 0;\r\n              text = text || '';\r\n              path.v = R.format(\r\n                'm{0},{1}l{2},{1}',\r\n                round(x * zoom),\r\n                round(y * zoom),\r\n                round(x * zoom) + 1\r\n              );\r\n              path.textpathok = true;\r\n              o.string = Str(text);\r\n              o.on = true;\r\n              el.style.cssText = cssDot;\r\n              el.coordsize = zoom + S + zoom;\r\n              el.coordorigin = '0 0';\r\n              var p = new Element(el, vml),\r\n                attr = {\r\n                  fill: '#000',\r\n                  stroke: 'none',\r\n                  font: R._availableAttrs.font,\r\n                  text: text,\r\n                };\r\n              p.shape = el;\r\n              p.path = path;\r\n              p.textpath = o;\r\n              p.type = 'text';\r\n              p.attrs.text = Str(text);\r\n              p.attrs.x = x;\r\n              p.attrs.y = y;\r\n              p.attrs.w = 1;\r\n              p.attrs.h = 1;\r\n              setFillAndStroke(p, attr);\r\n              el.appendChild(o);\r\n              el.appendChild(path);\r\n              vml.canvas.appendChild(el);\r\n              var skew = createNode('skew');\r\n              skew.on = true;\r\n              el.appendChild(skew);\r\n              p.skew = skew;\r\n              p.transform(E);\r\n              return p;\r\n            };\r\n            R._engine.setSize = function (width, height) {\r\n              var cs = this.canvas.style;\r\n              this.width = width;\r\n              this.height = height;\r\n              width == +width && (width += 'px');\r\n              height == +height && (height += 'px');\r\n              cs.width = width;\r\n              cs.height = height;\r\n              cs.clip = 'rect(0 ' + width + ' ' + height + ' 0)';\r\n              if (this._viewBox) {\r\n                R._engine.setViewBox.apply(this, this._viewBox);\r\n              }\r\n              return this;\r\n            };\r\n            R._engine.setViewBox = function (x, y, w, h, fit) {\r\n              R.eve('raphael.setViewBox', this, this._viewBox, [\r\n                x,\r\n                y,\r\n                w,\r\n                h,\r\n                fit,\r\n              ]);\r\n              var paperSize = this.getSize(),\r\n                width = paperSize.width,\r\n                height = paperSize.height,\r\n                H,\r\n                W;\r\n              if (fit) {\r\n                H = height / h;\r\n                W = width / w;\r\n                if (w * H < width) {\r\n                  x -= (width - w * H) / 2 / H;\r\n                }\r\n                if (h * W < height) {\r\n                  y -= (height - h * W) / 2 / W;\r\n                }\r\n              }\r\n              this._viewBox = [x, y, w, h, !!fit];\r\n              this._viewBoxShift = {\r\n                dx: -x,\r\n                dy: -y,\r\n                scale: paperSize,\r\n              };\r\n              this.forEach(function (el) {\r\n                el.transform('...');\r\n              });\r\n              return this;\r\n            };\r\n            var createNode;\r\n            R._engine.initWin = function (win) {\r\n              var doc = win.document;\r\n              if (doc.styleSheets.length < 31) {\r\n                doc\r\n                  .createStyleSheet()\r\n                  .addRule('.rvml', 'behavior:url(#default#VML)');\r\n              } else {\r\n                // no more room, add to the existing one\r\n                // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\r\n                doc.styleSheets[0].addRule(\r\n                  '.rvml',\r\n                  'behavior:url(#default#VML)'\r\n                );\r\n              }\r\n              try {\r\n                !doc.namespaces.rvml &&\r\n                  doc.namespaces.add('rvml', 'urn:schemas-microsoft-com:vml');\r\n                createNode = function (tagName) {\r\n                  return doc.createElement(\r\n                    '<rvml:' + tagName + ' class=\"rvml\">'\r\n                  );\r\n                };\r\n              } catch (e) {\r\n                createNode = function (tagName) {\r\n                  return doc.createElement(\r\n                    '<' +\r\n                      tagName +\r\n                      ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"rvml\">'\r\n                  );\r\n                };\r\n              }\r\n            };\r\n            R._engine.initWin(R._g.win);\r\n            R._engine.create = function () {\r\n              var con = R._getContainer.apply(0, arguments),\r\n                container = con.container,\r\n                height = con.height,\r\n                s,\r\n                width = con.width,\r\n                x = con.x,\r\n                y = con.y;\r\n              if (!container) {\r\n                throw new Error('VML container not found.');\r\n              }\r\n              var res = new R._Paper(),\r\n                c = (res.canvas = R._g.doc.createElement('div')),\r\n                cs = c.style;\r\n              x = x || 0;\r\n              y = y || 0;\r\n              width = width || 512;\r\n              height = height || 342;\r\n              res.width = width;\r\n              res.height = height;\r\n              width == +width && (width += 'px');\r\n              height == +height && (height += 'px');\r\n              res.coordsize = zoom * 1e3 + S + zoom * 1e3;\r\n              res.coordorigin = '0 0';\r\n              res.span = R._g.doc.createElement('span');\r\n              res.span.style.cssText =\r\n                'position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;';\r\n              c.appendChild(res.span);\r\n              cs.cssText = R.format(\r\n                'top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden',\r\n                width,\r\n                height\r\n              );\r\n              if (container == 1) {\r\n                R._g.doc.body.appendChild(c);\r\n                cs.left = x + 'px';\r\n                cs.top = y + 'px';\r\n                cs.position = 'absolute';\r\n              } else {\r\n                if (container.firstChild) {\r\n                  container.insertBefore(c, container.firstChild);\r\n                } else {\r\n                  container.appendChild(c);\r\n                }\r\n              }\r\n              res.renderfix = function () {};\r\n              return res;\r\n            };\r\n            R.prototype.clear = function () {\r\n              R.eve('raphael.clear', this);\r\n              this.canvas.innerHTML = E;\r\n              this.span = R._g.doc.createElement('span');\r\n              this.span.style.cssText =\r\n                'position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;';\r\n              this.canvas.appendChild(this.span);\r\n              this.bottom = this.top = null;\r\n            };\r\n            R.prototype.remove = function () {\r\n              R.eve('raphael.remove', this);\r\n              this.canvas.parentNode.removeChild(this.canvas);\r\n              for (var i in this) {\r\n                this[i] =\r\n                  typeof this[i] == 'function' ? R._removedFactory(i) : null;\r\n              }\r\n              return true;\r\n            };\r\n\r\n            var setproto = R.st;\r\n            for (var method in elproto)\r\n              if (elproto[has](method) && !setproto[has](method)) {\r\n                setproto[method] = (function (methodname) {\r\n                  return function () {\r\n                    var arg = arguments;\r\n                    return this.forEach(function (el) {\r\n                      el[methodname].apply(el, arg);\r\n                    });\r\n                  };\r\n                })(method);\r\n              }\r\n          }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)),\r\n          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&\r\n            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n          /***/\r\n        },\r\n\r\n      /***/ eve:\r\n        /*!**********************!*\\\r\n  !*** external \"eve\" ***!\r\n  \\**********************/\r\n        /*! no static exports found */\r\n        /***/ function (module, exports) {\r\n          module.exports = __WEBPACK_EXTERNAL_MODULE_eve__;\r\n\r\n          /***/\r\n        },\r\n\r\n      /******/\r\n    }\r\n  );\r\n});\r\n\n\n//# sourceURL=webpack://pointlinejs/./src/pointlinejs/vendor/raphael/raphael.no-deps.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 		} catch(e) {
/******/ 			module.error = e;
/******/ 			throw e;
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".css";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	(() => {
/******/ 		__webpack_require__.hmrF = () => ("examples_timeline_timeline." + __webpack_require__.h() + ".hot-update.json");
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("d68900728d1a94e58d37")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "pointlinejs:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	(() => {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId, fetchPriority) {
/******/ 				return trackBlockingPromise(require.e(chunkId, fetchPriority));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				//inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results).then(function () {});
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							}, [])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								} else {
/******/ 									return setStatus("ready").then(function () {
/******/ 										return updatedModules;
/******/ 									});
/******/ 								}
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl + "../../";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/css loading */
/******/ 	(() => {
/******/ 		var createStylesheet = (chunkId, fullhref, resolve, reject) => {
/******/ 			var linkTag = document.createElement("link");
/******/ 		
/******/ 			linkTag.rel = "stylesheet";
/******/ 			linkTag.type = "text/css";
/******/ 			var onLinkComplete = (event) => {
/******/ 				// avoid mem leaks.
/******/ 				linkTag.onerror = linkTag.onload = null;
/******/ 				if (event.type === 'load') {
/******/ 					resolve();
/******/ 				} else {
/******/ 					var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 					var realHref = event && event.target && event.target.href || fullhref;
/******/ 					var err = new Error("Loading CSS chunk " + chunkId + " failed.\n(" + realHref + ")");
/******/ 					err.code = "CSS_CHUNK_LOAD_FAILED";
/******/ 					err.type = errorType;
/******/ 					err.request = realHref;
/******/ 					linkTag.parentNode.removeChild(linkTag)
/******/ 					reject(err);
/******/ 				}
/******/ 			}
/******/ 			linkTag.onerror = linkTag.onload = onLinkComplete;
/******/ 			linkTag.href = fullhref;
/******/ 		
/******/ 			document.head.appendChild(linkTag);
/******/ 			return linkTag;
/******/ 		};
/******/ 		var findStylesheet = (href, fullhref) => {
/******/ 			var existingLinkTags = document.getElementsByTagName("link");
/******/ 			for(var i = 0; i < existingLinkTags.length; i++) {
/******/ 				var tag = existingLinkTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href") || tag.getAttribute("href");
/******/ 				if(tag.rel === "stylesheet" && (dataHref === href || dataHref === fullhref)) return tag;
/******/ 			}
/******/ 			var existingStyleTags = document.getElementsByTagName("style");
/******/ 			for(var i = 0; i < existingStyleTags.length; i++) {
/******/ 				var tag = existingStyleTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href");
/******/ 				if(dataHref === href || dataHref === fullhref) return tag;
/******/ 			}
/******/ 		};
/******/ 		var loadStylesheet = (chunkId) => {
/******/ 			return new Promise((resolve, reject) => {
/******/ 				var href = __webpack_require__.miniCssF(chunkId);
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				if(findStylesheet(href, fullhref)) return resolve();
/******/ 				createStylesheet(chunkId, fullhref, resolve, reject);
/******/ 			});
/******/ 		}
/******/ 		// no chunk loading
/******/ 		
/******/ 		var oldTags = [];
/******/ 		var newTags = [];
/******/ 		var applyHandler = (options) => {
/******/ 			return { dispose: () => {
/******/ 				for(var i = 0; i < oldTags.length; i++) {
/******/ 					var oldTag = oldTags[i];
/******/ 					if(oldTag.parentNode) oldTag.parentNode.removeChild(oldTag);
/******/ 				}
/******/ 				oldTags.length = 0;
/******/ 			}, apply: () => {
/******/ 				for(var i = 0; i < newTags.length; i++) newTags[i].rel = "stylesheet";
/******/ 				newTags.length = 0;
/******/ 			} };
/******/ 		}
/******/ 		__webpack_require__.hmrC.miniCss = (chunkIds, removedChunks, removedModules, promises, applyHandlers, updatedModulesList) => {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			chunkIds.forEach((chunkId) => {
/******/ 				var href = __webpack_require__.miniCssF(chunkId);
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				var oldTag = findStylesheet(href, fullhref);
/******/ 				if(!oldTag) return;
/******/ 				promises.push(new Promise((resolve, reject) => {
/******/ 					var tag = createStylesheet(chunkId, fullhref, () => {
/******/ 						tag.as = "style";
/******/ 						tag.rel = "preload";
/******/ 						resolve();
/******/ 					}, reject);
/******/ 					oldTags.push(oldTag);
/******/ 					newTags.push(tag);
/******/ 				}));
/******/ 			});
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = __webpack_require__.hmrS_jsonp = __webpack_require__.hmrS_jsonp || {
/******/ 			"examples/timeline/timeline": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		var currentUpdatedModulesList;
/******/ 		var waitingUpdateResolves = {};
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			currentUpdatedModulesList = updatedModulesList;
/******/ 			return new Promise((resolve, reject) => {
/******/ 				waitingUpdateResolves[chunkId] = resolve;
/******/ 				// start update chunk loading
/******/ 				var url = __webpack_require__.p + __webpack_require__.hu(chunkId);
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				var loadingEnded = (event) => {
/******/ 					if(waitingUpdateResolves[chunkId]) {
/******/ 						waitingUpdateResolves[chunkId] = undefined
/******/ 						var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 						var realSrc = event && event.target && event.target.src;
/******/ 						error.message = 'Loading hot update chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 						error.name = 'ChunkLoadError';
/******/ 						error.type = errorType;
/******/ 						error.request = realSrc;
/******/ 						reject(error);
/******/ 					}
/******/ 				};
/******/ 				__webpack_require__.l(url, loadingEnded);
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		self["webpackHotUpdatepointlinejs"] = (chunkId, moreModules, runtime) => {
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					currentUpdate[moduleId] = moreModules[moduleId];
/******/ 					if(currentUpdatedModulesList) currentUpdatedModulesList.push(moduleId);
/******/ 				}
/******/ 			}
/******/ 			if(runtime) currentUpdateRuntime.push(runtime);
/******/ 			if(waitingUpdateResolves[chunkId]) {
/******/ 				waitingUpdateResolves[chunkId]();
/******/ 				waitingUpdateResolves[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.jsonpHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result;
/******/ 					if (newModuleFactory) {
/******/ 						result = getAffectedModuleEffects(moduleId);
/******/ 					} else {
/******/ 						result = {
/******/ 							type: "disposed",
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err2) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err2,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err2);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.jsonp = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.jsonp = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.jsonpHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = () => {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("./src/examples/timeline/timeline.ts");
/******/ 	
/******/ })()
;